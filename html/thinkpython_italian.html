<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.30">
<style type="text/css">
.c000{border-spacing:0;}
.c001{border-spacing:6px;border-collapse:separate;}
.c002{border:0;border-spacing:1;border-collapse:separate;}
.c003{font-family:monospace}
.c004{font-family:monospace;font-weight:bold}
.c005{font-family:sans-serif}
.c006{font-size:small}
.c007{font-size:x-large}
.c008{font-style:italic}
.c009{font-weight:bold}
.c010{text-align:center}
.c011{text-align:center;white-space:nowrap}
.c012{text-align:left;white-space:nowrap}
.c013{text-align:right;border:solid 1px;white-space:nowrap}
.c014{text-align:right;white-space:nowrap}
.c015{text-decoration:overline}
.c016{vertical-align:middle}
.c017{vertical-align:top;text-align:left;}
.c018{width:120px;height:240px;}
.c019{width:80%;height:2}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.center{text-align:center;margin-left:auto;margin-right:auto;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
a:link{color:black;}
p+p{margin-top:1em;margin-bottom:1em}
img{border:0px}
</style>
<title>Pensare in Python
</title>
</head>
<body>
<!--HEVEA command line is: hevea -fix -O -e latexonly htmlonly thinkpython_italian -->
<!--CUT STYLE book--><!--HTMLHEAD-->
<table cellpadding=10>

<tr>

<td valign="top" width=100 bgcolor="#b6459a">
</td>

<td valign="top" width=600>

<p>
<a href="http://amzn.to/Owtmjy">Buy this book at Amazon.com</a>

<!--ENDHTML-->
<!--SETENV <arg PREVTXT><img src="back.png" ALT="Previous"></arg><arg UPTXT><img src="up.png" ALT="Up"></arg><arg NEXTTXT><img src="next.png" ALT="Next"></arg>-->
<!--CUT DEF chapter 1 --><p><span class="c007">Pensare in Python: Come pensare da Informatico</span></p><p><span style="font-size:large">Allen B. Downey</span></p><p>Seconda Edizione, Versione 2.2.23</p>
<!--TOC chapter id="sec1" Prefazione-->
<h1 class="chapter" id="sec1">Chapter 0  Prefazione</h1><!--SEC END --><!--TOC section id="sec2" La strana storia di questo libro-->
<h2 class="section" id="sec2">La strana storia di questo libro</h2><!--SEC END --><p>Nel gennaio 1999 mi stavo preparando a tenere un corso introduttivo di programmazione in Java. Lo avevo tenuto già tre volte, ma ne stavo diventando sempre più insoddisfatto. Il tasso di insuccesso nel corso era troppo elevato, e anche per gli studenti che venivano promossi, il livello globale di apprendimento era troppo basso.</p><p>Uno dei problemi che avevo individuato erano i libri. Troppo grandi, con troppi dettagli non necessari su Java e privi di una guida di alto livello su come programmare. E tutti soffrivano dell’ “effetto botola”: cominciavano in modo semplice, procedevano gradualmente e poi, verso il Capitolo 5, mancava il pavimento sotto i piedi. Gli studenti si trovavano con troppo nuovo materiale e troppo velocemente, e io passavo il resto del semestre a raccogliere i cocci.</p><p>Due settimane prima dell’inizio delle lezioni, decisi allora di scrivere un libro tutto mio. I miei obiettivi erano:</p><ul class="itemize"><li class="li-itemize">Mantenerlo breve. Gli studenti preferiscono leggere 10 pagine piuttosto che 50.</li><li class="li-itemize">Prestare attenzione ai vocaboli. Cercai di ridurre al minimo i termini gergali e di spiegare ciascun termine la prima volta che veniva usato.</li><li class="li-itemize">Costruire gradualmente. Per evitare le “botole”, presi gli argomenti più ostici suddividendoli in una serie di piccoli passi.</li><li class="li-itemize">Focalizzare sulla programmazione, non sul linguaggio di programmazione. Inclusi la minima parte necessaria di Java e tralasciai il resto.</li></ul><p>Mi serviva un titolo, così d’istinto scelsi <em>Come pensare da Informatico</em>.</p><p>La prima versione era grezza, ma funzionò. Gli studenti lo lessero, e capirono abbastanza da permettermi di impiegare il tempo della lezione per gli argomenti più difficili, per quelli interessanti e (cosa più importante) per la parte pratica.</p><p>Pubblicai il libro sotto la GNU Free Documentation License, che permette ai fruitori di copiare, modificare, e distribuire il libro.</p><p><a id="hevea_default0"></a>
<a id="hevea_default1"></a></p><p>Ma il bello venne dopo. Jeff Elkner, insegnante di liceo in Virginia, utilizzò il mio libro adattandolo per Python. Mi mandò una copia della sua versione, e io ebbi la insolita esperienza di imparare Python leggendo il mio stesso libro. Con la Green Tea Press, pubblicai la prima versione Python nel 2001.
<a id="hevea_default2"></a></p><p>Nel 2003 cominciai a lavorare all’Olin College, ed ottenni di insegnare Python per la prima volta. Il contrasto con Java fu abissale. Gli studenti dovettero faticare meno, impararono di più, lavorarono su progetti più interessanti, e in generale si divertirono di più.
<a id="hevea_default3"></a></p><p>Da allora, ho continuato a sviluppare il libro, correggendo errori, migliorando alcuni esempi e aggiungendo nuovo materiale, soprattutto esercizi.</p><p>Il risultato è questo libro, che ora ha il meno grandioso titolo 
<em>Pensare in Python</em>. Ecco alcune novità:</p><ul class="itemize"><li class="li-itemize">Ho aggiunto un paragrafo sul debug alla fine di ciascun capitolo. Questi paragrafi presentano le tecniche generali per scovare ed evitare gli errori, e le avvertenze sui trabocchetti di Python.</li><li class="li-itemize">Ho aggiunto altri esercizi, da brevi test di apprendimento ad alcuni progetti sostanziosi. Per la maggior parte di essi, c’è un collegamento web alla soluzione.</li><li class="li-itemize">Ho aggiunto una serie di esercitazioni - esempi più articolati con esercizi, soluzioni e discussione. </li><li class="li-itemize">Ho ampliato la trattazione sui metodi di sviluppo di un programma e sugli schemi fondamentali di progettazione.</li><li class="li-itemize">Ho aggiunto delle appendici sul debug e l’analisi degli algoritmi.</li></ul><p>Novità di questa seconda edizione:</p><ul class="itemize"><li class="li-itemize">Il libro e tutto il codice di supporto sono stati aggiornati a Python 3.</li><li class="li-itemize">Ho aggiunto alcuni paragrafi, con ulteriori dettagli sul web, per aiutare i meno esperti ad iniziare a usare Python in un browser, in modo da non doverne affrontare l’installazione fino a quando non si sentiranno pronti.</li><li class="li-itemize">Per il capitolo <a href="#turtlechap">4</a>, al posto del mio pacchetto grafico basato su <em>turtle graphics</em>, chiamato Swampy, ho adottato il modulo <em>turtle</em> di Python, più standard, potente e facile da installare.</li><li class="li-itemize">Ho inserito un nuovo capitolo chiamato “Ulteriori strumenti”, che presenta alcune funzionalità aggiuntive di Python non indispensabili, ma che possono tornare utili.</li></ul><p>Spero che troviate piacevole utilizzare questo libro, e che vi aiuti, almeno un pochino, ad imparare a programmare e a pensare da informatici.</p><p>Allen B. Downey <br>

Olin College<br>
</p><!--TOC section id="sec3" Ringraziamenti-->
<h2 class="section" id="sec3">Ringraziamenti</h2><!--SEC END --><p>Grazie infinite a Jeff Elkner, che ha adattato a Python il mio libro su Java, ha dato inizio a questo progetto e mi ha introdotto in quello che poi è diventato il mio linguaggio di programmazione preferito. 
<a id="hevea_default4"></a></p><p>Grazie anche a Chris Meyers, che ha contribuito ad alcuni paragrafi di
<em>How to Think Like a Computer Scientist</em>.
<a id="hevea_default5"></a></p><p>Grazie alla Free Software Foundation per aver sviluppato la GNU Free Documentation License, che ha aiutato a rendere possibile la mia collaborazione con Jeff e Chris, e a Creative Commons per la licenza che uso attualmente.
<a id="hevea_default6"></a>
<a id="hevea_default7"></a>
<a id="hevea_default8"></a></p><p>Grazie ai redattori di Lulu che hanno lavorato a
<em>How to Think Like a Computer Scientist</em>.</p><p>Grazie ai redattori di O’Reilly Media che hanno lavorato a
<em>Think Python</em>.</p><p>Grazie a tutti gli studenti che hanno usato le versioni precedenti di questo libro e a tutti coloro (elencati di seguito) che hanno contribuito inviando correzioni e suggerimenti.</p><!--TOC section id="sec4" Elenco dei collaboratori-->
<h2 class="section" id="sec4">Elenco dei collaboratori</h2><!--SEC END --><p><a id="hevea_default9"></a>
Più di 100 lettori premurosi e dalla vista aguzza hanno inviato suggerimenti e correzioni negli anni passati. Il loro contributo e l’entusiasmo per questo progetto, sono stati di enorme aiuto.</p><p>Se volete proporre suggerimenti o correzioni, inviate una email a 
<span class="c003">feedback@thinkpython.com</span>. Se farò delle modifiche in seguito al vostro contributo, sarete aggiunti all’elenco dei collaboratori (a meno che non chiediate di non comparire).</p><p>Se includete almeno parte della frase in cui si trova l’errore, mi faciliterete la ricerca. Vanno bene anche numeri di pagina e di paragrafo, ma sono meno agevoli da trattare. Grazie!</p><ul class="itemize"><li class="li-itemize"><span class="c006">Lloyd Hugh Allen ha inviato una correzione al Paragrafo 8.4.</span></li><li class="li-itemize"><span class="c006">Yvon Boulianne ha inviato una correzione a un errore di semantica nel Capitolo 5.</span></li><li class="li-itemize"><span class="c006">Fred Bremmer ha inviato una correzione al Paragrafo 2.1.</span></li><li class="li-itemize"><span class="c006">Jonah Cohen ha scritto gli script Perl per convertire i sorgenti
LaTeX di questo libro in un meraviglioso HTML.</span></li><li class="li-itemize"><span class="c006">Michael Conlon ha inviato una correzione grammaticale nel Capitolo 2
e un miglioramento dello stile nel Capitolo 1, e ha iniziato la discussione sugli aspetti tecnici degli interpreti.</span></li><li class="li-itemize"><span class="c006">Benoit Girard ha inviato una correzione ad un umoristico errore nel Paragrafo 5.6.</span></li><li class="li-itemize"><span class="c006">Courtney Gleason e Katherine Smith hanno scritto <span class="c003">horsebet.py</span>,
che veniva usato come esercitazione in una versione precedente del libro. Ora il loro programma si può trovare sul sito web.</span></li><li class="li-itemize"><span class="c006">Lee Harr ha sottoposto più correzioni di quelle che è possibile elencare in questo spazio, e pertanto andrebbe considerato come uno dei principali revisori del testo.</span></li><li class="li-itemize"><span class="c006">James Kaylin è uno studente che ha usato il libro. Ha sottoposto numerose correzioni.</span></li><li class="li-itemize"><span class="c006">David Kershaw ha sistemato la funzione errata <span class="c003">catTwice</span> nel Paragrafo
3.10.</span></li><li class="li-itemize"><span class="c006">Eddie Lam ha mandato molte correzioni ai Capitoli 1, 2, e 3.
Ha anche sistemato il Makefile in modo che crei un indice alla prima esecuzione e ha aiutato nell’impostazione dello schema delle versioni. </span></li><li class="li-itemize"><span class="c006">Man-Yong Lee ha inviato una correzione al codice di esempio nel Paragrafo 2.4. </span></li><li class="li-itemize"><span class="c006">David Mayo ha puntualizzato che la parola “inconsciamente’ nel Capitolo 1 doveva essere cambiata in “subconsciamente”.</span></li><li class="li-itemize"><span class="c006">Chris McAloon ha inviato alcune correzioni ai Paragrafi 3.9 e
3.10.</span></li><li class="li-itemize"><span class="c006">Matthew J. Moelter è un collaboratore di lunga data che ha inviato numerose correzioni e suggerimenti al libro. </span></li><li class="li-itemize"><span class="c006">Simon Dicon Montford ha comunicato una definizione di funzione mancante e alcuni errori di battitura nel Capitolo 3. Ha anche trovato un errore nella funzione <span class="c003">incremento</span> nel Capitolo 13.</span></li><li class="li-itemize"><span class="c006">John Ouzts ha corretto la definizione di “valore di ritorno” nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Kevin Parks ha inviato preziosi commenti e suggerimenti su come migliorare la distribuzione del libro.</span></li><li class="li-itemize"><span class="c006">David Pool ha inviato un errore di battitura nel glossario del Capitolo 1, e gentili parole di incoraggiamento.</span></li><li class="li-itemize"><span class="c006">Michael Schmitt ha inviato correzioni al capitolo sui file e le eccezioni.</span></li><li class="li-itemize"><span class="c006">Robin Shaw ha evidenziato un errore nel Paragrafo 13.1 dove la funzione printTime veniva usata in un esempio senza essere definita.</span></li><li class="li-itemize"><span class="c006">Paul Sleigh ha trovato un errore nel Capitolo 7 e un bug nello script Perl di Jonah Cohen che genera HTML a partire da LaTeX.</span></li><li class="li-itemize"><span class="c006">Craig T. Snydal sta provando il testo in un corso presso la Drew
University. Ha contribuito con alcuni preziosi consigli e correzioni.</span></li><li class="li-itemize"><span class="c006">Ian Thomas e i suoi studenti stanno usando il testo in un corso di programmazione. Sono i primi a collaudare i capitoli della seconda metà del libro, e hanno apportato numerose correzioni e suggerimenti.</span></li><li class="li-itemize"><span class="c006">Keith Verheyden ha inviato una correzione al Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Peter Winstanley ci ha portato a conoscenza di un annoso errore nel nostro carattere latin nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Chris Wrobel ha apportato correzioni al codice nel capitolo su file I/O ed eccezioni. </span></li><li class="li-itemize"><span class="c006">Moshe Zadka ha dato un inestimabile contributo a questo progetto. Oltre a scrivere la prima bozza del capitolo sui Dizionari, è stato una continua fonte di indicazioni nei primi abbozzi di questo libro.</span></li><li class="li-itemize"><span class="c006">Christoph Zwerschke ha inviato alcune correzioni e suggerimenti pedagogici, e ha spiegato la differenza tra <em>gleich</em> e <em>selbe</em>.</span></li><li class="li-itemize"><span class="c006">James Mayer ci ha mandato correzioni a un sacco di errori di battitura e di dizione, compresi due nell’elenco dei collaboratori.</span></li><li class="li-itemize"><span class="c006">Hayden McAfee ha colto una incongruenza, fonte di probabile confusione, tra due esempi.</span></li><li class="li-itemize"><span class="c006">Angel Arnal fa parte del gruppo internazionale di traduttori e lavora sulla versione spagnola. Ha trovato anche alcuni errori nella versione inglese.</span></li><li class="li-itemize"><span class="c006">Tauhidul Hoque e Lex Berezhny hanno creato le illustrazioni del Capitolo 1 e migliorato molte delle altre.</span></li><li class="li-itemize"><span class="c006">Il Dr. Michele Alzetta ha colto un errore nel Capitolo 8 e inviato alcuni interessanti commenti pedagogici su Fibonacci e Old Maid.</span></li><li class="li-itemize"><span class="c006">Andy Mitchell ha trovato un errore di battitura nel Capitolo1 e un esempio non funzionante nel Capitolo 2.</span></li><li class="li-itemize"><span class="c006">Kalin Harvey ha suggerito un chiarimento nel Capitolo 7 e ha trovato alcuni errori di battitura.</span></li><li class="li-itemize"><span class="c006">Christopher P. Smith ha trovato alcuni errori di battitura e ci ha aiutato ad aggiornare il libro a Python 2.2 .</span></li><li class="li-itemize"><span class="c006">David Hutchins ha trovato un errore di battitura nella Premessa.</span></li><li class="li-itemize"><span class="c006">Gregor Lingl insegna Python in un liceo di Vienna, in Austria. Sta lavorando alla traduzione tedesca del libro e ha trovato un paio di brutti errori nel Capitolo 5.</span></li><li class="li-itemize"><span class="c006">Julie Peters ha trovato un errore di battitura nella Premessa.</span></li><li class="li-itemize"><span class="c006">Florin Oprina ha inviato un miglioramento in <span class="c003">makeTime</span>,
una correzione in <span class="c003">printTime</span>, e un simpatico errore di battitura.</span></li><li class="li-itemize"><span class="c006">D. J. Webre ha suggerito un chiarimento nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Ken ha trovato una manciata di errori nei Capitoli 8, 9 e 11.</span></li><li class="li-itemize"><span class="c006">Ivo Wever ha trovato un errore di battitura nel Capitolo 5 e ha suggerito un chiarimento nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Curtis Yanko ha suggerito un chiarimento nel Capitolo 2.</span></li><li class="li-itemize"><span class="c006">Ben Logan ha evidenziato alcuni errori di battitura e dei problemi nella trasposizione del libro in HTML.</span></li><li class="li-itemize"><span class="c006">Jason Armstrong ha notato una parola mancante nel Capitolo 2.</span></li><li class="li-itemize"><span class="c006">Louis Cordier ha notato un punto del Capitolo 16 dove il codice non corrispondeva al testo.</span></li><li class="li-itemize"><span class="c006">Brian Cain ha suggerito dei chiarimenti nei Capitoli 2 e 3.</span></li><li class="li-itemize"><span class="c006">Rob Black ha inviato un’ampia raccolta di correzioni, inclusi alcuni cambiamenti per Python 2.2.</span></li><li class="li-itemize"><span class="c006">Jean-Philippe Rey dell’Ecole Centrale di Parigi ha inviato un buon numero di correzioni, inclusi degli aggiornamenti per Python 2.2 e altri preziosi miglioramenti.</span></li><li class="li-itemize"><span class="c006">Jason Mader della George Washington University ha dato parecchi utili suggerimenti e correzioni.</span></li><li class="li-itemize"><span class="c006">Jan Gundtofte-Bruun ci ha ricordato che “a error” è un errore.</span></li><li class="li-itemize"><span class="c006">Abel David e Alexis Dinno ci hanno ricordato che il plurale di
“matrix” è “matrices”, non “matrixes”. Questo errore è rimasto nel libro per anni, ma due lettori con le stesse iniziali lo hanno segnalato nello stesso giorno. Curioso.</span></li><li class="li-itemize"><span class="c006">Charles Thayer ci ha spronati a sbarazzarci dei due punti che avevamo messo alla fine di alcune istruzioni, e a fare un uso più appropriato di “argomenti” e “parametri”.</span></li><li class="li-itemize"><span class="c006">Roger Sperberg ha indicato un brano dalla logica contorta nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Sam Bull ha evidenziato un paragrafo confuso nel Capitolo 2.</span></li><li class="li-itemize"><span class="c006">Andrew Cheung ha evidenziato due istanze di “uso prima di def.”</span></li><li class="li-itemize"><span class="c006">C. Corey Capel ha notato una parola mancante nel Terzo Teorema del Debugging e un errore di battitura nel Capitolo 4.</span></li><li class="li-itemize"><span class="c006">Alessandra ha aiutato a sistemare un po’ di confusione nelle Tartarughe.</span></li><li class="li-itemize"><span class="c006">Wim Champagne ha trovato un errore in un esempio di dizionario.</span></li><li class="li-itemize"><span class="c006">Douglas Wright ha trovato un problema con la divisione intera in
<span class="c003">arco</span>.</span></li><li class="li-itemize"><span class="c006">Jared Spindor ha trovato alcuni scarti alla fine di una frase.</span></li><li class="li-itemize"><span class="c006">Lin Peiheng ha inviato una serie di suggerimenti molto utili.</span></li><li class="li-itemize"><span class="c006">Ray Hagtvedt ha sottoposto due errori e un non-abbastanza-errore.</span></li><li class="li-itemize"><span class="c006">Torsten Hübsch ha evidenziato un’incongruenza in Swampy.</span></li><li class="li-itemize"><span class="c006">Inga Petuhhov ha corretto un esempio nel Capitolo 14.</span></li><li class="li-itemize"><span class="c006">Arne Babenhauserheide ha inviato alcune utili correzioni.</span></li><li class="li-itemize"><span class="c006">Mark E. Casida è bravo bravo a trovare parole ripetute.</span></li><li class="li-itemize"><span class="c006">Scott Tyler ha inserito una che mancava. E ha poi inviato una pila di correzioni.</span></li><li class="li-itemize"><span class="c006">Gordon Shephard ha inviato alcune correzioni, tutte in email separate.</span></li><li class="li-itemize"><span class="c006">Andrew Turner <span class="c003">ha tro</span>vato un errore nel Capitolo 8.</span></li><li class="li-itemize"><span class="c006">Adam Hobart ha sistemato un problema con la divisione intera in
<span class="c003">arco</span>.</span></li><li class="li-itemize"><span class="c006">Daryl Hammond e Sarah Zimmerman hanno osservato che ho servito <span class="c003">math.pi</span> troppo presto. E Zim ha trovato un errore di battitura.</span></li><li class="li-itemize"><span class="c006">George Sass ha trovato un bug in un Paragrafo sul Debug.</span></li><li class="li-itemize"><span class="c006">Brian Bingham ha suggerito l’Esercizio </span><a href="#exrotatepairs"><span class="c006">5</span></a><span class="c006">.</span></li><li class="li-itemize"><span class="c006">Leah Engelbert-Fenton ha osservato che avevo usate <span class="c003">tuple</span>
come nome di variabile, contro le mie stesse affermazioni. E poi ha trovato una manciata di errori di battitura e un “uso prima di def.”</span></li><li class="li-itemize"><span class="c006">Joe Funke ha trovato un errore di battitura.</span></li><li class="li-itemize"><span class="c006">Chao-chao Chen ha trovato un’incoerenza nell’esempio su Fibonacci.</span></li><li class="li-itemize"><span class="c006">Jeff Paine conosce la differenza tra space e spam.</span></li><li class="li-itemize"><span class="c006">Lubos Pintes ha corretto un errore di battitura.</span></li><li class="li-itemize"><span class="c006">Gregg Lind e Abigail Heithoff hanno suggerito l’Esercizio </span><a href="#checksum"><span class="c006">3</span></a><span class="c006">.</span></li><li class="li-itemize"><span class="c006">Max Hailperin ha inviato parecchie correzioni e suggerimenti. Max è uno degli autori dello straordinario <em>Concrete Abstractions</em>, che potreste prendere in considerazione dopo aver letto questo libro.</span></li><li class="li-itemize"><span class="c006">Chotipat Pornavalai ha trovato un errore in un messaggio di errore.</span></li><li class="li-itemize"><span class="c006">Stanislaw Antol ha mandato un elenco di suggerimenti molto utili.</span></li><li class="li-itemize"><span class="c006">Eric Pashman ha inviato parecchie correzioni ai Capitoli 4–11.</span></li><li class="li-itemize"><span class="c006">Miguel Azevedo ha trovato alcuni errori di battitura.</span></li><li class="li-itemize"><span class="c006">Jianhua Liu ha inviato un lungo elenco di correzioni.</span></li><li class="li-itemize"><span class="c006">Nick King ha trovato una parola mancante.</span></li><li class="li-itemize"><span class="c006">Martin Zuther ha inviato un lungo elenco di suggerimenti.</span></li><li class="li-itemize"><span class="c006">Adam Zimmerman ha trovato un’incongruenza nella mia istanza di un’ “istanza” e qualche altro errore.</span></li><li class="li-itemize"><span class="c006">Ratnakar Tiwari ha suggerito una nota a pié di pagina per spiegare i triangoli degeneri.</span></li><li class="li-itemize"><span class="c006">Anurag Goel ha suggerito un’altra soluzione per <code>alfabetica</code>
e alcune altre correzioni. E sa come si scrive Jane Austen.</span></li><li class="li-itemize"><span class="c006">Kelli Kratzer ha evidenziato un errore di battitura.</span></li><li class="li-itemize"><span class="c006">Mark Griffiths ha osservato un esempio poco chiaro nel Capitolo 3.</span></li><li class="li-itemize"><span class="c006">Roydan Ongie ha trovato un errore nel mio metodo di Newton.</span></li><li class="li-itemize"><span class="c006">Patryk Wolowiec mi ha aiutato a risolvere un problema con la versione HTML.</span></li><li class="li-itemize"><span class="c006">Mark Chonofsky mi ha riferito di una nuova parola riservata in Python 3.</span></li><li class="li-itemize"><span class="c006">Russell Coleman mi ha aiutato con la geometria.</span></li><li class="li-itemize"><span class="c006">Nam Nguyen ha trovato un errore di battitura e ha osservato che avevo usato uno schema di Decoratore senza farne menzione.</span></li><li class="li-itemize"><span class="c006">Stéphane Morin ha inviato alcune correzioni e suggerimenti.</span></li><li class="li-itemize"><span class="c006">Paul Stoop ha corretto un errore di battitura in <code>usa_solo</code>.</span></li><li class="li-itemize"><span class="c006">Eric Bronner ha notato un po’ di confusione nella discussione dell’ordine delle operazioni.</span></li><li class="li-itemize"><span class="c006">Alexandros Gezerlis ha fissato un nuovo standard per il numero e la qualità dei suoi suggerimenti. Gli siamo profondamente grati!</span></li><li class="li-itemize"><span class="c006">Gray Thomas distingue la sua destra dalla sua sinistra.</span></li><li class="li-itemize"><span class="c006">Giovanni Escobar Sosa ha inviato un lungo elenco di correzioni e suggerimenti.</span></li><li class="li-itemize"><span class="c006">Daniel Neilson ha corretto un errore nell’ordine delle operazioni.</span></li><li class="li-itemize"><span class="c006">Will McGinnis ha evidenziato che <span class="c003">polilinea</span> era definita in modo diverso in due punti.</span></li><li class="li-itemize"><span class="c006">Frank Hecker ha osservato un esercizio non ben spiegato e alcuni collegamenti non funzionanti.</span></li><li class="li-itemize"><span class="c006">Animesh B mi ha aiutato a spiegare meglio un esempio poco chiaro.</span></li><li class="li-itemize"><span class="c006">Martin Caspersen ha trovato due errori di arrotondamento.</span></li><li class="li-itemize"><span class="c006">Gregor Ulm ha inviato alcune correzioni e suggerimenti.</span></li><li class="li-itemize"><span class="c006">Dimitrios Tsirigkas ha suggerito di chiarire meglio un esercizio.</span></li><li class="li-itemize"><span class="c006">Carlos Tafur ha inviato una pagina di correzioni e suggerimenti.</span></li><li class="li-itemize"><span class="c006">Martin Nordsletten ha trovato un bug nella soluzione di un esercizio.</span></li><li class="li-itemize"><span class="c006">Sven Hoexter ha osservato che una variabile di nome <span class="c003">input</span>
oscura una funzione predefinita.</span></li><li class="li-itemize"><span class="c006">Stephen Gregory ha evidenziato il problema di <span class="c003">cmp</span> in Python 3.</span></li><li class="li-itemize"><span class="c006">Ishwar Bhat ha corretto la mia formulazione dell’ultimo teorema di Fermat.</span></li><li class="li-itemize"><span class="c006">Andrea Zanella ha tradotto il libro in italiano e, strada facendo, ha inviato alcune correzioni.</span></li><li class="li-itemize"><span class="c006">Mille grazie a Melissa Lewis e a Luciano Ramalho per gli eccellenti commenti e suggerimenti alla seconda edizione.</span></li><li class="li-itemize"><span class="c006">Grazie a Harry Percival di PythonAnywhere per il suo aiuto a chi vuole iniziare ad usare Python in un web browser.</span></li><li class="li-itemize"><span class="c006">Xavier Van Aubel ha prodotto alcune utili correzioni alla seconda edizione.</span></li><li class="li-itemize"><span class="c006">William Murray ha puntualizzato la mia definizione di divisione intera.</span></li><li class="li-itemize"><span class="c006">Per Starbäck mi ha aggiornato sui ritorni a capo universali in Python 3.</span><p><span class="c006">Hanno inoltre segnalato errori di stampa o indicato correzioni:
Czeslaw Czapla, Richard Fursa, Brian McGhie, Lokesh Kumar Makani, Matthew Shultz, Viet Le, Victor Simeone, Lars O.D. Christensen, Swarup Sahoo, Alix Etienne, Kuang He, Wei Huang, Karen Barber, e Eric Ransom.</span></p></li></ul>
<!--TOC chapter id="sec5" Lo scopo del programma-->
<h1 class="chapter" id="sec5">Chapter 1  Lo scopo del programma</h1><!--SEC END --><p>Lo scopo di questo libro è di insegnarvi a pensare da informatici. Si tratta di un modo di pensare che riassume in sé alcuni validi aspetti della matematica, dell’ingegneria e delle scienze naturali. Come i matematici, gli informatici si avvalgono di linguaggi formali per esprimere dei concetti (più precisamente, dei calcoli). Come gli ingegneri, gli informatici progettano svariate cose, compongono singole parti in sistemi e valutano costi e benefici tra varie alternative. Come i naturalisti, gli informatici osservano come si comportano dei sistemi complessi, formulano delle ipotesi e verificano le loro previsioni.
<a id="hevea_default10"></a></p><p>La risoluzione di problemi è la principale qualità di un informatico: risolvere problemi comporta la capacità di formularli, di pensare in maniera creativa alle possibili soluzioni, e di esprimere una soluzione in modo chiaro ed accurato. Imparare a programmare è quindi un ottimo modo di mettere alla prova la propria bravura nel risolvere problemi. Ecco perché questo capitolo è chiamato “Lo scopo del programma”.</p><p>Da un lato, imparerete a programmare, che è già di per sé molto utile. Da un altro, userete la programmazione come un mezzo per raggiungere uno scopo. Man mano che procederemo, quello scopo vi diventerà più chiaro.</p>
<!--TOC section id="sec6" Che cos’è un programma?-->
<h2 class="section" id="sec6">1.1  Che cos’è un programma?</h2><!--SEC END --><p>Un <span class="c009">programma</span> consiste in una serie di istruzioni che spiegano come effettuare un calcolo. Quest’ultimo può essere sia di tipo matematico, come la soluzione di un sistema di equazioni o la ricerca delle radici di un polinomio, sia di tipo simbolico, come la ricerca e la sostituzione di una parola in un documento, o ancora operazioni grafiche come l’elaborazione di un’immagine o la riproduzione di un filmato.
<a id="hevea_default11"></a></p><p>I dettagli operativi variano a seconda del linguaggio di programmazione che si usa, ma quasi tutti i linguaggi condividono un piccolo insieme di istruzioni fondamentali:</p><dl class="description"><dt class="dt-description"><span class="c009">input:</span></dt><dd class="dd-description"> Ricevimento di dati dalla tastiera, da un file, dalla rete o da un altro dispositivo.</dd><dt class="dt-description"><span class="c009">output:</span></dt><dd class="dd-description"> Invio di dati allo schermo, loro salvataggio su un file, o trasmissione verso la rete, ecc.</dd><dt class="dt-description"><span class="c009">matematiche:</span></dt><dd class="dd-description"> Esecuzione di operazioni matematiche fondamentali, come l’addizione e la moltiplicazione.</dd><dt class="dt-description"><span class="c009">condizionali:</span></dt><dd class="dd-description"> Controllo di determinate condizioni ed esecuzione del blocco di istruzioni appropriato.</dd><dt class="dt-description"><span class="c009">ripetizioni:</span></dt><dd class="dd-description"> Esecuzione ripetuta di una certa azione, di solito con qualche variazione.</dd></dl><p>Che ci crediate o no, questo è più o meno tutto ciò che serve. Qualunque programma abbiate usato, non importa quanto complesso, è fatto di istruzioni simili a queste. Potete pensare alla programmazione come ad un procedimento di suddivisione di un compito grande e complesso in una serie di compiti sempre più piccoli, fino a quando non risultano abbastanza semplici da essere eseguiti da una di queste istruzioni.
<a id="hevea_default12"></a></p>
<!--TOC section id="sec7" Avviare Python-->
<h2 class="section" id="sec7">1.2  Avviare Python</h2><!--SEC END --><p>Un possibile scoglio nell’iniziare ad usare Python, il linguaggio di programmazione che adotteremo, è quello di doverlo installare, con il software correlato, nel vostro computer. Se siete già pratici del vostro sistema operativo, e soprattutto se ve la cavate con l’interfaccia a riga di comando, non avrete nessun problema ad installare Python. Ma per i meno esperti, può risultare faticoso dover imparare contemporaneamente l’amministrazione del sistema e la programmazione.
<a id="hevea_default13"></a>
<a id="hevea_default14"></a></p><p>A chi dovesse trovare difficoltà, suggerisco per il momento di avviare Python all’interno di un browser web. Più avanti, una volta presa confidenza con Python, fornirò dei suggerimenti per l’installazione.
<a id="hevea_default15"></a></p><p>Esistono alcuni siti web che permettono di usare Python senza doverlo installare. Se avete già dimestichezza con uno di questi siti, usate pure quello. Altrimenti, vi consiglio PythonAnywhere. Trovate le istruzioni dettagliate per iniziare all’indirizzo <a href="http://tinyurl.com/thinkpython2e"><span class="c003">http://tinyurl.com/thinkpython2e</span></a>.
<a id="hevea_default16"></a></p><p>Ci sono due versioni di Python, chiamate Python 2 e Python 3. Sono molto simili, pertanto imparandone una non è difficile passare poi all’altra. Di fatto, ai primi livelli di apprendimento le differenze tra le due versioni sono poche. 
Questo libro fa riferimento alla più recente versione Python 3, ma troverete anche alcune annotazioni su Python 2.
<a id="hevea_default17"></a></p><p>L’<span class="c009">interprete</span> di Python è un programma che legge ed esegue il codice Python. A seconda del vostro ambiente di lavoro, lo potete avviare facendo click su un’icona, oppure digitando <span class="c003">python</span> in una riga di comando. In alcune installazioni di Python, è compreso anche un ambiente di sviluppo di base chiamato IDLE.
All’avvio, dovreste vedere un output simile a questo:
<a id="hevea_default18"></a></p><pre class="verbatim">Python 3.4.0 (default, Jun 19 2015, 14:20:21)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre><p>
Le prime tre righe contengono informazioni sull’interprete e il sistema operativo in cui viene eseguito, per cui nel vostro caso concreto potrebbero essere diverse. Ma occhio al numero di versione, che in questo esempio è 
<span class="c003">3.4.0</span>: comincia con 3, il che significa che state usando Python 3. Se cominciasse con 2, vorrebbe dire che state usando (avete indovinato!) Python 2.</p><p>L’ultima riga è un <span class="c009">prompt</span>, che comunica che l’interprete è pronto a ricevere il codice che inserirete. Se scrivete una riga di codice e poi premete Invio, l’interprete elabora immediatamente il risultato:
<a id="hevea_default19"></a></p><pre class="verbatim">&gt;&gt;&gt; 1 + 1
2
</pre><p>
Ora siete pronti per iniziare. D’ora in poi, darò per scontato che sappiate come avviare l’interprete di Python ed eseguire del codice.</p>
<!--TOC section id="sec8" Il primo programma-->
<h2 class="section" id="sec8">1.3  Il primo programma</h2><!--SEC END --><p>
<a id="hello"></a>
<a id="hevea_default20"></a></p><p>Per consuetudine, il primo programma che si scrive quando si affronta un nuovo linguaggio si chiama “Ciao, Mondo!”, perché non fa altro che mostrare a video le parole “Ciao, Mondo!”, e niente di più. In Python questo programma si scrive semplicemente così:</p><pre class="verbatim">print('Ciao, Mondo!')
</pre><p>
Questo è un esempio di <span class="c009">istruzione di stampa</span>, che a dispetto del nome non stampa nulla su carta: visualizza solo un risultato sullo schermo. In questo caso il risultato sono le parole:</p><pre class="verbatim">Ciao, Mondo!
</pre><p>
Gli apici nell’istruzione segnalano l’inizio e la fine del testo che deve essere visualizzato, e non fanno parte del risultato finale.
<a id="hevea_default21"></a>
<a id="hevea_default22"></a>
<a id="hevea_default23"></a></p><p>Le parentesi indicano che <span class="c003">print</span> è una funzione. Torneremo a parlare di funzioni nel Capitolo <a href="#funcchap">3</a>.
<a id="hevea_default24"></a> 
<a id="hevea_default25"></a> </p><p>In Python 2, l’istruzione di stampa è leggermente diversa: non è una funzione, per cui non si usano le parentesi.
<a id="hevea_default26"></a>
</p><pre class="verbatim">&gt;&gt;&gt; print 'Ciao, Mondo!'
</pre><p>
La differenza sarà presto chiarita meglio, ma questo ci basta per cominciare.</p>
<!--TOC section id="sec9" Operatori aritmetici-->
<h2 class="section" id="sec9">1.4  Operatori aritmetici</h2><!--SEC END --><p>
<a id="hevea_default27"></a>
<a id="hevea_default28"></a></p><p>Dopo il classico “Ciao, Mondo!”, passiamo all’aritmetica. Python dispone di
<span class="c009">operatori</span>, che sono simboli speciali che rappresentano i calcoli fondamentali, come l’addizione e la moltiplicazione.</p><p>Gli operatori <span class="c003">+</span>, <span class="c003">-</span>, e <span class="c003">*</span> eseguono nell’ordine addizione, sottrazione e moltiplicazione, come illustrato negli esempi seguenti:</p><pre class="verbatim">&gt;&gt;&gt; 40 + 2
42
&gt;&gt;&gt; 43 - 1
42
&gt;&gt;&gt; 6 * 7
42
</pre><p>
L’operatore <span class="c003">/</span> esegue la divisione:</p><pre class="verbatim">&gt;&gt;&gt; 84 / 2
42.0
</pre><p>
Vi chiederete come mai il risultato è <span class="c003">42.0</span> anziché <span class="c003">42</span>.
Lo vedremo nel prossimo paragrafo.</p><p>Infine, l’operatore <span class="c003">**</span> esegue l’elevamento a potenza; ovvero, calcola la potenza di un numero:</p><pre class="verbatim">&gt;&gt;&gt; 6**2 + 6
42
</pre><p>
In altri linguaggi viene usato il simbolo <code>^</code> per le potenze, ma in Python questo è un operatore bitwise chiamato XOR. Se non siete pratici di questi operatori, il risultato vi lascerà sorpresi:</p><pre class="verbatim">&gt;&gt;&gt; 6 ^ 2
4
</pre><p>
Non tratteremo gli operatori bitwise in questo libro, ma se volete approfondire l’argomento andate sul sito <a href="http://wiki.python.org/moin/BitwiseOperators"><span class="c003">http://wiki.python.org/moin/BitwiseOperators</span></a>.
<a id="hevea_default29"></a>
<a id="hevea_default30"></a></p>
<!--TOC section id="sec10" Valori e tipi-->
<h2 class="section" id="sec10">1.5  Valori e tipi</h2><!--SEC END --><p>
<a id="hevea_default31"></a>
<a id="hevea_default32"></a>
<a id="hevea_default33"></a></p><p>Un <span class="c009">valore</span> è uno degli elementi di base che un programma è in grado di elaborare, come ad esempio una lettera oppure un numero. Tra i valori che abbiamo visto finora: 
<span class="c003">2</span>, <span class="c003">42.0</span>, e <code>'Ciao, Mondo!'</code>.</p><p>Questi valori appartengono a <span class="c009">tipi</span> diversi:
<span class="c003">2</span> è un numero <span class="c009">intero</span>, <span class="c003">42.0</span> è un numero decimale, detto anche “a virgola mobile” o <span class="c009">floating-point</span>, e <code>'Ciao, Mondo!'</code> è una <span class="c009">stringa</span>, in quanto costituita da una sequenza di singoli caratteri collegati (dal verbo inglese <code>to string</code>, che ha anche il significato di “legare insieme”).
<a id="hevea_default34"></a>
<a id="hevea_default35"></a>
<a id="hevea_default36"></a></p><p>Per sapere a quale tipo appartiene un dato valore, basta chiederlo all’interprete:</p><pre class="verbatim">&gt;&gt;&gt; type(2)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(42.0)
&lt;class 'float'&gt;
&gt;&gt;&gt; type('Ciao, Mondo!')
&lt;class 'str'&gt;
</pre><p>Nei responsi, la parola “class” (classe) viene usata nel senso di categoria; un tipo è una categoria di valori.
<a id="hevea_default37"></a></p><p>Alle stringhe corrisponde il tipo <span class="c003">str</span>, agli interi il
tipo <span class="c003">int</span>, ai numeri con parte decimale il tipo <span class="c003">float</span>.
<a id="hevea_default38"></a>
<a id="hevea_default39"></a>
<a id="hevea_default40"></a>
<a id="hevea_default41"></a>
<a id="hevea_default42"></a>
<a id="hevea_default43"></a>
<a id="hevea_default44"></a></p><p>Di che tipo sono valori come <code>'2'</code> e <code>'42.0'</code>?
Sembrerebbero a prima vista dei numeri, ma notate che sono racchiusi tra apici come le stringhe. 
<a id="hevea_default45"></a></p><pre class="verbatim">&gt;&gt;&gt; type('2')
&lt;class 'str'&gt;
&gt;&gt;&gt; type('42.0')
&lt;class 'str'&gt;
</pre><p>
E infatti si tratta di stringhe.</p><p>Quando scrivete numeri grandi, potrebbe venirvi in mente di usare delle virgole per delimitare i gruppi di tre cifre, come in <span class="c003">1,000,000</span>. [Python utilizza la notazione anglosassone, per cui i separatori delle migliaia sono le virgole, mentre il punto è usato per separare le cifre decimali, NdT]. Questo non è un numero <em>intero</em> valido in Python, ma è comunque un qualcosa di consentito:</p><pre class="verbatim">&gt;&gt;&gt; 1,000,000
(1, 0, 0)
</pre><p>
Ma non è affatto quello che ci aspettavamo! Python in questo caso interpreta 1,000,000 come una sequenza di tre interi separati da virgole. Approfondiremo meglio questo tipo di sequenza più avanti.
<a id="hevea_default46"></a></p>
<!--TOC section id="sec11" Linguaggi formali e linguaggi naturali-->
<h2 class="section" id="sec11">1.6  Linguaggi formali e linguaggi naturali</h2><!--SEC END --><p>
<a id="hevea_default47"></a>
<a id="hevea_default48"></a></p><p>I <span class="c009">linguaggi naturali</span> sono le lingue parlate, come l’inglese, il francese, l’italiano. Non sono opera di qualcuno, benché le persone cerchino di imporre loro un ordine razionale, e si sono evoluti naturalmente.</p><p>I <span class="c009">linguaggi formali</span> sono linguaggi appositamente creati per specifiche applicazioni. Ad esempio, la notazione usata dai matematici è un linguaggio formale particolarmente indicato per esprimere le relazioni tra numeri e simboli; i chimici utilizzano un linguaggio formale per descrivere la struttura chimica delle molecole; e, soprattutto, </p><blockquote class="quote">
<span class="c009">I linguaggi di programmazione sono linguaggi formali progettati per esprimere dei calcoli.</span>
</blockquote><p>I linguaggi formali hanno delle rigide regole sintattiche che governano la struttura di ciò che devono esprimere. Per esempio,
3 + 3 = 6 è un’espressione matematica dalla sintassi corretta, ma
3 += 3 $ 6 non lo è.
In chimica, <span class="c008">H</span><sub>2</sub><span class="c008">O</span> è sintatticamente corretto, a differenza di <sub>2</sub><span class="c008">Zz</span> .</p><p>Le regole sintattiche hanno due aspetti, che riguardano i <span class="c009">simboli</span> e la
<span class="c009">struttura</span>. I simboli (in inglese <em>token</em>) sono gli elementi di base del linguaggio, come le parole, i numeri, gli elementi chimici. Un problema dell’espressione 3 += 3 $ 6 è che  $  non è un simbolo valido in matematica (almeno per quanto mi risulta). Allo stesso modo, in chimica <sub>2</sub><span class="c008">Zz</span> non è valido perché non esiste un elemento di simbolo <span class="c008">Zz</span>.
<a id="hevea_default49"></a>
<a id="hevea_default50"></a>
<a id="hevea_default51"></a></p><p>Il secondo tipo di regola sintattica, la struttura, riguarda il modo in cui sono disposti i simboli. L’espressione 3 += 3 non è strutturalmente valida perché, anche se + e = sono dei simboli validi, non è possibile che uno segua immediatamente l’altro. Allo stesso modo, il pedice numerico nelle formule chimiche deve essere scritto dopo il simbolo dell’elemento chimico, e non prima.</p><p>Questa è un@ frase ben $trutturata in italiano che conti<code>&amp;</code>ne simb*li non validi.<br>
Frase questa simboli validi tutti ha, ma struttura non valida con.</p><p>Quando leggete una frase in italiano o un’espressione in un linguaggio formale, dovete analizzare quale sia la struttura della frase (in un linguaggio naturale, questa operazione viene effettuata subconsciamente). Questo processo di analisi è chiamato <span class="c009">parsing</span>.
<a id="hevea_default52"></a></p><p>Sebbene i linguaggi formali e quelli naturali abbiano molte caratteristiche in comune (simboli, struttura, sintassi e semantica), ci sono delle differenze:
<a id="hevea_default53"></a>
<a id="hevea_default54"></a>
<a id="hevea_default55"></a></p><dl class="description"><dt class="dt-description"><span class="c009">ambiguità:</span></dt><dd class="dd-description"> I linguaggi naturali ne sono pieni, e le persone riescono a risolverla mediante indizi contestuali ed altre informazioni. I linguaggi formali sono invece progettati per essere quasi o completamente privi di ambiguità: ciascuna dichiarazione ha un unico significato, indipendente dal contesto.</dd><dt class="dt-description"><span class="c009">ridondanza:</span></dt><dd class="dd-description"> Per risolvere l’ambiguità e ridurre le incomprensioni, i linguaggi naturali impiegano molta ridondanza, ovvero sono spesso prolissi. I linguaggi formali sono meno ridondanti e più concisi.</dd><dt class="dt-description"><span class="c009">letteralità:</span></dt><dd class="dd-description"> i linguaggi naturali sono pieni di frasi idiomatiche e metafore. Se dico: “Mangiare la foglia”, presumibilmente non c’è nessuna foglia e nessuno che la mangi (è un modo di dire di una persona che si rende conto di come stanno realmente le cose). I linguaggi formali invece significano esattamente quello che dicono.</dd></dl><p>Dato che tutti noi siamo cresciuti parlando dei linguaggi naturali, possiamo trovare difficoltà ad adattarci ai linguaggi formali. La differenza tra linguaggi naturali e formali può essere paragonata a quella tra poesia e prosa, ma non solo:
<a id="hevea_default56"></a>
<a id="hevea_default57"></a></p><dl class="description"><dt class="dt-description"><span class="c009">Poesia:</span></dt><dd class="dd-description"> Le parole sono usate sia per il loro suono che per il loro significato, e l’intero componimento poetico crea complessivamente un effetto o una risposta emotiva. L’ambiguità non solo è frequente, ma spesso voluta.</dd><dt class="dt-description"><span class="c009">Prosa:</span></dt><dd class="dd-description"> Il significato letterale delle parole assume più importanza, e la struttura contribuisce a generare un maggiore significato. La prosa è più assoggettabile all’analisi della poesia, ma spesso è ancora ambigua.</dd><dt class="dt-description"><span class="c009">Programmi:</span></dt><dd class="dd-description"> Il significato di un programma per computer è letterale e privo di ambiguità, e può essere completamente interpretato mediante l’analisi dei simboli e della struttura.</dd></dl><p>I linguaggi formali sono molto più densi di significato di quelli naturali, e per questo è necessario più tempo per leggerli. Inoltre, la struttura è importante, e non sempre è bene leggere dall’alto in basso e da sinistra a destra; i programmi vanno analizzati nella propria testa, identificando i simboli e comprendendo la struttura. Infine, i dettagli contano molto: piccoli errori di ortografia e punteggiatura che sono trascurabili nei linguaggi naturali, possono diventare gravi in quelli formali.</p>
<!--TOC section id="sec12" Debug-->
<h2 class="section" id="sec12">1.7  Debug</h2><!--SEC END --><p>
<a id="hevea_default58"></a></p><p>Inevitabilmente, i programmatori commettono errori. Per ragioni storiche curiose, gli errori di programmazione sono detti <span class="c009">bug</span>, ed il procedimento della loro ricerca e correzione è chiamato <span class="c009">debug</span>.
<a id="hevea_default59"></a>
<a id="hevea_default60"></a></p><p>La programmazione, e specialmente il debug, a volte fanno emergere emozioni forti. Se siete alle prese con un bug impegnativo, vi può capitare di sentirvi arrabbiati, scoraggiati o in difficoltà.</p><p>Ci sono studi secondo i quali le persone tendono naturalmente a rapportarsi con i computer come se fossero esseri umani. Se funzionano bene, li pensiamo come compagni di squadra, e quando sono ostinati o rudi, li trattiamo come trattiamo la gente rude o ostinata (Reeves and Nass, <span class="c008">The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places</span>).
<a id="hevea_default61"></a>
<a id="hevea_default62"></a></p><p>Prepararsi a simili reazioni può aiutare ad affrontarle. Un possibile approccio è quello di pensare al computer come ad un impiegato con alcuni punti di forza, come velocità e precisione, e particolari debolezze, come mancanza di empatia e incapacità di cogliere il quadro generale.</p><p>Il vostro compito è di essere un buon manager: trovare il modo di trarre vantaggio dai pregi e mitigare i difetti. E trovare il modo di usare le vostre emozioni per affrontare i problemi, senza lasciare che le vostre reazioni interferiscano con la vostra capacità di lavorare in modo efficace.</p><p>Imparare a dare la caccia agli errori può essere noioso, ma è un’abilità preziosa, utile anche per tante altre attività oltre alla programmazione. Alla fine di ogni capitolo troverete un paragrafo dedicato al debug, come questo, con le mie riflessioni in merito. Spero vi siano di aiuto!</p>
<!--TOC section id="sec13" Glossario-->
<h2 class="section" id="sec13">1.8  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">soluzione di problemi:</span></dt><dd class="dd-description"> Procedura che consiste nel formulare un problema, trovare una soluzione ed esprimerla.
<a id="hevea_default63"></a></dd><dt class="dt-description"><span class="c009">linguaggio di alto livello:</span></dt><dd class="dd-description"> Un linguaggio di programmazione come Python, progettato per essere facile da leggere e scrivere per le persone.
<a id="hevea_default64"></a></dd><dt class="dt-description"><span class="c009">linguaggio di basso livello:</span></dt><dd class="dd-description"> Un linguaggio di programmazione progettato per essere facilmente eseguibile da un computer; è detto anche “linguaggio macchina” o “linguaggio assembly”.
<a id="hevea_default65"></a></dd><dt class="dt-description"><span class="c009">portabilità:</span></dt><dd class="dd-description"> Proprietà di un programma di poter essere eseguito su computer di tipo diverso.
<a id="hevea_default66"></a></dd><dt class="dt-description"><span class="c009">interprete:</span></dt><dd class="dd-description"> Un programma che legge un altro programma e lo esegue.
<a id="hevea_default67"></a></dd><dt class="dt-description"><span class="c009">prompt:</span></dt><dd class="dd-description"> Sequenza di caratteri mostrati dall’interprete per indicare la disponibilità a ricevere input dall’utente.
<a id="hevea_default68"></a></dd><dt class="dt-description"><span class="c009">programma:</span></dt><dd class="dd-description"> Serie di istruzioni che specifica come effettuare un calcolo.
<a id="hevea_default69"></a></dd><dt class="dt-description"><span class="c009">istruzione di stampa:</span></dt><dd class="dd-description"> Istruzione per la quale l’interprete Python visualizza un valore sullo schermo.
<a id="hevea_default70"></a>
<a id="hevea_default71"></a></dd><dt class="dt-description"><span class="c009">operatore:</span></dt><dd class="dd-description"> Simbolo speciale che rappresenta un calcolo semplice come l’addizione, la moltiplicazione o il concatenamento di stringhe.
<a id="hevea_default72"></a></dd><dt class="dt-description"><span class="c009">valore:</span></dt><dd class="dd-description"> Una unità fondamentale di dati, come un numero o una stringa, che un programma elabora.
<a id="hevea_default73"></a></dd><dt class="dt-description"><span class="c009">tipo:</span></dt><dd class="dd-description"> Una categoria di valori. I tipi visti finora sono gli interi (tipo <span class="c003">int</span>), numeri a virgola mobile o floating-point (tipo <span class="c003">float</span>), e stringhe (tipo <span class="c003">str</span>).
<a id="hevea_default74"></a></dd><dt class="dt-description"><span class="c009">intero:</span></dt><dd class="dd-description"> Tipo che rappresenta i numeri interi.
<a id="hevea_default75"></a></dd><dt class="dt-description"><span class="c009">floating-point:</span></dt><dd class="dd-description"> Tipo che rappresenta i numeri con parte decimale.
<a id="hevea_default76"></a></dd><dt class="dt-description"><span class="c009">stringa:</span></dt><dd class="dd-description"> Tipo che rappresenta sequenze di caratteri.
<a id="hevea_default77"></a></dd><dt class="dt-description"><span class="c009">linguaggio naturale:</span></dt><dd class="dd-description"> Qualunque linguaggio parlato che si è evoluto spontaneamente nel tempo.
<a id="hevea_default78"></a></dd><dt class="dt-description"><span class="c009">linguaggio formale:</span></dt><dd class="dd-description"> Qualunque linguaggio creato per scopi particolari, come l’espressione di concetti matematici o di programmi per computer. Tutti i linguaggi di programmazione sono linguaggi formali.
<a id="hevea_default79"></a></dd><dt class="dt-description"><span class="c009">simbolo o <em>token</em>:</span></dt><dd class="dd-description"> Uno degli elementi di base della struttura sintattica di un programma, analogo a una parola nei linguaggi naturali.
<a id="hevea_default80"></a>
<a id="hevea_default81"></a></dd><dt class="dt-description"><span class="c009">sintassi:</span></dt><dd class="dd-description"> Le regole che governano la struttura di un programma.
<a id="hevea_default82"></a></dd><dt class="dt-description"><span class="c009">parsing:</span></dt><dd class="dd-description"> L’esame e l’analisi della struttura sintattica di un programma.
<a id="hevea_default83"></a></dd><dt class="dt-description"><span class="c009">bug:</span></dt><dd class="dd-description"> Un errore in un programma.
<a id="hevea_default84"></a></dd><dt class="dt-description"><span class="c009">debug:</span></dt><dd class="dd-description"> L’operazione di ricerca e correzione degli errori di programmazione.
<a id="hevea_default85"></a></dd></dl>
<!--TOC section id="sec14" Esercizi-->
<h2 class="section" id="sec14">1.9  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>È opportuno leggere questo libro davanti al computer, in modo da poter provare gli esempi man mano che procedete nella lettura.</em></p><p><em>Ogni volta che sperimentate una nuova caratteristica, dovreste provare ad inserire degli errori. Ad esempio, nel programma “Ciao, mondo!”, cosa succede se dimenticate uno dei due apici? O entrambi? O se scrivete sbagliato <span class="c003">print</span>?
</em><a id="hevea_default86"></a></p><p><em>Esperimenti di questo tipo aiutano a ricordare quello che avete letto; aiutano anche nella programmazione, perché in questo modo imparate a conoscere il significato dei messaggi di errore. È meglio fare errori ora e di proposito, che più avanti e accidentalmente.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>In un’istruzione di stampa, cosa succede se dimenticate una delle parentesi, o entrambe?</em></li><li class="li-enumerate"><em>Se state cercando di stampare una stringa, cosa succede se dimenticate uno degli apici, o entrambi?</em></li><li class="li-enumerate"><em>Per rendere negativo un numero, gli si antepone un segno meno, come in 
<span class="c003">-2</span>. Cosa succede se anteponete un segno più ad un numero?
E nel caso di <span class="c003">2++2</span>?</em></li><li class="li-enumerate"><em>Nella notazione matematica, gli zeri iniziali sono ammessi, come in <span class="c003">02</span>. In questo caso, cosa succede in Python?</em></li><li class="li-enumerate"><em>Cosa succede se scrivete due valori, senza inserire in mezzo un operatore?</em></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Avviate l’interprete di Python e utilizzatelo come calcolatrice. </em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Quanti secondi ci sono in 42 minuti e 42 secondi?</em></li><li class="li-enumerate"><em>Quante miglia ci sono in 10 chilometri? Suggerimento: un miglio equivale a 1,61 km.</em></li><li class="li-enumerate"><em>Se correte una gara di 10 chilometri in 42 minuti e 42 secondi, qual è la vostra cadenza media (tempo per miglio in minuti e secondi)? Qual è la vostra velocità media, in miglia all’ora?</em><p><a id="hevea_default87"></a>
<a id="hevea_default88"></a></p></li></ol></div>
<!--TOC chapter id="sec15" Variabili, espressioni ed istruzioni-->
<h1 class="chapter" id="sec15">Chapter 2  Variabili, espressioni ed istruzioni</h1><!--SEC END --><p>Una delle caratteristiche più potenti di un linguaggio di programmazione è la capacità di elaborare delle <span class="c009">variabili</span>. Una variabile è un nome che fa riferimento ad un valore.
<a id="hevea_default89"></a></p>
<!--TOC section id="sec16" Istruzioni di assegnazione-->
<h2 class="section" id="sec16">2.1  Istruzioni di assegnazione</h2><!--SEC END --><p>
<a id="variables"></a>
<a id="hevea_default90"></a>
<a id="hevea_default91"></a></p><p>Un’<span class="c009">istruzione di assegnazione</span> serve a creare una nuova variabile, specificandone il nome, e ad assegnarle un valore:</p><pre class="verbatim">&gt;&gt;&gt; messaggio = 'E ora qualcosa di completamente diverso'
&gt;&gt;&gt; n = 17
&gt;&gt;&gt; pi = 3.141592653589793
</pre><p>
Questo esempio effettua tre assegnazioni. La prima assegna una stringa
ad una nuova variabile di nome <span class="c003">messaggio</span>; la seconda assegna il numero intero <span class="c003">17</span> alla variabile <span class="c003">n</span>; la terza assegna il valore decimale approssimato di π alla variabile <span class="c003">pi</span>.
<a id="hevea_default92"></a></p><p>Un modo frequente di raffigurare le variabili è quello di scriverne il nome e disegnare una freccia che punta al loro valore. Questa illustrazione è chiamata <span class="c009">diagramma di stato</span> perché mostra lo stato in cui si trova la variabile. La Figura <a href="#fig.state2">2.1</a> contiene i risultati delle istruzioni di assegnazione dell’esempio precedente.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian001.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 2.1: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.state2"></a>
<div class="center"><hr class="c019"></div></blockquote>
<!--TOC section id="sec17" Nomi delle variabili-->
<h2 class="section" id="sec17">2.2  Nomi delle variabili</h2><!--SEC END --><p>
<a id="hevea_default93"></a></p><p>Generalmente, i programmatori chiamano le variabili con dei nomi significativi, in modo da documentare a cosa servono.</p><p>I nomi possono essere lunghi a piacere e possono contenere sia lettere che numeri, ma non possono iniziare con un numero. È possibile usare anche le lettere maiuscole, ma per i nomi di variabile è convenzione utilizzare solo lettere minuscole. In ogni caso, tenete conto che, per l’interprete, maiuscole e minuscole sono diverse, pertanto <code>spam</code>, <code>Spam</code> e <code>SPAM</code> sono variabili diverse.</p><p>Il trattino basso o <em>underscore</em>, <code>_</code>, può far parte di un nome: è usato spesso in nomi di variabile composti da più parole (per esempio 
<code>il_tuo_nome</code> o <code>monty_python</code>).
<a id="hevea_default94"></a></p><p>Se assegnate un nome non valido alla variabile, otterrete un errore di sintassi:</p><pre class="verbatim">&gt;&gt;&gt; 76tromboni = 'grande banda'
SyntaxError: invalid syntax
&gt;&gt;&gt; altro@ = 1000000
SyntaxError: invalid syntax
&gt;&gt;&gt; class = 'Zymurgy Teorico Avanzato'
SyntaxError: invalid syntax
</pre><p>
<span class="c003">76tromboni</span> non è valido perché non inizia con una lettera.
<span class="c003">altro@</span> non è valido perché contiene un carattere non ammesso (la chiocciola <span class="c003">@</span>). Ma cosa c’è di sbagliato in <span class="c003">class</span>?</p><p>Succede che <span class="c003">class</span> è una delle <span class="c009">parole chiave riservate</span> di Python. L’interprete utilizza queste parole per riconoscere la struttura del programma, pertanto non è consentito usarle come nomi di variabile.
<a id="hevea_default95"></a></p><p>Python 3 ha queste parole chiave:</p><pre class="verbatim">False      class      finally    is         return
None       continue   for        lambda     try
True       def        from       nonlocal   while
and        del        global     not        with
as         elif       if         or         yield
assert     else       import     pass
break      except     in         raise
</pre><p>
Non occorre imparare a memoria questo elenco. Nella maggior parte degli ambienti di sviluppo, le parole chiave vengono evidenziate con un diverso colore; se cercate di usarne una come nome di variabile, ve ne accorgerete subito.</p>
<!--TOC section id="sec18" Espressioni e istruzioni-->
<h2 class="section" id="sec18">2.3  Espressioni e istruzioni</h2><!--SEC END --><p>Un’<span class="c009">espressione</span> è una combinazione di valori, variabili e operatori. Un valore è considerato già di per sé un’espressione, come pure una variabile, per cui quelle che seguono sono tutte delle espressioni valide (supponendo che alla variabile <span class="c003">n</span> sia già stato assegnato un valore):
<a id="hevea_default96"></a>
<a id="hevea_default97"></a></p><pre class="verbatim">&gt;&gt;&gt; 42
42
&gt;&gt;&gt; n
17
&gt;&gt;&gt; n + 25
42
</pre><p>Quando scrivete un’espressione al prompt dei comandi, l’interprete la
<span class="c009">valuta</span>, cioè trova il valore dell’espressione. 
Nell’esempio di prima, <span class="c003">n</span> ha valore 17 e <span class="c003">n + 25</span> ha valore 42.
<a id="hevea_default98"></a></p><p>Un’<span class="c009">istruzione</span> è una porzione di codice che l’interprete Python può eseguire e che ha un qualche effetto, come creare una variabile o mostrare un valore.</p><pre class="verbatim">&gt;&gt;&gt; n = 17
&gt;&gt;&gt; print(n)
</pre><p>
La prima riga è un’istruzione di assegnazione che dà un valore alla variabile <span class="c003">n</span>. La seconda è un’istruzione di stampa che mostra a video il valore di <span class="c003">n</span>.</p><p>Quando scrivete un’istruzione, l’interprete la <span class="c009">esegue</span>, cioè fa quello che l’istruzione dice di fare. In linea generale, le istruzioni, a differenza delle espressioni, non contengono valori.
<a id="hevea_default99"></a></p>
<!--TOC section id="sec19" Modalità script-->
<h2 class="section" id="sec19">2.4  Modalità script</h2><!--SEC END --><p>Finora abbiamo avviato Python in <span class="c009">modalità interattiva</span>, detta anche “a riga di comando”, che vuol dire interagire direttamente con l’interprete. La modalità interattiva è un buon modo per iniziare e fare esperimenti, ma se si deve lavorare con più di qualche riga di codice, può diventare in breve tempo un impiccio.</p><p>In alternativa alla riga di comando, si può scrivere e salvare un programma in un file di testo semplice, chiamato <span class="c009">script</span>, ed usare poi l’interprete in <span class="c009">modalità script</span> per eseguirlo. Per convenzione, i file contenenti programmi Python hanno nomi che terminano con l’estensione <span class="c003">.py</span> .
<a id="hevea_default100"></a>
<a id="hevea_default101"></a></p><p>Se già sapete come creare e avviare uno script nel vostro computer, siete a cavallo. Altrimenti vi consiglio di nuovo di usare PythonAnywhere. Le istruzioni per l’avvio in modalità script sono pubblicate all’indirizzo
<a href="http://tinyurl.com/thinkpython2e"><span class="c003">http://tinyurl.com/thinkpython2e</span></a>.</p><p>Poiché Python consente entrambe queste modalità, potete provare dei pezzi di codice in modalità interattiva prima di inserirli in uno script. Ma tra le due modalità, ci sono delle differenze che possono disorientare.
<a id="hevea_default102"></a>
<a id="hevea_default103"></a></p><p>Per esempio, usando Python come una calcolatrice, si può scrivere:</p><pre class="verbatim">&gt;&gt;&gt; miglia = 26.2
&gt;&gt;&gt; miglia * 1.61
42.182
</pre><p>La prima riga assegna un valore a <span class="c003">miglia</span>, e non ha alcun effetto visibile. La seconda riga è un’espressione, e l’interprete la valuta e ne mostra il risultato. Vediamo così che una maratona misura circa 42 chilometri.</p><p>Ma se scrivete lo stesso codice in uno script e lo avviate, non otterrete alcun riscontro. In modalità script, un’espressione, di per sé, non ha effetti visibili. In realtà Python valuta l’espressione, ma non ne mostra il risultato finché non gli dite esplicitamente di farlo:</p><pre class="verbatim">miglia = 26.2
print(miglia * 1.61)
</pre><p>Questo comportamento inizialmente può confondere.</p><p>Uno script di solito contiene una serie di istruzioni. Se ci sono più istruzioni, i risultati compaiono uno alla volta, man mano che le istruzioni vengono eseguite.</p><p>Per esempio lo script:</p><pre class="verbatim">print(1)
x = 2
print(x)
</pre><p>
visualizza questo:</p><pre class="verbatim">1
2
</pre><p>
mentre l’istruzione di assegnazione non produce alcun output sullo schermo.</p><p>Per controllare se avete capito tutto, scrivete le seguenti istruzioni nell’interprete Python per vedere quali effetti producono:</p><pre class="verbatim">5
x = 5
x + 1
</pre><p>
Ora scrivete le stesse istruzioni in uno script ed avviatelo. Qual è il risultato? Modificate lo script trasformando ciascuna espressione in un’istruzione di stampa, ed avviatelo nuovamente.</p>
<!--TOC section id="sec20" Ordine delle operazioni-->
<h2 class="section" id="sec20">2.5  Ordine delle operazioni</h2><!--SEC END --><p>
<a id="hevea_default104"></a>
<a id="hevea_default105"></a></p><p>Quando un’espressione contiene più operatori, la successione con cui viene eseguito il calcolo dipende dall’<span class="c009">ordine delle operazioni</span>. Per quelle matematiche, Python segue le stesse regole di precedenza comunemente usate in matematica. L’acronimo <span class="c009">PEMDAS</span> è un modo utile per ricordare le regole:</p><ul class="itemize"><li class="li-itemize"><span class="c009">P</span>arentesi: hanno il livello di precedenza più elevato e possono essere usate per forzare la valutazione di un’espressione secondo qualsiasi ordine si desideri. Dato che le espressioni tra parentesi sono valutate per prime, <span class="c003">2 * (3-1)</span> fa 4, e <span class="c003">(1+1)**(5-2)</span> fa 8. Si possono usare le parentesi anche solo per rendere più leggibile un’espressione, come in <span class="c003">(minuti * 100) / 60</span>, e in questo caso non influiscono sul risultato.</li><li class="li-itemize"><span class="c009">E</span>levamento a potenza: ha la priorità successiva, così
<span class="c003">1 + 2**3</span> fa 9, e non 27, e <span class="c003">2 * 3**2</span> fa 18, e non 36.</li><li class="li-itemize"><span class="c009">M</span>oltiplicazione e <span class="c009">D</span>ivisione hanno priorità superiore ad <span class="c009">A</span>ddizione e <span class="c009">S</span>ottrazione. Per cui <span class="c003">2*3-1</span> fa 5, e non 4, e <span class="c003">6+4/2</span> fa 8, e non 5.</li><li class="li-itemize">Gli operatori con la stessa priorità vengono valutati da sinistra verso destra (eccetto la potenza), per cui nell’espressione <span class="c003">gradi / 2 * pi</span>, la divisione viene calcolata per prima e il risultato viene moltiplicato per <span class="c003">pi</span>. Per dividere <span class="c003">gradi</span> per 2 π, dovete usare le parentesi o scrivere <span class="c003">gradi / 2 / pi</span>.</li></ul><p>Personalmente, non mi sforzo molto di ricordare la precedenza degli operatori. Se non ne sono certo guardando un’espressione, inserisco le parentesi per fugare ogni dubbio.</p>
<!--TOC section id="sec21" Operazioni sulle stringhe-->
<h2 class="section" id="sec21">2.6  Operazioni sulle stringhe</h2><!--SEC END --><p>
<a id="hevea_default106"></a>
<a id="hevea_default107"></a></p><p>In linea generale non è possibile effettuare operazioni matematiche sulle stringhe, anche se la stringa sembra un numero; quindi gli esempi che seguono non sono validi.</p><pre class="verbatim">'2'-'1'    'uova'/'facili'    'terzo'*'una magia'
</pre><p>
Ma ci sono due eccezioni: <span class="c003">+</span> e <span class="c003">*</span>.</p><p>L’operatore <span class="c003">+</span> esegue il <span class="c009">concatenamento</span>, cioè unisce le stringhe collegandole ai due estremi. Per esempio:
<a id="hevea_default108"></a></p><pre class="verbatim">&gt;&gt;&gt; primo = 'bagno'
&gt;&gt;&gt; secondo = 'schiuma'
&gt;&gt;&gt; primo + secondo
bagnoschiuma
</pre><p>Anche l’operatore <span class="c003">*</span> funziona sulle stringhe: ne esegue la ripetizione. Per esempio, <code>'Spam'*3</code> dà <code>'SpamSpamSpam'</code>. Uno degli operandi deve essere una stringa, l’altro un numero intero.</p><p>Questo utilizzo di <span class="c003">+</span> e <span class="c003">*</span> è coerente per analogia con l’addizione e la moltiplicazione. Dato che <span class="c003">4*3</span> è equivalente a <span class="c003">4+4+4</span>, ci possiamo aspettare che <code>'Spam'*3</code> sia la stessa cosa di
<code>'Spam'+'Spam'+'Spam'</code>, ed infatti è così. Tuttavia, concatenamento e ripetizione di stringhe differiscono da addizione e moltiplicazione di interi per un particolare importante. Riuscite a pensare ad una proprietà che ha l’addizione ma che non vale per il concatenamento di stringhe?
<a id="hevea_default109"></a></p>
<!--TOC section id="sec22" Commenti-->
<h2 class="section" id="sec22">2.7  Commenti</h2><!--SEC END --><p>
<a id="hevea_default110"></a></p><p>Al crescere delle sue dimensioni e della sua complessità, un programma diventa anche sempre più difficile da leggere. I linguaggi formali sono densi di significato, e spesso non è facile guardare un segmento di codice scritto da altri e capire immediatamente che cosa fa, o perché.</p><p>Per questo motivo, è buona abitudine aggiungere ai vostri programmi delle annotazioni che spiegano in linguaggio naturale ciò che il programma sta facendo. Queste annotazioni si chiamano <span class="c009">commenti</span>, contrassegnati dal simbolo <code>#</code>:</p><pre class="verbatim"># calcola la percentuale di ora trascorsa
percentuale = (minuti * 100) / 60
</pre><p>
In questo caso, il commento si trova su una riga a sé stante, ma potete anche inserire un commento in coda a una riga:</p><pre class="verbatim">percentuale = (minuti * 100) / 60     # percentuale di un'ora
</pre><p>
Tutto ciò che viene scritto dopo il simbolo <span class="c003">#</span> e fino alla fine della riga, viene trascurato e non influisce in alcun modo sull’esecuzione del programma. </p><p>I commenti più utili sono quelli che documentano caratteristiche del codice di non immediata comprensione. È ragionevole supporre che chi legge il codice possa capire <em>cosa</em> esso faccia; è più utile spiegare <em>perché</em>.</p><p>Questo commento è ridondante e inutile:</p><pre class="verbatim">v = 5     # assegna 5 a v
</pre><p>
Questo commento contiene invece un’informazione utile che non è contenuta nel codice:</p><pre class="verbatim">v = 5     # velocità in metri/secondo 
</pre><p>
Dei buoni nomi di variabile possono ridurre la necessità di commenti, ma nomi lunghi possono complicare la lettura, pertanto va trovato un giusto compromesso.</p>
<!--TOC section id="sec23" Debug-->
<h2 class="section" id="sec23">2.8  Debug</h2><!--SEC END --><p>
<a id="hevea_default111"></a></p><p>In un programma si possono verificare tre tipi di errori: gli errori di sintassi, gli errori in esecuzione e gli errori di semantica. È utile analizzarli singolarmente per facilitarne l’individuazione.</p>
<!--TOC subsection id="sec24" Errori di sintassi-->
<h3 class="subsection" id="sec24">2.8.1  Errori di sintassi</h3><!--SEC END --><p>
<a id="hevea_default112"></a>
<a id="hevea_default113"></a>
<a id="hevea_default114"></a></p><p>Il termine <span class="c009">sintassi</span> si riferisce alla struttura di un programma e alle regole che la governano. Ad esempio, le parentesi devono essere sempre presenti a coppie corrispondenti, così <span class="c003">(1 + 2)</span> è corretto, ma <span class="c003">8)</span> è un <span class="c009">errore di sintassi</span>.
<a id="hevea_default115"></a> 
<a id="hevea_default116"></a></p><p>Se c’è anche un solo errore di sintassi in qualche parte del programma, non sarete in grado di eseguirlo: Python visualizzerà subito un messaggio d’errore e lo terminerà. Nelle prime settimane della vostra carriera di programmatori, dovrete probabilmente dedicare molto tempo a correggere errori di sintassi. Ma con l’esperienza, ne commetterete meno e li troverete più velocemente.</p>
<!--TOC subsection id="sec25" Errori in esecuzione-->
<h3 class="subsection" id="sec25">2.8.2  Errori in esecuzione</h3><!--SEC END --><p>
<a id="runtime"></a></p><p>Il secondo tipo di errore è l’<span class="c009">errore in esecuzione</span> (o di <em>runtime</em>), così chiamato perché non compare fino a quando il programma non viene eseguito. Questi errori sono anche detti <span class="c009">eccezioni</span> perché indicano che è accaduto qualcosa di eccezionale (e di spiacevole) durante l’esecuzione.
<a id="hevea_default117"></a>
<a id="hevea_default118"></a>
<a id="hevea_default119"></a>
<a id="hevea_default120"></a></p><p>Gli errori di runtime sono molto rari nei programmi semplici, come quelli che vedrete nei primi capitoli di questo libro, e potrebbe passare un po’ di tempo prima di incontrarne uno.</p>
<!--TOC subsection id="sec26" Errori di semantica-->
<h3 class="subsection" id="sec26">2.8.3  Errori di semantica</h3><!--SEC END --><p>
<a id="hevea_default121"></a>
<a id="hevea_default122"></a>
<a id="hevea_default123"></a>
<a id="hevea_default124"></a></p><p>Il terzo tipo di errore è l’<span class="c009">errore di semantica</span> (o di logica), che è correlato al significato del programma. In presenza di un errore di semantica, il programma verrà eseguito senza che compaia alcun messaggio di errore, ma non farà la cosa giusta: farà qualcosa di diverso. Nello specifico, farà esattamente ciò che voi gli avete detto di fare, esprimendovi in modo sbagliato.</p><p>Gli errori di semantica sono insidiosi e identificarli può essere complicato, perché occorre lavorare a ritroso, partendo dai risultati dell’esecuzione e cercando di risalire a che cosa non sia andato per il verso giusto.</p>
<!--TOC section id="sec27" Glossario-->
<h2 class="section" id="sec27">2.9  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">variabile:</span></dt><dd class="dd-description"> Un nome che fa riferimento ad un valore.
<a id="hevea_default125"></a></dd><dt class="dt-description"><span class="c009">assegnazione:</span></dt><dd class="dd-description"> Istruzione che assegna un valore ad una variabile.
<a id="hevea_default126"></a></dd><dt class="dt-description"><span class="c009">diagramma di stato:</span></dt><dd class="dd-description"> Rappresentazione grafica di una serie di variabili e dei valori ai quali esse si riferiscono.
<a id="hevea_default127"></a></dd><dt class="dt-description"><span class="c009">parola chiave riservata:</span></dt><dd class="dd-description"> Parola chiave destinata esclusivamente all’analisi del programma e che non può essere usata come nome di variabile o di funzione, come <span class="c003">if</span>, <span class="c003">def</span>, e <span class="c003">while</span>.
<a id="hevea_default128"></a></dd><dt class="dt-description"><span class="c009">operando:</span></dt><dd class="dd-description"> Uno dei valori sui quali si applica un operatore.
<a id="hevea_default129"></a></dd><dt class="dt-description"><span class="c009">espressione:</span></dt><dd class="dd-description"> Combinazione di variabili, operatori e valori che rappresentano un unico valore risultante.
<a id="hevea_default130"></a></dd><dt class="dt-description"><span class="c009">valutare:</span></dt><dd class="dd-description"> Semplificare un’espressione eseguendo una serie di operazioni che producono un unico valore.
<a id="hevea_default131"></a></dd><dt class="dt-description"><span class="c009">istruzione:</span></dt><dd class="dd-description"> Porzione di codice che rappresenta un comando o un’azione, come le istruzioni di assegnazione e di stampa che abbiamo visto finora.
<a id="hevea_default132"></a></dd><dt class="dt-description"><span class="c009">eseguire:</span></dt><dd class="dd-description"> Dare efficacia a un’istruzione e fare ciò che dice.
<a id="hevea_default133"></a></dd><dt class="dt-description"><span class="c009">modalità interattiva:</span></dt><dd class="dd-description"> Un modo di usare l’interprete Python, scrivendo del codice al prompt.
<a id="hevea_default134"></a></dd><dt class="dt-description"><span class="c009">modalità script:</span></dt><dd class="dd-description"> Un modo di usare l’interprete Python, leggendo del codice da uno script ed eseguendolo.
<a id="hevea_default135"></a></dd><dt class="dt-description"><span class="c009">script:</span></dt><dd class="dd-description"> Un programma scritto e memorizzato in un file di testo.
<a id="hevea_default136"></a></dd><dt class="dt-description"><span class="c009">ordine delle operazioni:</span></dt><dd class="dd-description"> Regole che stabiliscono l’ordine in cui vengono valutate le espressioni che contengono più operandi ed operatori.
<a id="hevea_default137"></a></dd><dt class="dt-description"><span class="c009">concatenare:</span></dt><dd class="dd-description"> Unire due stringhe accodando la seconda alla prima.
<a id="hevea_default138"></a></dd><dt class="dt-description"><span class="c009">commento:</span></dt><dd class="dd-description"> Annotazione in un programma, rivolta ad altri programmatori (o a chi legge il codice sorgente), che non ha effetti sull’esecuzione del programma.
<a id="hevea_default139"></a></dd><dt class="dt-description"><span class="c009">errore di sintassi:</span></dt><dd class="dd-description"> Errore in un programma che ne rende impossibile l’analisi (il programma non è interpretabile).
<a id="hevea_default140"></a></dd><dt class="dt-description"><span class="c009">eccezione:</span></dt><dd class="dd-description"> Errore (detto anche di <em>runtime</em>) che si verifica mentre il programma è in esecuzione.
<a id="hevea_default141"></a></dd><dt class="dt-description"><span class="c009">semantica:</span></dt><dd class="dd-description"> Il significato logico di un programma.
<a id="hevea_default142"></a></dd><dt class="dt-description"><span class="c009">errore di semantica:</span></dt><dd class="dd-description"> Errore nel programma tale da produrre risultati diversi da quelli che il programmatore si aspettava.
<a id="hevea_default143"></a></dd></dl>
<!--TOC section id="sec28" Esercizi-->
<h2 class="section" id="sec28">2.10  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Rinnovo la raccomandazione del capitolo precedente: ogni volta che apprendete qualcosa di nuovo, provatelo in modalità interattiva e fate degli errori di proposito per vedere cosa non funziona.</em></p><ul class="itemize"><li class="li-itemize"><em>Abbiamo visto che <span class="c003">n = 42</span> è valido. E <span class="c003">42 = n</span>?</em></li><li class="li-itemize"><em>E se scrivete <span class="c003">x = y = 1</span>?</em></li><li class="li-itemize"><em>In alcuni linguaggi, ogni istruzione termina con un punto e virgola, <span class="c003">;</span>.
Cosa succede se mettete un punto e virgola alla fine di un’istruzione in Python?</em></li><li class="li-itemize"><em>E se mettete un punto alla fine di un’istruzione?</em></li><li class="li-itemize"><em>Nella notazione matematica potete indicare la moltiplicazione di </em><span class="c008">x</span><em> per </em><span class="c008">y</span><em> scrivendo: </em><span class="c008">x y</span><em>. 
Cosa succede scrivendo questo in Python?</em></li></ul></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Fate un po’ di pratica con l’interprete Python usandolo come calcolatrice:
</em><a id="hevea_default144"></a></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Il volume di una sfera di raggio </em><span class="c008">r</span><em> è </em>4/3 π <span class="c008">r</span><sup>3</sup><em>.
Che volume ha una sfera di raggio 5?</em></li><li class="li-enumerate"><em>Il prezzo di copertina di un libro è <code>€</code> 24,95, ma una libreria ottiene il 40% di sconto. I costi di spedizione sono <code>€</code> 3 per la prima copia e 75 centesimi per ogni copia aggiuntiva. Qual è il costo totale di 60 copie?</em></li><li class="li-enumerate"><em>Se uscite di casa alle 6:52 di mattina e correte 1 miglio a ritmo blando (8:15 al miglio), poi 3 miglia a ritmo moderato (7:12 al miglio), quindi 1 altro miglio a ritmo blando, a che ora tornate a casa per colazione?
</em><a id="hevea_default145"></a></li></ol></div>
<!--TOC chapter id="sec29" Funzioni-->
<h1 class="chapter" id="sec29">Chapter 3  Funzioni</h1><!--SEC END --><p>
<a id="funcchap"></a></p><p>Nell’ambito della programmazione, una <span class="c009">funzione</span> è una serie di istruzioni che esegue un calcolo, alla quale viene assegnato un nome. Per definire una funzione, dovete specificarne il nome e scrivere la serie di istruzioni. In un secondo tempo, potete “chiamare” la funzione mediante il nome che le avete assegnato. 
<a id="hevea_default146"></a></p>
<!--TOC section id="sec30" Chiamate di funzione-->
<h2 class="section" id="sec30">3.1  Chiamate di funzione</h2><!--SEC END --><p>
<a id="functionchap"></a>
<a id="hevea_default147"></a></p><p>Abbiamo già visto un esempio di una <span class="c009">chiamata di funzione</span>:</p><pre class="verbatim">&gt;&gt;&gt; type(42)
&lt;class 'int'&gt;
</pre><p>
Il nome di questa funzione è <span class="c003">type</span>. L’espressione tra parentesi è chiamata <span class="c009">argomento</span> della funzione, e il risultato che produce è il tipo di valore dell’argomento che abbiamo inserito.
<a id="hevea_default148"></a></p><p>Si usa dire che una funzione “prende” o “riceve” un argomento e, una volta eseguita l’elaborazione, “ritorna” o “restituisce” un risultato. Il risultato è detto <span class="c009">valore di ritorno</span>.
<a id="hevea_default149"></a>
<a id="hevea_default150"></a></p><p>Python contiene una raccolta di funzioni per convertire i valori da un tipo a un altro. La funzione <span class="c003">int</span> prende un dato valore e lo converte, se possibile, in un numero intero. Se la conversione è impossibile, Python comunica che si è verificato un errore:
<a id="hevea_default151"></a>
<a id="hevea_default152"></a>
<a id="hevea_default153"></a></p><pre class="verbatim">&gt;&gt;&gt; int('32')
32
&gt;&gt;&gt; int('Ciao')
ValueError: invalid literal for int(): Ciao
</pre><p>
<span class="c003">int</span> può anche convertire valori in virgola mobile in interi, ma non arrotonda bensì tronca la parte decimale.</p><pre class="verbatim">&gt;&gt;&gt; int(3.99999)
3
&gt;&gt;&gt; int(-2.3)
-2
</pre><p>
La funzione <span class="c003">float</span> converte interi e stringhe in numeri a virgola mobile:
<a id="hevea_default154"></a>
<a id="hevea_default155"></a></p><pre class="verbatim">&gt;&gt;&gt; float(32)
32.0
&gt;&gt;&gt; float('3.14159')
3.14159
</pre><p>
Infine, <span class="c003">str</span> converte l’argomento in una stringa:
<a id="hevea_default156"></a>
<a id="hevea_default157"></a></p><pre class="verbatim">&gt;&gt;&gt; str(32)
'32'
&gt;&gt;&gt; str(3.14159)
'3.14159'
</pre>
<!--TOC section id="sec31" Funzioni matematiche-->
<h2 class="section" id="sec31">3.2  Funzioni matematiche</h2><!--SEC END --><p>
<a id="hevea_default158"></a></p><p>Python è provvisto di un modulo matematico che comprende buona parte delle funzioni matematiche d’uso frequente. Un <span class="c009">modulo</span> è un file che contiene una raccolta di funzioni correlate.
<a id="hevea_default159"></a>
<a id="hevea_default160"></a></p><p>Prima di poter usare le funzioni contenute in un modulo, lo dobbiamo importare con un’<span class="c009">istruzione di importazione</span>:</p><pre class="verbatim">&gt;&gt;&gt; import math
</pre><p>
Questa istruzione crea un <span class="c009">oggetto modulo</span> chiamato math. Se visualizzate l’oggetto modulo, ottenete alcune informazioni a riguardo:</p><pre class="verbatim">&gt;&gt;&gt; math
&lt;module 'math' (built-in)&gt;
</pre><p>
L’oggetto modulo contiene le funzioni e le variabili definite all’interno del modulo stesso. Per accedere a una funzione del modulo, dovete specificare, nell’ordine, il nome del modulo e il nome della funzione, separati da un punto. Questo formato è chiamato <span class="c009">notazione a punto</span> o <em>dot notation</em>.
<a id="hevea_default161"></a>
<a id="hevea_default162"></a></p><pre class="verbatim">&gt;&gt;&gt; rapporto = potenza_segnale / potenza_rumore
&gt;&gt;&gt; decibel = 10 * math.log10(rapporto)

&gt;&gt;&gt; radianti = 0.7
&gt;&gt;&gt; altezza = math.sin(radianti)
</pre><p>
Il primo esempio utilizza la funzione <code>math.log10</code> per calcolare un rapporto segnale/rumore in decibel (a condizione che siano stati definiti i valori di <code>potenza_segnale</code> e <code>potenza_rumore</code>). Il modulo math contiene anche <span class="c003">log</span>, che calcola i logaritmi naturali in base <span class="c003">e</span>.
<a id="hevea_default163"></a>
<a id="hevea_default164"></a>
<a id="hevea_default165"></a>
<a id="hevea_default166"></a>
<a id="hevea_default167"></a></p><p>Il secondo esempio calcola il seno della variabile <span class="c003">radianti</span>. Il nome della variabile spiega già che <span class="c003">sin</span> e le altre funzioni trigonometriche (<span class="c003">cos</span>, <span class="c003">tan</span>, ecc.) accettano argomenti espressi in radianti. Per convertire da gradi in radianti occorre dividere per 180 e moltiplicare per π:</p><pre class="verbatim">&gt;&gt;&gt; gradi = 45
&gt;&gt;&gt; radianti = gradi / 180.0 * math.pi
&gt;&gt;&gt; math.sin(radianti)
0.707106781187
</pre><p>
L’espressione <span class="c003">math.pi</span> ricava la variabile <span class="c003">pi</span> dal modulo matematico. Il suo valore è un numero decimale, approssimazione di π, accurata a circa 15 cifre. 
<a id="hevea_default168"></a></p><p>Se ricordate la trigonometria, potete verificare il risultato precedente confrontandolo con la radice quadrata di 2 diviso 2:
<a id="hevea_default169"></a>
<a id="hevea_default170"></a></p><pre class="verbatim">&gt;&gt;&gt; math.sqrt(2) / 2.0
0.707106781187
</pre>
<!--TOC section id="sec32" Composizione-->
<h2 class="section" id="sec32">3.3  Composizione</h2><!--SEC END --><p>
<a id="hevea_default171"></a></p><p>Finora, abbiamo considerato gli elementi di un programma - variabili, espressioni e istruzioni - separatamente, senza discutere di come utilizzarli insieme.</p><p>Una delle caratteristiche più utili dei linguaggi di programmazione è la loro capacità di prendere dei piccoli mattoni e <span class="c009">comporli</span> tra loro. Per esempio, l’argomento di una funzione può essere un qualunque tipo di espressione, operazioni aritmetiche incluse:</p><pre class="verbatim">x = math.sin(gradi / 360.0 * 2 * math.pi)
</pre><p>
E anche chiamate di funzione:</p><pre class="verbatim">x = math.exp(math.log(x+1))
</pre><p>
In linea generale, dovunque potete mettere un valore potete anche mettere un’espressione a piacere, con un’eccezione: il lato sinistro di un’istruzione di assegnazione deve essere un nome di variabile. Ogni altra espressione darebbe un errore di sintassi (vedremo più avanti le eccezioni a questa regola).</p><pre class="verbatim">&gt;&gt;&gt; minuti = ore * 60                 # giusto
&gt;&gt;&gt; ore * 60 = minuti                 # sbagliato!
SyntaxError: can't assign to operator
</pre><p>
<a id="hevea_default172"></a>
<a id="hevea_default173"></a></p>
<!--TOC section id="sec33" Aggiungere nuove funzioni-->
<h2 class="section" id="sec33">3.4  Aggiungere nuove funzioni</h2><!--SEC END --><p>Finora abbiamo usato solo funzioni predefinite o “built-in”, che sono parte integrante di Python, ma è anche possibile crearne di nuove.
Una <span class="c009">definizione di funzione</span> specifica il nome di una nuova funzione e la serie di istruzioni che viene eseguita quando la funzione viene chiamata.
<a id="hevea_default174"></a>
<a id="hevea_default175"></a>
<a id="hevea_default176"></a></p><p>Ecco un esempio:</p><pre class="verbatim">def stampa_brani():
    print('Terror di tutta la foresta egli è,')
    print("Con l'ascia in mano si sente un re.")
</pre><p>
<span class="c003">def</span> è una parola chiave riservata che indica la definizione di una nuova funzione. Il nome della funzione è <code>stampa_brani</code>. Le regole per i nomi delle funzioni sono le stesse dei nomi delle variabili: lettere, numeri e underscore (<code>_</code>) sono permessi, ma il primo carattere non può essere un numero. Non si possono usare parole riservate, e bisogna evitare di avere una funzione e una variabile con lo stesso nome
<a id="hevea_default177"></a>
<a id="hevea_default178"></a>
<a id="hevea_default179"></a></p><p>Le parentesi vuote dopo il nome indicano che la funzione non accetta alcun argomento.
<a id="hevea_default180"></a>
<a id="hevea_default181"></a>
<a id="hevea_default182"></a>
<a id="hevea_default183"></a>
<a id="hevea_default184"></a></p><p>La prima riga della definizione di funzione è chiamata <span class="c009">intestazione</span>;
il resto è detto <span class="c009">corpo</span>. L’intestazione deve terminare con i due punti, e il corpo deve essere obbligatoriamente indentato, cioè deve avere un rientro rispetto all’intestazione. Per convenzione, l’indentazione è sempre di quattro spazi. Il corpo può contenere un qualsiasi numero di istruzioni.</p><p>Le stringhe nelle istruzioni di stampa sono racchiuse tra apici (<code>' '</code>) oppure virgolette (<code>" "</code>). Virgolette e apici sono equivalenti; la maggioranza degli utenti usa gli apici, eccetto nei casi in cui nel testo da stampare sono contenuti degli apici (che possono essere usati anche come apostrofi o accenti). In questi casi, frequenti con l’italiano, bisogna usare le virgolette.</p><p>Virgolette e apici devono essere alti e di tipo indifferenziato, quelli che trovate tra i simboli in alto sulla vostra tastiera. Altre virgolette “tipografiche”, come quelle in questa frase, non sono valide in Python.</p><p>Se scrivete una funzione in modalità interattiva, l’interprete mette tre puntini di sospensione (<em>...</em>) per indicare che la definizione non è completa:
<a id="hevea_default185"></a></p><pre class="verbatim">&gt;&gt;&gt; def stampa_brani():
...     print('Terror di tutta la foresta egli è,')
...     print("Con l'ascia in mano si sente un re.")
...
</pre><p>
Per concludere la funzione, dovete inserire una riga vuota.</p><p>La definizione di una funzione crea un <span class="c009">oggetto funzione</span> che è di tipo <code>function</code>:
<a id="hevea_default186"></a>
<a id="hevea_default187"></a></p><pre class="verbatim">&gt;&gt;&gt; print(stampa_brani)
&lt;function stampa_brani at 0xb7e99e9c&gt;
&gt;&gt;&gt; type(stampa_brani)
&lt;class 'function'&gt;
</pre><p>La sintassi per chiamare la nuova funzione è la stessa che abbiamo visto per le funzioni predefinite:</p><pre class="verbatim">&gt;&gt;&gt; stampa_brani()
Terror di tutta la foresta egli è,
Con l'ascia in mano si sente un re.
</pre><p>
Una volta definita una funzione, si può utilizzarla all’interno di un’altra funzione. Per esempio, per ripetere due volte il brano precedente possiamo scrivere una funzione <code>ripeti_brani</code>:</p><pre class="verbatim">def ripeti_brani():
    stampa_brani()
    stampa_brani()
</pre><p>
E quindi chiamare <code>ripeti_brani</code>:</p><pre class="verbatim">&gt;&gt;&gt; ripeti_brani()
Terror di tutta la foresta egli è,
Con l'ascia in mano si sente un re.
Terror di tutta la foresta egli è,
Con l'ascia in mano si sente un re.
</pre><p>
Ma a dire il vero, la canzone del taglialegna non fa così!</p>
<!--TOC section id="sec34" Definizioni e loro utilizzo-->
<h2 class="section" id="sec34">3.5  Definizioni e loro utilizzo</h2><!--SEC END --><p>
<a id="hevea_default188"></a></p><p>Raggruppando assieme i frammenti di codice del Paragrafo precedente, il programma diventa:</p><pre class="verbatim">def stampa_brani():
    print('Terror di tutta la foresta egli è,')
    print("Con l'ascia in mano si sente un re.")

def ripeti_brani():
    stampa_brani()
    stampa_brani()

ripeti_brani()
</pre><p>Questo programma contiene due definizioni di funzione: <code>stampa_brani</code> e
<code>ripeti_brani</code>. Le definizioni di funzione sono eseguite come le altre istruzioni, ma il loro effetto è solo quello di creare una nuova funzione. Le istruzioni all’interno di una definizione non vengono eseguite fino a quando la funzione non viene chiamata, e la definizione di per sé non genera alcun risultato.</p><p>Ovviamente, una funzione deve essere definita prima di poterla usare: la definizione della funzione deve sempre precedere la sua chiamata.
<a id="hevea_default189"></a></p><p>Come esercizio, spostate l’ultima riga del programma all’inizio, per fare in modo che la chiamata della funzione appaia prima della definizione. Eseguite il programma e guardate che tipo di messaggio d’errore ottenete.</p><p>Ora riportate la chiamata della funzione al suo posto, e spostate la definizione di <code>stampa_brani</code> dopo la definizione di <code>ripeti_brani</code>. Cosa succede quando avviate il programma?</p>
<!--TOC section id="sec35" Flusso di esecuzione-->
<h2 class="section" id="sec35">3.6  Flusso di esecuzione</h2><!--SEC END --><p>
<a id="hevea_default190"></a></p><p>Per essere sicuri che una funzione sia stata definita prima di essere utilizzata, dovete conoscere l’ordine in cui le istruzioni vengono eseguite, che è chiamato <span class="c009">flusso di esecuzione</span>.</p><p>L’esecuzione inizia sempre dalla prima istruzione del programma; quindi, le istruzioni successive sono eseguite una alla volta, procedendo dall’alto verso il basso.</p><p>Le definizioni di funzione non cambiano il flusso di esecuzione del programma, ma ricordate che le istruzioni all’interno delle funzioni non vengono eseguite fino a quando la funzione non viene chiamata. </p><p>Quando viene chiamata una funzione, si genera una specie di deviazione nel flusso di esecuzione: anziché proseguire con l’istruzione successiva, il flusso salta nel corpo della funzione chiamata, ne esegue le istruzioni, e infine riprende il percorso dal punto che aveva lasciato.</p><p>Parrebbe tutto abbastanza semplice, se non fosse che una funzione può chiamarne un’altra. Mentre si trova all’interno di una funzione, il programma può dover eseguire le istruzioni che si trovano in un’altra funzione. Poi, mentre esegue quella nuova funzione, il programma potrebbe andare ad eseguirne un’altra ancora!</p><p>Fortunatamente, Python sa tener bene traccia di dove si trova: ogni volta che una funzione viene completata, il programma ritorna al punto della funzione chiamante che aveva lasciato. E una volta giunto alla fine, termina il suo lavoro.</p><p>Concludendo, nel leggere un programma non è sempre opportuno farlo dall’alto in basso. Spesso è più logico seguire il flusso di esecuzione.</p>
<!--TOC section id="sec36" Parametri e argomenti-->
<h2 class="section" id="sec36">3.7  Parametri e argomenti</h2><!--SEC END --><p>
<a id="parametri"></a>
<a id="hevea_default191"></a>
<a id="hevea_default192"></a>
<a id="hevea_default193"></a>
<a id="hevea_default194"></a></p><p>Alcune delle funzioni che abbiamo visto richiedono degli argomenti. Per esempio, se volete trovare il seno di un numero chiamando la funzione <span class="c003">math.sin</span>, dovete passarle quel numero come argomento. Alcune funzioni ricevono più di un argomento: a <span class="c003">math.pow</span> ne servono due, che sono la base e l’esponente dell’operazione di elevamento a potenza. </p><p>All’interno della funzione, gli argomenti che le vengono passati sono assegnati ad altrettante variabili chiamate <span class="c009">parametri</span>. Ecco un esempio di definizione di una funzione che riceve un argomento:
<a id="hevea_default195"></a></p><pre class="verbatim">def stampa2volte(bruce):
    print(bruce)
    print(bruce)
</pre><p>
Questa funzione assegna l’argomento ricevuto ad un parametro chiamato <span class="c003">bruce</span>. Quando la funzione viene chiamata, stampa il valore del parametro (qualunque esso sia) due volte.</p><p>Questa funzione elabora qualunque valore che possa essere stampato.</p><pre class="verbatim">&gt;&gt;&gt; stampa2volte('Spam')
Spam
Spam
&gt;&gt;&gt; stampa2volte(42)
42
42
&gt;&gt;&gt; stampa2volte(math.pi)
3.14159265359
3.14159265359
</pre><p>
Le stesse regole di composizione che valgono per le funzioni predefinite si applicano anche alle funzioni definite da un programmatore, pertanto possiamo usare come argomento per <code>stampa2volte</code> qualsiasi espressione:
<a id="hevea_default196"></a>
<a id="hevea_default197"></a></p><pre class="verbatim">&gt;&gt;&gt; stampa2volte('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
&gt;&gt;&gt; stampa2volte(math.cos(math.pi))
-1.0
-1.0
</pre><p>
L’argomento viene valutato prima della chiamata alla funzione, pertanto nell’esempio appena proposto le espressioni <code>'Spam '*4</code> e
<span class="c003">math.cos(math.pi)</span> vengono valutate una volta sola.
<a id="hevea_default198"></a></p><p>Potete anche usare una variabile come argomento di una funzione:</p><pre class="verbatim">&gt;&gt;&gt; michael = 'Eric, the half a bee.'
&gt;&gt;&gt; stampa2volte(michael)
Eric, the half a bee.
Eric, the half a bee.
</pre><p>
Il nome della variabile che passiamo come argomento (<span class="c003">michael</span>) non ha niente a che fare con il nome del parametro nella definizione della funzione (<span class="c003">bruce</span>). Non ha importanza come era stato denominato il valore di partenza (nel codice chiamante); qui in <code>stampa2volte</code>, chiamiamo tutto quanto <span class="c003">bruce</span>.</p>
<!--TOC section id="sec37" Variabili e parametri sono locali-->
<h2 class="section" id="sec37">3.8  Variabili e parametri sono locali</h2><!--SEC END --><p>
<a id="hevea_default199"></a></p><p>Quando create una variabile in una funzione, essa è <span class="c009">locale</span>,
cioè esiste solo all’interno della funzione. Per esempio:
<a id="hevea_default200"></a></p><pre class="verbatim">def cat2volte(parte1, parte2):
    cat = parte1 + parte2
    stampa2volte(cat)
</pre><p>
Questa funzione prende due argomenti, li concatena e poi stampa il risultato per due volte. Ecco un esempio che la utilizza:
<a id="hevea_default201"></a></p><pre class="verbatim">&gt;&gt;&gt; riga1 = 'Bing tiddle '
&gt;&gt;&gt; riga2 = 'tiddle bang.'
&gt;&gt;&gt; cat2volte(riga1, riga2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
</pre><p>
Quando <code>cat2volte</code> termina, la variabile <span class="c003">cat</span> viene distrutta. Se provassimo a stamparla, otterremmo infatti un messaggio d’errore:
<a id="hevea_default202"></a>
<a id="hevea_default203"></a></p><pre class="verbatim">&gt;&gt;&gt; print(cat)
NameError: name 'cat' is not defined
</pre><p>
Anche i parametri sono locali: esternamente alla funzione <code>stampa2volte</code>, non esiste nulla di nome <span class="c003">bruce</span>.
<a id="hevea_default204"></a></p>
<!--TOC section id="sec38" Diagrammi di stack-->
<h2 class="section" id="sec38">3.9  Diagrammi di stack</h2><!--SEC END --><p>
<a id="stackdiagram"></a>
<a id="hevea_default205"></a>
<a id="hevea_default206"></a>
<a id="hevea_default207"></a></p><p>Per tenere traccia di quali variabili possono essere usate e dove, a volte può risultare utile disegnare un <span class="c009">diagramma di stack</span>. Come i diagrammi di stato, i diagrammi di stack mostrano il valore di ciascuna variabile, ma in più indicano a quale funzione essa appartiene.</p><p>Ciascuna funzione è rappresentata da un <span class="c009">frame</span>, un riquadro che riporta a fianco il nome della funzione e all’interno un elenco dei suoi parametri e delle sue variabili. Nel caso dell’esempio precedente, il diagramma di stack è illustrato in Figura <a href="#fig.stack">3.1</a>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian002.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 3.1: Diagramma di stack.</td></tr>
</table></div>
<a id="fig.stack"></a>
<div class="center"><hr class="c019"></div></blockquote><p>I frame sono disposti in una pila che indica quale funzione ne ha chiamata un’altra e così via. Nell’esempio, <code>stampa2volte</code> è stata chiamata da <code>cat2volte</code>, e <code>cat2volte</code> è stata a sua volta chiamata da 
<code>__main__</code>, che è un nome speciale per il frame principale. Quando si crea una variabile che è esterna ad ogni funzione, essa appartiene a 
<code>__main__</code>.
<a id="hevea_default208"></a></p><p>Ogni parametro fa riferimento allo stesso valore del suo argomento corrispondente. Così, <span class="c003">parte1</span> ha lo stesso valore di
<span class="c003">riga1</span>, <span class="c003">parte2</span> ha lo stesso valore di <span class="c003">riga2</span>,
e <span class="c003">bruce</span> ha lo stesso valore di <span class="c003">cat</span>.</p><p>Se si verifica un errore durante la chiamata di una funzione, Python mostra il nome della funzione, il nome della funzione che l’ha chiamata, il nome della funzione che a sua volta ha chiamato quest’ultima e così via, fino a raggiungere il primo livello che è sempre <code>__main__</code>.</p><p>Ad esempio se cercate di accedere a <span class="c003">cat</span> dall’interno di
<code>stampa2volte</code>, ottenete un errore di tipo <span class="c003">NameError</span>:</p><pre class="verbatim">Traceback (innermost last):
  File "test.py", line 13, in __main__
    cat2volte(riga1, riga2)
  File "test.py", line 5, in cat2volte
    stampa2volte(cat)
  File "test.py", line 9, in stampa2volte
    print(cat)
NameError: name 'cat' is not defined
</pre><p>
Questo elenco di funzioni è detto <span class="c009">traceback</span>. Il traceback vi dice in quale file è avvenuto l’errore, e in quale riga, e quale funzione era in esecuzione in quel momento. Mostra anche la riga di codice che ha causato l’errore.
<a id="hevea_default209"></a></p><p>L’ordine delle funzioni nel traceback è lo stesso di quello dei frame nel diagramma di stack. La funzione attualmente in esecuzione si trova in fondo all’elenco.</p>
<!--TOC section id="sec39" Funzioni “produttive” e funzioni “vuote”-->
<h2 class="section" id="sec39">3.10  Funzioni “produttive” e funzioni “vuote”</h2><!--SEC END --><p>
<a id="hevea_default210"></a>
<a id="hevea_default211"></a> </p><p>Alcune delle funzioni che abbiamo usato, come le funzioni matematiche, restituiscono dei risultati; in mancanza di definizioni migliori, personalmente le chiamo <span class="c009">funzioni “produttive”</span>. Altre funzioni, come <code>stampa2volte</code>, eseguono un’azione ma non restituiscono alcun valore. Le chiameremo <span class="c009">funzioni “vuote”</span>.</p><p>Quando chiamate una funzione produttiva, quasi sempre è per fare qualcosa di utile con il suo risultato, tipo assegnarlo a una variabile o usarlo come parte di un’espressione.</p><pre class="verbatim">x = math.cos(radianti)
aureo = (math.sqrt(5) + 1) / 2
</pre><p>
Se chiamate una funzione in modalità interattiva, Python ne mostra il risultato:</p><pre class="verbatim">&gt;&gt;&gt; math.sqrt(5)
2.2360679774997898
</pre><p>
Ma in uno script, se chiamate una funzione produttiva così come è, il valore di ritorno è perso!</p><pre class="verbatim">math.sqrt(5)
</pre><p>
Questo script in effetti calcola la radice quadrata di 5, ma non conserva nè visualizza il risultato, per cui non è di grande utilità.
<a id="hevea_default212"></a>
<a id="hevea_default213"></a></p><p>Le funzioni vuote possono visualizzare qualcosa sullo schermo o avere qualche altro effetto, ma non restituiscono un valore. Se provate comunque ad assegnare il risultato ad una variabile, ottenete un valore speciale chiamato
<span class="c003">None</span> (nulla).
<a id="hevea_default214"></a>
<a id="hevea_default215"></a></p><pre class="verbatim">&gt;&gt;&gt; risultato = stampa2volte('Bing')
Bing
Bing
&gt;&gt;&gt; print(risultato)
None
</pre><p>
Il valore <span class="c003">None</span> non è la stessa cosa della stringa <code>'None'</code>. 
È un valore speciale che appartiene ad un tipo tutto suo:</p><pre class="verbatim">&gt;&gt;&gt; type(None)
&lt;class 'NoneType'&gt;
</pre><p>
Le funzioni che abbiamo scritto finora, sono tutte vuote. Cominceremo a scriverne di produttive tra alcuni capitoli.</p>
<!--TOC section id="sec40" Perché usare le funzioni?-->
<h2 class="section" id="sec40">3.11  Perché usare le funzioni?</h2><!--SEC END --><p>
<a id="hevea_default216"></a></p><p>Potrebbe non esservi ancora ben chiaro perché valga la pena di suddividere il programma in funzioni. Ecco alcuni motivi:</p><ul class="itemize"><li class="li-itemize">Creare una nuova funzione vi dà modo di dare un nome a un gruppo di istruzioni, rendendo il programma più facile da leggere e da correggere.</li><li class="li-itemize">Le funzioni possono rendere un programma più breve, eliminando il codice ripetitivo. Se in un secondo tempo dovete fare una modifica, basterà farla in un posto solo.</li><li class="li-itemize">Dividere un programma lungo in funzioni vi permette di correggere le parti una per una, per poi assemblarle in un complesso funzionante.</li><li class="li-itemize">Funzioni ben fatte sono spesso utili per più programmi. Quando ne avete scritta e corretta una, la potete riutilizzare tale e quale.</li></ul>
<!--TOC section id="sec41" Debug-->
<h2 class="section" id="sec41">3.12  Debug</h2><!--SEC END --><p>
<a id="editor"></a>
<a id="hevea_default217"></a></p><p>Saper rintracciare e correggere gli errori è una essenziale qualità che dovete acquisire. Anche se a volte può essere demotivante, si tratta infatti di una delle parti più intellettualmente ricche, stimolanti ed interessanti della programmazione.
<a id="hevea_default218"></a></p><p>Possiamo paragonare il debug al lavoro di un investigatore: avete a disposizione degli indizi e dovete ricostruire quali processi ed eventi hanno prodotto il risultato che osservate.</p><p>Il debug è anche simile ad una scienza sperimentale. Quando pensate di aver capito cosa può avere provocato un errore, modificate il programma di conseguenza e riprovate di nuovo. Se l’ipotesi era giusta, avete saputo prevedere il risultato della modifica e vi siete avvicinati di un passo ad un programma funzionante. Se l’ipotesi era sbagliata, ne dovete formulare un’altra. Come disse Sherlock Holmes: “Una volta eliminato l’impossibile, qualsiasi cosa rimanga, per quanto improbabile, deve essere la verità.”
(A. Conan Doyle, <em>Il segno dei quattro</em>)
<a id="hevea_default219"></a>
<a id="hevea_default220"></a></p><p>Per alcuni, la programmazione e la rimozione degli errori sono in fondo la stessa cosa: programmare è una procedura di graduale rimozione degli errori da un programma, fino a quando non funziona a dovere. L’idea di fondo è di iniziare con un programma funzionante e di fare ogni volta piccole modifiche, effettuandone man mano il debug.</p><p>Linux, ad esempio, è un sistema operativo fatto da milioni di righe di codice, ma nacque come un semplice programma che Linus Torvalds usava per esplorare il chip Intel 80386. Secondo Larry Greenfields, “Uno dei progetti iniziali di Linus era un programma che doveva visualizzare alternativamente una sequenza di AAAA e BBBB. Questo programma si è poi evoluto in Linux”. (<em>The Linux Users’ Guide</em> Beta Version 1).
<a id="hevea_default221"></a></p>
<!--TOC section id="sec42" Glossario-->
<h2 class="section" id="sec42">3.13  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">funzione:</span></dt><dd class="dd-description"> Una serie di istruzioni dotata di un nome che esegue una certa operazione utile. Le funzioni possono o meno ricevere argomenti e possono o meno produrre un risultato.
<a id="hevea_default222"></a></dd><dt class="dt-description"><span class="c009">definizione di funzione:</span></dt><dd class="dd-description"> Istruzione che crea una nuova funzione, specificandone il nome, i parametri, e le istruzioni che contiene.
<a id="hevea_default223"></a></dd><dt class="dt-description"><span class="c009">oggetto funzione:</span></dt><dd class="dd-description"> Valore creato da una definizione di funzione. Il nome della funzione è una variabile che fa riferimento a un oggetto funzione.
<a id="hevea_default224"></a></dd><dt class="dt-description"><span class="c009">intestazione:</span></dt><dd class="dd-description"> La prima riga di una definizione di funzione.
<a id="hevea_default225"></a></dd><dt class="dt-description"><span class="c009">corpo:</span></dt><dd class="dd-description"> La serie di istruzioni all’interno di una definizione di funzione.
<a id="hevea_default226"></a></dd><dt class="dt-description"><span class="c009">parametro:</span></dt><dd class="dd-description"> Un nome usato all’interno di una funzione che fa riferimento al valore passato come argomento.
<a id="hevea_default227"></a></dd><dt class="dt-description"><span class="c009">chiamata di funzione:</span></dt><dd class="dd-description"> Istruzione che esegue una funzione. Consiste nel nome della funzione seguito da un elenco di argomenti tra parentesi.
<a id="hevea_default228"></a></dd><dt class="dt-description"><span class="c009">argomento:</span></dt><dd class="dd-description"> Un valore fornito (passato) a una funzione quando viene chiamata. Questo valore viene assegnato al corrispondente parametro nella funzione.
<a id="hevea_default229"></a></dd><dt class="dt-description"><span class="c009">variabile locale:</span></dt><dd class="dd-description"> Variabile definita all’interno di una funzione e che puo essere usata solo all’interno della funzione.
<a id="hevea_default230"></a></dd><dt class="dt-description"><span class="c009">valore di ritorno:</span></dt><dd class="dd-description"> Il risultato di una funzione. Se una chiamata di funzione viene usata come espressione, il valore di ritorno è il valore dell’espressione.
<a id="hevea_default231"></a></dd><dt class="dt-description"><span class="c009">funzione “produttiva”:</span></dt><dd class="dd-description"> Una funzione che restituisce un valore.
<a id="hevea_default232"></a></dd><dt class="dt-description"><span class="c009">funzione “vuota”:</span></dt><dd class="dd-description"> Una funzione che restituisce sempre <span class="c003">None</span>.
<a id="hevea_default233"></a></dd><dt class="dt-description"><span class="c009"><span class="c003">None</span>:</span></dt><dd class="dd-description"> Valore speciale restituito dalle funzioni vuote.
<a id="hevea_default234"></a>
<a id="hevea_default235"></a></dd><dt class="dt-description"><span class="c009">modulo:</span></dt><dd class="dd-description"> Un file che contiene una raccolta di funzioni correlate e altre definizioni.
<a id="hevea_default236"></a></dd><dt class="dt-description"><span class="c009">istruzione import:</span></dt><dd class="dd-description"> Istruzione che legge un file modulo e crea un oggetto modulo utilizzabile.
<a id="hevea_default237"></a>
<a id="hevea_default238"></a></dd><dt class="dt-description"><span class="c009">oggetto modulo:</span></dt><dd class="dd-description"> Valore creato da un’istruzione <span class="c003">import</span> che fornisce l’accesso ai valori definiti in un modulo.
<a id="hevea_default239"></a></dd><dt class="dt-description"><span class="c009">dot notation o notazione a punto:</span></dt><dd class="dd-description"> Sintassi per chiamare una funzione di un modulo diverso, specificando il nome del modulo seguito da un punto e dal nome della funzione.
<a id="hevea_default240"></a>
<a id="hevea_default241"></a></dd><dt class="dt-description"><span class="c009">composizione:</span></dt><dd class="dd-description"> Utilizzare un’espressione come parte di un’espressione più grande o un’istruzione come parte di un’istruzione più grande.
<a id="hevea_default242"></a></dd><dt class="dt-description"><span class="c009">flusso di esecuzione:</span></dt><dd class="dd-description"> L’ordine in cui vengono eseguite le istruzioni nel corso di un programma.
<a id="hevea_default243"></a></dd><dt class="dt-description"><span class="c009">diagramma di stack:</span></dt><dd class="dd-description"> Rappresentazione grafica di una serie di funzioni impilate, delle loro variabili e dei valori a cui fanno riferimento.
<a id="hevea_default244"></a></dd><dt class="dt-description"><span class="c009">frame:</span></dt><dd class="dd-description"> Un riquadro in un diagramma di stack che rappresenta una chiamata di funzione. Contiene le variabili locali e i parametri della funzione.
<a id="hevea_default245"></a>
<a id="hevea_default246"></a></dd><dt class="dt-description"><span class="c009">traceback:</span></dt><dd class="dd-description"> Elenco delle funzioni in corso di esecuzione, visualizzato quando si verifica un errore.
<a id="hevea_default247"></a></dd></dl>
<!--TOC section id="sec43" Esercizi-->
<h2 class="section" id="sec43">3.14  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  
<a id="hevea_default248"></a>
<a id="hevea_default249"></a><p><em>Scrivete una funzione chiamata <code>giustif_destra</code> che richieda una stringa <span class="c003">s</span> come parametro e stampi la stringa con tanti spazi iniziali da far sì che l’ultima lettera della stringa cada nella colonna 70 del display.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; giustif_destra('monty')
                                                                 monty
</em></pre><p><em>Suggerimento: usate concatenamento delle stringhe e ripetizione. Inoltre,
Python contiene una funzione predefinita chiamata <span class="c003">len</span> che restituisce la lunghezza di una stringa, ad esempio il valore di <code>len('monty')</code> è 5.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default250"></a><p><em>Un oggetto funzione è un valore che potete assegnare a una variabile o passare come argomento. Ad esempio, <code>fai2volte</code> è una funzione che accetta un oggetto funzione come argomento e la chiama per due volte.</em></p><pre class="verbatim"><em>def fai2volte(f):
    f()
    f()
</em></pre><p><em>Ecco un esempio che usa <code>fai2volte</code> per chiamare una funzione di nome <code>stampa_spam</code> due volte.</em></p><pre class="verbatim"><em>def stampa_spam():
    print('spam')

fai2volte(stampa_spam)
</em></pre><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete questo esempio in uno script e provatelo.</em></li><li class="li-enumerate"><em>Modificate <code>fai2volte</code> in modo che accetti due argomenti, un oggetto funzione e un valore, e che chiami la funzione due volte passando il valore come argomento.</em></li><li class="li-enumerate"><em>Copiate nel vostro script la definizione di <code>stampa_2volte</code> che abbiamo visto nel corso di questo capitolo.</em></li><li class="li-enumerate"><em>Usate la versione modificata di <code>fai2volte</code> per chiamare
<code>stampa_2volte</code> per due volte, passando <code>'spam'</code> come argomento.</em></li><li class="li-enumerate"><em>Definite una nuova funzione di nome <code>fai_quattro</code> che richieda un oggetto funzione e un valore e chiami la funzione per 4 volte, passando il valore come argomento. Dovrebbero esserci solo due istruzioni nel corpo di questa funzione, non quattro.</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/do_four.py"><em><span class="c003">http://thinkpython2.com/code/do_four.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  <p><em>Nota: questo esercizio dovrebbe essere svolto con le sole istruzioni e caratteristiche del linguaggio imparate finora.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione che disegni una griglia come questa:
</em><a id="hevea_default251"></a><pre class="verbatim"><em>+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
|         |         |
|         |         |
|         |         |
|         |         |
+ - - - - + - - - - +
</em></pre><p><em>
Suggerimento: per stampare più di un valore per riga, stampate una sequenza di valori separati da virgole:</em></p><pre class="verbatim"><em>print('+', '-')
</em></pre><p><em>
Di default, <span class="c003">print</span> va a capo; si può però variare questo comportamento e restare sulla stessa riga, inserendo uno spazio, in questo modo:</em></p><pre class="verbatim"><em>print('+', end=' ')
print('-')
</em></pre><p><em>
L’output di queste istruzioni è <code>'+ -'</code>.</em></p><p><em>Una funzione <span class="c003">print</span> priva di argomento, termina la riga e va a capo.</em></p></li><li class="li-enumerate"><em>Scrivete una funzione che disegni una griglia simile, con quattro righe e quattro colonne.</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/grid.py"><em><span class="c003">http://thinkpython2.com/code/grid.py</span></em></a><em>.
Fonte: Esercizio tratto da Oualline, </em>Practical C Programming, Third Edition<em>, O’Reilly Media, 1997.</em></p></div>
<!--TOC chapter id="sec44" Esercitazione: Progettazione dell’interfaccia-->
<h1 class="chapter" id="sec44">Chapter 4  Esercitazione: Progettazione dell’interfaccia</h1><!--SEC END --><p>
<a id="turtlechap"></a></p><p>Questo capitolo vi propone un’esercitazione che dimostra una procedura per progettare delle funzioni che collaborano tra loro.</p><p>Viene illustrato il modulo grafico <span class="c003">turtle</span> che vi permette di creare immagini utilizzando <em>turtle graphics</em>. Si tratta di un modulo già compreso nella maggior parte delle installazioni di Python; tuttavia, se usate PythonAnywhere, non sarete in grado di visualizzare gli esempi basati su turtle (almeno non nel momento in cui scrivo).</p><p>Se avete già installato Python sul vostro computer, gli esempi dovrebbero funzionare. Se non lo avete ancora installato, questo è il momento buono per farlo. Potete trovare delle istruzioni all’indirizzo <a href="http://tinyurl.com/thinkpython2e"><span class="c003">http://tinyurl.com/thinkpython2e</span></a>.</p><p>Il codice degli esempi di questo capitolo è scaricabile dal sito
<a href="http://thinkpython2.com/code/polygon.py"><span class="c003">http://thinkpython2.com/code/polygon.py</span></a></p>
<!--TOC section id="sec45" Il modulo turtle-->
<h2 class="section" id="sec45">4.1  Il modulo turtle</h2><!--SEC END --><p>
<a id="turtle"></a></p><p>Per controllare se il modulo <span class="c003">turtle</span> è installato, aprite l’interprete Python e scrivete:</p><pre class="verbatim">&gt;&gt;&gt; import turtle
&gt;&gt;&gt; bob = turtle.Turtle()
</pre><p>Eseguendo questo codice, dovrebbe comparire una nuova finestra con un cursore a forma di freccetta che rappresenta un’ideale tartaruga. Ora chiudete pure la finestra.</p><p>Create un file di nome <span class="c003">miopoligono.py</span> e scriveteci il seguente codice:</p><pre class="verbatim">import turtle
bob = turtle.Turtle()
print(bob)
turtle.mainloop()
</pre><p>
Il modulo <span class="c003">turtle</span> (con la ’t’ minuscola) contiene una funzione di nome <span class="c003">Turtle</span> (con la ’T’ maiuscola) che crea un oggetto Turtle (una “tartaruga”); questo oggetto viene assegnato a una variabile di nome <span class="c003">bob</span>.
Stampando <span class="c003">bob</span> viene visualizzato qualcosa di questo genere:</p><pre class="verbatim">&lt;turtle.Turtle object at 0xb7bfbf4c&gt;
</pre><p>
Ciò significa che <span class="c003">bob</span> fa riferimento ad un oggetto <span class="c003">Turtle</span>,
come definito nel modulo <span class="c003">turtle</span>.</p><p><code>mainloop</code> dice alla finestra di attendere che l’utente faccia qualcosa, sebbene in questo caso non ci sia molto da fare, se non chiudere la finestra.</p><p>Una volta creata una tartaruga, potete chiamare uno dei suoi <span class="c009">metodi</span> per spostarla in giro per la finestra. Un metodo è simile ad una funzione, ma usa una sintassi leggermente diversa. Ad esempio, per spostare la tartaruga in avanti:</p><pre class="verbatim">bob.fd(100)
</pre><p>
Il metodo, <span class="c003">fd</span>, è associato all’oggetto Turtle che abbiamo chiamato
<span class="c003">bob</span>. 
Chiamare un metodo è come effettuare una richiesta: in questo caso state chiedendo a <span class="c003">bob</span> di muoversi in avanti [fd sta per <em>forward</em>, NdT].
L’argomento di <span class="c003">fd</span> è una distanza espressa in pixel, per cui l’effettivo spostamento dipenderà dalle caratteristiche del vostro schermo.</p><p>Altri metodi che potete chiamare su una tartaruga sono: <span class="c003">bk</span> per muoversi indietro (<em>backward</em>) e <span class="c003">lt</span> e <span class="c003">rt</span> per girare a sinistra (<em>left</em>) e a destra (<em>right</em>). Per questi ultimi due, l’argomento è un angolo espresso in gradi. </p><p>Inoltre, ogni tartaruga regge una penna, che può essere appoggiata o sollevata; se la penna è appoggiata, la tartaruga lascia un segno dove passa. I metodi <span class="c003">pu</span> e <span class="c003">pd</span> stanno per “penna su (<em>up</em>)” e “penna giù (<em>down</em>)”.</p><p>Per disegnare un angolo retto, aggiungete queste righe al programma (dopo aver creato <span class="c003">bob</span> e prima di chiamare <code>mainloop</code>):</p><pre class="verbatim">bob.fd(100)
bob.lt(90)
bob.fd(100)
</pre><p>
Avviando il programma, dovreste vedere <span class="c003">bob</span> muoversi verso destra e poi in alto, lasciandosi dietro due segmenti.</p><p>Ora provate a modificare il programma in modo da disegnare un quadrato. Non andate avanti finché non ci riuscite!</p>
<!--TOC section id="sec46" Ripetizione semplice-->
<h2 class="section" id="sec46">4.2  Ripetizione semplice</h2><!--SEC END --><p>
<a id="repetition"></a>
<a id="hevea_default252"></a></p><p>Probabilmente avete scritto qualcosa del genere:</p><pre class="verbatim">bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
bob.lt(90)

bob.fd(100)
</pre><p>
Si può ottenere lo stesso risultato in modo più conciso con un’istruzione <span class="c003">for</span>. Aggiungete questo esempio a <span class="c003">miopoligono.py</span> ed eseguitelo di nuovo:
<a id="hevea_default253"></a>
<a id="hevea_default254"></a>
<a id="hevea_default255"></a></p><pre class="verbatim">for i in range(4):
    print('Ciao!')
</pre><p>
Dovreste vedere qualcosa di simile:</p><pre class="verbatim">Ciao!
Ciao!
Ciao!
Ciao!
</pre><p>
Questo è l’utilizzo più semplice dell’istruzione <span class="c003">for</span>; ne vedremo altri più avanti. Ma questo dovrebbe bastare per permettervi di riscrivere il vostro programma di disegno di quadrati. Proseguite nella lettura solo dopo averlo fatto.</p><p>Ecco l’istruzione <span class="c003">for</span> che disegna un quadrato:</p><pre class="verbatim">for i in range(4):
    bob.fd(100)
    bob.lt(90)
</pre><p>
La sintassi di un’istruzione <span class="c003">for</span> è simile a quella di una funzione. Ha un’intestazione che termina con i due punti e un corpo indentato che può contenere un numero qualunque di istruzioni.</p><p>Un’istruzione <span class="c003">for</span> è chiamata anche <span class="c009">ciclo</span>, perché il flusso dell’esecuzione ne attraversa il corpo per poi ritornare indietro e ripeterlo da capo. In questo caso, il corpo viene eseguito per quattro volte.
<a id="hevea_default256"></a></p><p>Questa versione del disegno di quadrati è in realtà un pochino differente dalla precedente, in quanto provoca un’ultima svolta dopo aver disegnato l’ultimo lato. Ciò comporta del tempo in più, ma il codice viene semplificato, inoltre lascia la tartaruga nella stessa posizione di partenza, rivolta nella direzione iniziale.</p>
<!--TOC section id="sec47" Esercizi-->
<h2 class="section" id="sec47">4.3  Esercizi</h2><!--SEC END --><p>Quella che segue è una serie di esercizi che utilizzano <span class="c003">turtle</span>. Sono pensati per essere divertenti, ma hanno anche uno scopo. Mentre ci lavorate su, provate a pensare quale sia.</p><p>I paragrafi successivi contengono le soluzioni degli esercizi, per cui non continuate la lettura finché non avete finito (o almeno provato).</p><ol class="enumerate" type=1><li class="li-enumerate">Scrivete una funzione di nome <span class="c003">quadrato</span> che richieda un parametro di nome <span class="c003">t</span>, che è una tartaruga. La funzione deve usare la tartaruga per disegnare un quadrato.<p>Scrivete una chiamata alla funzione <span class="c003">quadrato</span> che passi <span class="c003">bob</span> come argomento, ed eseguite nuovamente il programma.</p></li><li class="li-enumerate">Aggiungete a <span class="c003">quadrato</span> un nuovo parametro di nome <span class="c003">lunghezza</span>.
Modificate il corpo in modo che la lunghezza dei lati sia pari a <span class="c003">lunghezza</span>, quindi modificate la chiamata alla funzione in modo da fornire un secondo argomento. Eseguite di nuovo il programma e provatelo con vari valori di <span class="c003">lunghezza</span>.</li><li class="li-enumerate">Fate una copia di <span class="c003">quadrato</span> e cambiate il nome in <span class="c003">poligono</span>. Aggiungete un altro parametro di nome <span class="c003">n</span> e modificate il corpo in modo che sia disegnato un poligono regolare di n lati. Suggerimento: gli angoli esterni di un poligono regolare di n lati misurano 360/<span class="c008">n</span> gradi.
<a id="hevea_default257"></a>
<a id="hevea_default258"></a></li><li class="li-enumerate">Scrivete una funzione di nome <span class="c003">cerchio</span> che prenda come parametri una tartaruga, <span class="c003">t</span>, e un raggio, <span class="c003">r</span>, e che disegni un cerchio approssimato chiamando <span class="c003">poligono</span> con una appropriata lunghezza e numero di lati. Provate la funzione con diversi valori di <span class="c003">r</span>.
<a id="hevea_default259"></a>
<a id="hevea_default260"></a><p>Suggerimento: pensate alla circonferenza del cerchio e accertatevi che
<span class="c003">lunghezza * n = circonferenza</span>.</p></li><li class="li-enumerate">Create una versione più generale della funzione <span class="c003">cerchio</span>, di nome <span class="c003">arco</span>, che richieda un parametro aggiuntivo <span class="c003">angolo</span>, il quale determina la porzione di cerchio da disegnare. <span class="c003">angolo</span> è espresso in gradi, quindi se <span class="c003">angolo=360</span>, <span class="c003">arco</span> deve disegnare un cerchio completo.
<a id="hevea_default261"></a>
<a id="hevea_default262"></a></li></ol>
<!--TOC section id="sec48" Incapsulamento-->
<h2 class="section" id="sec48">4.4  Incapsulamento</h2><!--SEC END --><p>Il primo esercizio chiede di inserire il codice per disegnare un quadrato in una definizione di funzione, passando la tartaruga come argomento. Ecco una soluzione:</p><pre class="verbatim">def quadrato(t):
    for i in range(4):
        t.fd(100)
        t.lt(90)

quadrato(bob)
</pre><p>
Le istruzioni più interne, <span class="c003">fd</span> e <span class="c003">lt</span> sono doppiamente indentate per significare che si trovano all’interno del ciclo <span class="c003">for</span>, che a sua volta è all’interno della funzione. L’ultima riga, <span class="c003">quadrato(bob)</span>, è a livello del margine sinistro, pertanto indica la fine sia del ciclo <span class="c003">for</span> che della definizione di funzione.</p><p>Dentro la funzione, <span class="c003">t</span> si riferisce alla stessa tartaruga a cui si riferisce <span class="c003">bob</span>, per cui <span class="c003">t.lt(90)</span> ha lo stesso effetto di <span class="c003">bob.lt(90)</span>.
Ma allora perché non chiamare <span class="c003">bob</span> il parametro? Il motivo è che <span class="c003">t</span>
può essere qualunque tartaruga, non solo <span class="c003">bob</span>, e in questa maniera è possibile anche creare una seconda tartaruga e passarla come parametro a <span class="c003">quadrato</span>:</p><pre class="verbatim">alice = turtle.Turtle()
quadrato(alice)
</pre><p>
L’inglobare un pezzo di codice in una funzione è chiamato <span class="c009">incapsulamento</span>. Uno dei benefici dell’incapsulamento è che appiccica un nome al codice, il che può servire come una sorta di documentazione. Un altro vantaggio è il riuso del codice: è più conciso chiamare una funzione due volte che copiare e incollare il corpo!
<a id="hevea_default263"></a></p>
<!--TOC section id="sec49" Generalizzazione-->
<h2 class="section" id="sec49">4.5  Generalizzazione</h2><!--SEC END --><p>Il passo successivo è aggiungere a <span class="c003">quadrato</span> un parametro <span class="c003">lunghezza</span>.
Ecco una soluzione:</p><pre class="verbatim">def quadrato(t, lunghezza):
    for i in range(4):
        t.fd(lunghezza)
        t.lt(90)

quadrato(bob, 100)
</pre><p>
L’aggiunta di un parametro a una funzione è chiamata <span class="c009">generalizzazione</span>
poiché rende la funzione più generale: nella versione precedente, il quadrato aveva sempre la stessa dimensione, ora può essere grande a piacere.
<a id="hevea_default264"></a></p><p>Anche il passo seguente è una generalizzazione. Invece di disegnare solo quadrati, <span class="c003">poligono</span> disegna poligoni regolari di un qualunque numero di lati. Ecco una soluzione:</p><pre class="verbatim">def poligono(t, n, lunghezza):
    angolo = 360 / n
    for i in range(n):
        t.fd(lunghezza)
        t.lt(angolo)

poligono(bob, 7, 70)
</pre><p>
Questo esempio disegna un ettagono regolare con lati di lunghezza 70. </p><p>Se usate Python 2, il valore di <span class="c003">angolo</span> può risultare impreciso, per il fatto che la divisione di due interi dà come risultato un intero (“divisione intera”, che vedremo meglio nel prossimo Capitolo). Una semplice soluzione è calcolare <span class="c003">angolo = 360.0 / n</span>. Dato che il numeratore ora è un numero floating-point, anche il risultato sarà un floating-point.
<a id="hevea_default265"></a></p><p>Quando in una chiamata di funzione avete più di qualche argomento numerico, è facile dimenticare a cosa si riferiscono o in quale ordine vanno disposti. In questi casi, è bene includere i nomi dei parametri nell’elenco degli argomenti:</p><pre class="verbatim">poligono(bob, n=7, lunghezza=70)
</pre><p>
Questi sono detti <span class="c009">argomenti con nome</span> perché includono il nome del parametro a cui vengono passati, quale “parola chiave” (da non confondere con le parole chiave riservate come <span class="c003">while</span> e <span class="c003">def</span>).
<a id="hevea_default266"></a></p><p>Questa sintassi rende il programma più leggibile. È anche un appunto di come funzionano argomenti e parametri: quando chiamate una funzione, gli argomenti vengono assegnati a quei dati parametri.</p>
<!--TOC section id="sec50" Progettazione dell’interfaccia-->
<h2 class="section" id="sec50">4.6  Progettazione dell’interfaccia</h2><!--SEC END --><p>Il prossimo passaggio è scrivere <span class="c003">cerchio</span>, che richiede come parametro il raggio, <span class="c003">r</span>. Ecco una semplice soluzione che usa <span class="c003">poligono</span> per disegnare un poligono di 50 lati:</p><pre class="verbatim">import math

def cerchio(t, r):
    circonferenza = 2 * math.pi * r
    n = 50
    lunghezza = circonferenza / n
    poligono(t, n, lunghezza)
</pre><p>
La prima riga calcola la circonferenza di un cerchio di raggio
<span class="c003">r</span> usando la nota formula 2 π <span class="c008">r</span>. Dato che usiamo <span class="c003">math.pi</span>, vi ricordo che dovete prima importare il modulo <span class="c003">math</span>. Per convenzione, l’istruzione <span class="c003">import</span> si scrive all’inizio dello script.</p><p><span class="c003">n</span> è il numero di segmenti del nostro cerchio approssimato, e <span class="c003">lunghezza</span> è la lunghezza di ciascun segmento. Così facendo, <span class="c003">poligono</span> disegna un poligono di 50 lati che approssima un cerchio di raggio <span class="c003">r</span>.</p><p>Un limite di questa soluzione è che <span class="c003">n</span> è costante, il che comporta che per cerchi molto grandi i segmenti sono troppo lunghi, e per cerchi piccoli perdiamo tempo a disegnare minuscoli segmenti. Una soluzione sarebbe di generalizzare la funzione tramite un parametro <span class="c003">n</span>, dando all’utente (chiunque chiami la funzione <span class="c003">cerchio</span>) più controllo, ma rendendo così l’interfaccia meno chiara.
<a id="hevea_default267"></a></p><p>L’<span class="c009">interfaccia</span> è un riassunto di come è usata la funzione: quali sono i parametri? Che cosa fa la funzione? Qual è il valore restituito? Un’interfaccia è considerata “pulita” se permette al chiamante di fare ciò che deve, senza avere a che fare con dettagli non necessari.</p><p>In questo esempio, <span class="c003">r</span> appartiene all’interfaccia perché specifica il cerchio da disegnare. <span class="c003">n</span> è meno pertinente perché riguarda i dettagli di <em>come</em> il cerchio viene reso.</p><p>Piuttosto di ingombrare l’interfaccia di parametri, è meglio scegliere un valore appropriato di <span class="c003">n</span> che dipenda da <span class="c003">circonferenza</span>:</p><pre class="verbatim">def cerchio(t, r):
    circonferenza = 2 * math.pi * r
    n = int(circonferenza / 3) + 3
    lunghezza = circonferenza / n
    poligono(t, n, lunghezza)
</pre><p>
Ora il numero di segmenti è un numero intero vicino a <span class="c003">circonferenza/3</span>, e la lunghezza dei segmenti è circa 3, che è abbastanza piccolo da dare un cerchio di bell’aspetto, ma abbastanza grande da essere efficiente e appropriato per qualsiasi dimensione del cerchio.</p><p>Aggiungere 3 a <span class="c003">n</span> garantisce che il poligono abbia come minimo 3 lati.</p>
<!--TOC section id="sec51" Refactoring-->
<h2 class="section" id="sec51">4.7  Refactoring</h2><!--SEC END --><p>
<a id="refactoring"></a>
<a id="hevea_default268"></a></p><p>Nello scrivere <span class="c003">cerchio</span>, ho potuto riusare <span class="c003">poligono</span>
perché un poligono con molti lati è una buona approssimazione di un cerchio. Ma la funzione <span class="c003">arco</span> non è così collaborativa: non possiamo usare <span class="c003">poligono</span> o <span class="c003">cerchio</span> per disegnare un arco.</p><p>Un’alternativa è partire da una copia di <span class="c003">poligono</span> e trasformarla in <span class="c003">arco</span>. Il risultato può essere qualcosa del genere:</p><pre class="verbatim">def arco(t, r, angolo):
    arco_lunghezza = 2 * math.pi * r * angolo / 360
    n = int(arco_lunghezza / 3) + 1
    passo_lunghezza = arco_lunghezza / n
    passo_angolo = angolo / n
    
    for i in range(n):
        t.fd(passo_lunghezza)
        t.lt(passo_angolo)
</pre><p>
La seconda metà di questa funzione somiglia a <span class="c003">poligono</span>, ma non possiamo riusare questa funzione senza cambiarne l’interfaccia. Potremmo generalizzare <span class="c003">poligono</span> in modo che riceva un angolo come terzo argomento, ma allora <span class="c003">poligono</span> non sarebbe più un nome appropriato! Invece, creiamo una funzione più generale chiamata <span class="c003">polilinea</span>:</p><pre class="verbatim">def polilinea(t, n, lunghezza, angolo):
    for i in range(n):
        t.fd(lunghezza)
        t.lt(angolo)
</pre><p>
Ora possiamo riscrivere <span class="c003">poligono</span> e <span class="c003">arco</span> in modo che usino <span class="c003">polilinea</span>:</p><pre class="verbatim">def poligono(t, n, lunghezza):
    angolo = 360.0 / n
    polilinea(t, n, lunghezza, angolo)

def arco(t, r, angolo):
    arco_lunghezza = 2 * math.pi * r * angolo / 360
    n = int(arco_lunghezza / 3) + 1
    passo_lunghezza = arco_lunghezza / n
    passo_angolo = float(angolo) / n
    polilinea(t, n, passo_lunghezza, passo_angolo)
</pre><p>
Infine, riscriviamo <span class="c003">cerchio</span> in modo che usi <span class="c003">arco</span>:</p><pre class="verbatim">def cerchio(t, r):
    arco(t, r, 360)
</pre><p>
Questo procedimento di riarrangiare una programma per migliorare le interfacce e facilitare il riuso del codice, è chiamato <span class="c009">refactoring</span>.
In questo caso, abbiamo notato che in <span class="c003">arco</span> e in <span class="c003">poligono</span> c’era del codice simile, allora abbiamo semplificato il tutto in <span class="c003">polilinea</span>.
<a id="hevea_default269"></a></p><p>Avendoci pensato prima, avremmo potuto scrivere <span class="c003">polilinea</span> direttamente, evitando il refactoring, ma spesso all’inizio di un lavoro non si hanno le idee abbastanza chiare per progettare al meglio tutte le interfacce. Una volta cominciato a scrivere il codice, si colgono meglio i problemi. A volte, il refactoring è segno che avete imparato qualcosa.</p>
<!--TOC section id="sec52" Tecnica di sviluppo-->
<h2 class="section" id="sec52">4.8  Tecnica di sviluppo</h2><!--SEC END --><p>
<a id="hevea_default270"></a></p><p>Una <span class="c009">tecnica di sviluppo</span> è una procedura di scrittura dei programmi. Quello che abbiamo usato in questa esercitazione si chiama “incapsulamento e generalizzazione”. I passi della procedura sono:</p><ol class="enumerate" type=1><li class="li-enumerate">Iniziare scrivendo un piccolo programma senza definire funzioni.</li><li class="li-enumerate">Una volta ottenuto un programma funzionante, identificare una sua porzione che sia in sé coerente e autonoma, incapsularla in una funzione e dargli un nome.</li><li class="li-enumerate">Generalizzare la funzione aggiungendo i parametri appropriati.</li><li class="li-enumerate">Ripetere i passi da 1 a 3 fino ad avere un insieme di funzioni. Copiate e incollate il codice funzionante per evitare di riscriverlo (e ricorreggerlo).</li><li class="li-enumerate">Cercare le occasioni per migliorare il programma con il refactoring. Ad esempio, se avete del codice simile in più punti, valutate di semplificare rielaborandolo in una funzione più generale.</li></ol><p>Questa procedura ha alcuni inconvenienti—vedremo più avanti alcune alternative—ma può essere di aiuto se in principio non sapete bene come suddividere il vostro programma in funzioni. È un approccio che vi permette di progettare man mano che andate avanti.</p>
<!--TOC section id="sec53" Stringa di documentazione-->
<h2 class="section" id="sec53">4.9  Stringa di documentazione</h2><!--SEC END --><p>
<a id="docstring"></a>
<a id="hevea_default271"></a>
<a id="hevea_default272"></a></p><p>Una <span class="c009">stringa di documentazione</span>, o <em>docstring</em>, è una stringa posta all’inizio di una funzione che ne illustra l’interfaccia. Ecco un esempio:</p><pre class="verbatim">def polilinea(t, n, lunghezza, angolo):
    """Disegna n segmenti di data lunghezza e angolo
       (in gradi) tra di loro. t e' una tartaruga.
    """    
    for i in range(n):
        t.fd(lunghezza)
        t.lt(angolo)
</pre><p>
Per convenzione, la docstring è racchiusa tra triple virgolette, che le consentono di essere divisibile su più righe (stringa a righe multiple).
<a id="hevea_default273"></a>
<a id="hevea_default274"></a>
<a id="hevea_default275"></a></p><p>È breve, ma contiene le informazioni essenziali di cui qualcuno potrebbe aver bisogno per usare la funzione. Spiega in modo conciso cosa fa la funzione (senza entrare nei dettagli di come lo fa). Spiega che effetti ha ciascun parametro sul comportamento della funzione e di che tipo devono essere i parametri stessi (se non è ovvio).</p><p>Scrivere questo tipo di documentazione è una parte importante della progettazione dell’interfaccia. Un’interfaccia ben studiata dovrebbe essere semplice da spiegare; se fate fatica a spiegare una delle vostre funzioni, può darsi che la sua interfaccia sia migliorabile.</p>
<!--TOC section id="sec54" Debug-->
<h2 class="section" id="sec54">4.10  Debug</h2><!--SEC END --><p>
<a id="hevea_default276"></a>
<a id="hevea_default277"></a></p><p>Un’interfaccia è simile ad un contratto tra la funzione e il suo chiamante. Il chiamante si impegna a fornire certi parametri e la funzione si impegna a svolgere un dato lavoro.</p><p>Ad esempio, a <span class="c003">polilinea</span> devono essere passati quattro argomenti: <span class="c003">t</span> deve essere una tartaruga; <span class="c003">n</span> deve essere un numero intero; <span class="c003">lunghezza</span> deve essere un numero positivo; e <span class="c003">angolo</span> un numero che si intende espresso in gradi.</p><p>Questi requisiti sono detti <span class="c009">precondizioni</span> perché si suppone siano verificati prima che la funzione sia eseguita. Per contro, le condizioni che si devono verificare al termine della funzione sono dette <span class="c009">postcondizioni</span>, e comprendono l’effetto che deve avere la funzione (come il disegnare segmenti) e ogni altro effetto minore (come muovere la tartaruga o fare altri cambiamenti).
<a id="hevea_default278"></a>
<a id="hevea_default279"></a></p><p>Le precondizioni sono responsabilità del chiamante. Se questi viola una precondizione (documentata in modo appropriato!) e la funzione non fa correttamente ciò che deve, l’errore sta nel chiamante e non nella funzione.</p><p>Se le precondizioni sono soddisfatte e le postcondizioni no, l’errore sta nella funzione. E il fatto che le vostre pre- e postcondizioni siano chiare, è di aiuto nel debug.</p>
<!--TOC section id="sec55" Glossario-->
<h2 class="section" id="sec55">4.11  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">metodo:</span></dt><dd class="dd-description"> Una funzione associata ad un oggetto che viene chiamata utlizzando la notazione a punto.
<a id="hevea_default280"></a></dd><dt class="dt-description"><span class="c009">ciclo:</span></dt><dd class="dd-description"> Una porzione di programma che può essere eseguita ripetutamente.
<a id="hevea_default281"></a></dd><dt class="dt-description"><span class="c009">incapsulamento:</span></dt><dd class="dd-description"> Il procedimento di trasformare una serie di istruzioni in una funzione.
<a id="hevea_default282"></a></dd><dt class="dt-description"><span class="c009">generalizzazione:</span></dt><dd class="dd-description"> Il procedimento di sostituire qualcosa di inutilmente specifico (come un numero) con qualcosa di più generale ed appropriato (come una variabile o un parametro).
<a id="hevea_default283"></a></dd><dt class="dt-description"><span class="c009">argomento con nome:</span></dt><dd class="dd-description"> Un argomento che include il nome del parametro a cui è destinato come “parola chiave”.
<a id="hevea_default284"></a></dd><dt class="dt-description"><span class="c009">interfaccia:</span></dt><dd class="dd-description"> Una descrizione di come si usa una funzione, incluso il nome, la descrizione degli argomenti e il valore di ritorno.
<a id="hevea_default285"></a></dd><dt class="dt-description"><span class="c009">refactoring:</span></dt><dd class="dd-description"> Il procedimento di modifica di un programma funzionante per migliorare le interfacce delle funzioni e altre qualità del codice.
<a id="hevea_default286"></a></dd><dt class="dt-description"><span class="c009">tecnica di sviluppo:</span></dt><dd class="dd-description"> Procedura di scrittura dei programmi.
<a id="hevea_default287"></a></dd><dt class="dt-description"><span class="c009">stringa di documentazione o docstring:</span></dt><dd class="dd-description"> Una stringa che compare all’inizio di una definizione di una funzione per documentarne l’interfaccia.
<a id="hevea_default288"></a>
<a id="hevea_default289"></a></dd><dt class="dt-description"><span class="c009">precondizione:</span></dt><dd class="dd-description"> Un requisito che deve essere soddisfatto dal chiamante prima di eseguire una funzione.
<a id="hevea_default290"></a></dd><dt class="dt-description"><span class="c009">postcondizione:</span></dt><dd class="dd-description"> Un requisito che deve essere soddisfatto dalla funzione prima di terminare.
<a id="hevea_default291"></a></dd></dl>
<!--TOC section id="sec56" Esercizi-->
<h2 class="section" id="sec56">4.12  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scaricate il codice in questo capitolo dal sito
</em><a href="http://thinkpython2.com/code/polygon.py"><em><span class="c003">http://thinkpython2.com/code/polygon.py</span></em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Disegnate un diagramma di stack che illustri lo stato del programma mentre esegue <span class="c003">cerchio(bob, raggio)</span>. Potete fare i conti a mano o aggiungere istruzioni di stampa al codice.
</em><a id="hevea_default292"></a></li><li class="li-enumerate"><em>La versione di <span class="c003">arco</span> nel Paragrafo </em><a href="#refactoring"><em>4.7</em></a><em> non è molto accurata, perché l’approssimazione lineare del cerchio è sempre esterna al cerchio vero. Ne deriva che la Tartaruga finisce ad alcuni pixel di distanza dal traguardo corretto. La mia soluzione mostra un modo per ridurre questo errore. Leggete il codice e cercate di capirlo. Disegnare un diagramma può aiutarvi a comprendere il funzionamento.</em></li></ol></div><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian003.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 4.1: Fiori disegnati con turtle.</td></tr>
</table></div>
<a id="fig.flowers"></a>
<div class="center"><hr class="c019"></div></blockquote><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default293"></a><p><em>Scrivete un insieme di funzioni, generali in modo appropriato, che disegni dei fiori stilizzati come in Figura </em><a href="#fig.flowers"><em>4.1</em></a><em>.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/flower.py"><em><span class="c003">http://thinkpython2.com/code/flower.py</span></em></a><em>,
richiede anche </em><a href="http://thinkpython2.com/code/polygon.py"><em><span class="c003">http://thinkpython2.com/code/polygon.py</span></em></a><em>.</em></p></div><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian004.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 4.2: Torte disegnate con turtle.</td></tr>
</table></div>
<a id="fig.pies"></a>
<div class="center"><hr class="c019"></div></blockquote><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default294"></a><p><em>Scrivete un insieme di funzioni, generali in modo appropriato, che disegni delle forme a torta come in Figura </em><a href="#fig.pies"><em>4.2</em></a><em>.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/pie.py"><em><span class="c003">http://thinkpython2.com/code/pie.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  
<a id="hevea_default295"></a>
<a id="hevea_default296"></a><p><em>Le lettere dell’alfabeto possono essere costruite con un moderato numero di elementi di base, come linee orizzontali e verticali e alcune curve. Progettate un alfabeto che possa essere disegnato con un numero minimo di elementi di base e poi scrivete delle funzioni che disegnino le lettere.</em></p><p><em>Dovreste scrivere una funzione per ogni lettera, con nomi tipo
<code>disegna_a</code>, <code>disegna_b</code>, ecc., e inserirle in un file di nome <span class="c003">lettere.py</span>. Potete scaricare una “macchina da scrivere a tartaruga” da </em><a href="http://thinkpython2.com/code/typewriter.py"><span class="c003"><em>http://thinkpython2.com/code/typewriter.py</em></span></a><em>
per aiutarvi a provare il vostro codice.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/letters.py"><em><span class="c003">http://thinkpython2.com/code/letters.py</span></em></a><em>, richiede anche
</em><a href="http://thinkpython2.com/code/polygon.py"><em><span class="c003">http://thinkpython2.com/code/polygon.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  <p><em>Documentatevi sulle spirali sul sito </em><a href="http://it.wikipedia.org/wiki/Spirale"><span class="c003"><em>http://it.wikipedia.org/wiki/Spirale</em></span></a><em>; quindi scrivete un programma che disegni una spirale di Archimede (o di qualche altro tipo). Soluzione: </em><a href="http://thinkpython2.com/code/spiral.py"><span class="c003"><em>http://thinkpython2.com/code/spiral.py</em></span></a><em>.
</em><a id="hevea_default297"></a>
<a id="hevea_default298"></a> </p></div>
<!--TOC chapter id="sec57" Istruzioni condizionali e ricorsione-->
<h1 class="chapter" id="sec57">Chapter 5  Istruzioni condizionali e ricorsione</h1><!--SEC END --><p>L’argomento principale di questo capitolo è l’istruzione <span class="c003">if</span>, che permette di eseguire codice diverso a seconda dello stato del programma. Prima di tutto, vediamo però due nuovi operatori: divisione intera e modulo.</p>
<!--TOC section id="sec58" Divisione intera e modulo-->
<h2 class="section" id="sec58">5.1  Divisione intera e modulo</h2><!--SEC END --><p>L’operatore di <span class="c009">divisione intera</span>, <code>//</code>, divide due numeri e arrotonda il risultato all’intero inferiore. Ad esempio, supponiamo che la durata di un film sia di 105 minuti, e di volerla esprimere in ore. La normale divisione restituisce un numero decimale:</p><pre class="verbatim">&gt;&gt;&gt; minuti = 105
&gt;&gt;&gt; minuti / 60
1.75
</pre><p>Ma di solito non si esprimono le ore con un numero decimale. La divisione intera dà invece come risultato il numero di ore, arrotondando per difetto:</p><pre class="verbatim">&gt;&gt;&gt; minuti = 105
&gt;&gt;&gt; ore = minuti // 60
&gt;&gt;&gt; ore
1
</pre><p>Per ottenere il resto, potete sottrarre dai minuti l’equivalente delle ore:</p><pre class="verbatim">&gt;&gt;&gt; resto = minuti - ore * 60
&gt;&gt;&gt; resto
45
</pre><p><a id="hevea_default299"></a>
<a id="hevea_default300"></a>
<a id="hevea_default301"></a>
<a id="hevea_default302"></a></p><p>Come alternativa si può utilizzare l’<span class="c009">operatore modulo</span>, <code>%</code>, che 
restituisce il resto dell’operazione di divisione tra due numeri interi.</p><pre class="verbatim">&gt;&gt;&gt; resto = minuti % 60
&gt;&gt;&gt; resto
45
</pre><p>L’operatore modulo è più utile di quel che sembra. Per esempio, vi permette di controllare se un numero intero è divisibile per un altro: se
<span class="c003">x % y</span> è zero, significa che <span class="c003">x</span> è divisibile per <span class="c003">y</span>.
<a id="hevea_default303"></a></p><p>Potete inoltre estrarre la cifra più a destra o più cifre di un numero. Ad esempio <span class="c003">x % 10</span> restituisce la cifra più a destra di <span class="c003">x</span> (in base 10). E analogamente, <span class="c003">x % 100</span> restituisce le ultime due cifre.</p><p>Per chi usa Python 2, la divisione funziona in modo diverso. L’operatore di divisione intera non esiste, e quello di divisione, <code>/</code>, esegue una divisione intera se entrambi gli operandi sono interi, mentre il risultato è un decimale a virgola mobile se almeno uno degli operandi è un decimale.
<a id="hevea_default304"></a></p>
<!--TOC section id="sec59" Espressioni booleane-->
<h2 class="section" id="sec59">5.2  Espressioni booleane</h2><!--SEC END --><p>
<a id="hevea_default305"></a>
<a id="hevea_default306"></a></p><p>Un’<span class="c009">espressione booleana</span> è un’espressione che può essere o vera o falsa. Gli esempi che seguono usano l’operatore <span class="c003">==</span>, confrontano due valori e restituiscono <span class="c003">True</span> (vero) se sono uguali, <span class="c003">False</span> (falso) altrimenti:</p><pre class="verbatim">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</pre><p>
<span class="c003">True</span> e <span class="c003">False</span> sono valori speciali che sono di tipo <span class="c003">bool</span>; non sono delle stringhe:
<a id="hevea_default307"></a>
<a id="hevea_default308"></a>
<a id="hevea_default309"></a>
<a id="hevea_default310"></a>
<a id="hevea_default311"></a>
<a id="hevea_default312"></a></p><pre class="verbatim">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</pre><p>
L’operatore <span class="c003">==</span> è uno degli <span class="c009">operatori di confronto</span> (chiamati anche operatori relazionali); gli altri sono:</p><pre class="verbatim">      x != y               # x è diverso da y
      x &gt; y                # x è maggiore di y
      x &lt; y                # x è minore di y
      x &gt;= y               # x è maggiore o uguale a y
      x &lt;= y               # x è minore o uguale a y
</pre><p>
Queste operazioni vi saranno familiari, tuttavia i simboli usati in Python non sono del tutto uguali a quelli matematici. Un errore frequente è usare il simbolo di uguale(<span class="c003">=</span>) anziché il doppio uguale (<span class="c003">==</span>). Ricordatevi la differenza: <span class="c003">=</span> è un operatore di assegnazione, mentre <span class="c003">==</span> è un operatore di confronto. Inoltre in Python non esistono simboli come <span class="c003">=&lt;</span> o <span class="c003">=&gt;</span>.
<a id="hevea_default313"></a>
<a id="hevea_default314"></a></p>
<!--TOC section id="sec60" Operatori logici-->
<h2 class="section" id="sec60">5.3  Operatori logici</h2><!--SEC END --><p>
<a id="hevea_default315"></a>
<a id="hevea_default316"></a></p><p>Ci sono tre <span class="c009">operatori logici</span>: <span class="c003">and</span>, <span class="c003">or</span>, e <span class="c003">not</span>. Il significato di questi operatori è simile a quello comune (e, o, non): per esempio, l’espressione <span class="c003">x &gt; 0 and x &lt; 10</span> è vera solo se sono vere <em>entrambe</em> le condizioni, cioè <span class="c003">x</span> è più grande di 0 <em>e</em> più piccolo di 10.
<a id="hevea_default317"></a>
<a id="hevea_default318"></a>
<a id="hevea_default319"></a>
<a id="hevea_default320"></a>
<a id="hevea_default321"></a>
<a id="hevea_default322"></a></p><p>L’espressione <span class="c003">n % 2 == 0 or n % 3 == 0</span> invece è vera se è verificata <em>almeno una</em> delle due condizioni, cioè se il numero è divisibile per 2 <em>o</em> per 3 (o per entrambi).</p><p>Infine, l’operatore <span class="c003">not</span> nega il valore di un’espressione booleana, per cui <span class="c003">not (x &gt; y)</span> è vera se <span class="c003">x &gt; y</span> è falsa, cioè se <span class="c003">x</span> è minore o uguale a <span class="c003">y</span>.</p><p>In senso stretto, gli operandi degli operatori logici dovrebbero essere delle espressioni booleane, ma qui Python non è rigido: ogni numero diverso da zero viene accettato ed interpretato come <span class="c003">True</span>.</p><pre class="verbatim">&gt;&gt;&gt; 42 and True
True
</pre><p>
Questa flessibilità può essere utile, ma ci sono alcune sottigliezze che potrebbero confondere. È preferibile evitarla (a meno che non sappiate esattamente quello che state facendo).</p>
<!--TOC section id="sec61" Esecuzione condizionale-->
<h2 class="section" id="sec61">5.4  Esecuzione condizionale</h2><!--SEC END --><p>
<a id="conditional.execution"></a></p><p><a id="hevea_default323"></a>
<a id="hevea_default324"></a>
<a id="hevea_default325"></a>
<a id="hevea_default326"></a>
Se volete scrivere programmi utili, vi capiterà spesso di dover controllare se si verificano determinate condizioni, e di variare di conseguenza il comportamento del programma. Le <span class="c009">istruzioni condizionali</span> servono proprio a questo. La forma più semplice di istruzione condizionale è l’istruzione <span class="c003">if</span> (“se” in inglese):</p><pre class="verbatim">if x &gt; 0:
    print('x è positivo')
</pre><p>
L’espressione booleana dopo l’istruzione <span class="c003">if</span> è chiamata <span class="c009">condizione</span>. Se risulta vera, viene eseguita l’istruzione indentata che segue sulla riga successiva. Altrimenti, non succede nulla.
<a id="hevea_default327"></a>
<a id="hevea_default328"></a></p><p>L’istruzione <span class="c003">if</span> ha la stessa struttura che abbiamo già visto nel caso delle definizioni di funzione: un’intestazione seguita da un corpo indentato. Le istruzioni come questa vengono chiamate <span class="c009">istruzioni composte</span>.</p><p>Non c’è limite al numero di istruzioni che possono essere scritte nel corpo, ma deve sempre essercene almeno una. Talvolta può servire che il corpo sia privo di istruzioni (di solito quando c’è del codice ancora da scrivere); in questo caso potete usare l’istruzione <span class="c003">pass</span>, che serve solo da segnaposto temporaneo e nulla più:
<a id="hevea_default329"></a>
<a id="hevea_default330"></a></p><pre class="verbatim">if x &lt; 0:
    pass          # scrivere cosa fare con i valori negativi!
</pre>
<!--TOC section id="sec62" Esecuzione alternativa-->
<h2 class="section" id="sec62">5.5  Esecuzione alternativa</h2><!--SEC END --><p>
<a id="alternative.execution"></a>
<a id="hevea_default331"></a>
<a id="hevea_default332"></a>
<a id="hevea_default333"></a></p><p>Una seconda forma di istruzione <span class="c003">if</span> è l’<span class="c009">esecuzione alternativa</span>,
dove esistono due possibili azioni, e il valore della condizione determina quale delle due azioni debba essere eseguita e quale no. La sintassi è:</p><pre class="verbatim">if x % 2 == 0:
    print('x è pari')
else:
    print('x è dispari')
</pre><p>
Se il resto della divisione di <span class="c003">x</span> per 2 è zero, significa che <span class="c003">x</span> è un numero pari, e il programma mostra il messaggio appropriato. Altrimenti (<code>else</code>), se la condizione è falsa, viene eseguito il secondo blocco di istruzioni. Dato che la condizione deve essere necessariamente o vera o falsa, sarà sempre eseguita una sola delle due alternative. Queste sono dette <span class="c009">ramificazioni</span>, perché rappresentano dei bivi nel flusso di esecuzione del programma.
<a id="hevea_default334"></a></p>
<!--TOC section id="sec63" Condizioni in serie-->
<h2 class="section" id="sec63">5.6  Condizioni in serie</h2><!--SEC END --><p>
<a id="hevea_default335"></a>
<a id="hevea_default336"></a></p><p>A volte è necessario considerare più di due possibili sviluppi, e occorre che nel programma ci siano più di due ramificazioni. Un modo per esprimere questo tipo di calcolo sono le <span class="c009">condizioni in serie</span>:</p><pre class="verbatim">if x &lt; y:
    print('x è minore di y')
elif x &gt; y:
    print('x è maggiore di y')
else:
    print('x e y sono uguali')
</pre><p>
<span class="c003">elif</span> è l’abbreviazione di <em>else if</em>, che in inglese significa “altrimenti se”. Anche stavolta verrà eseguito solo uno dei tre rami, a seconda dell’esito del confronto tra <span class="c003">x</span> e <span class="c003">y</span>. Non c’è alcun limite al numero di istruzioni <span class="c003">elif</span>. Se esiste una clausola <span class="c003">else</span>, deve essere scritta per ultima, ma non è obbligatoria; il ramo corrispondente viene eseguito solo quando tutte le condizioni precedenti sono false.
<a id="hevea_default337"></a>
<a id="hevea_default338"></a></p><pre class="verbatim">if scelta == 'a':
    disegna_a()
elif scelta == 'b':
    disegna_b()
elif scelta == 'c':
    disegna_c()
</pre><p>
Le condizioni vengono controllate nell’ordine dall’alto al basso: se la prima è falsa, viene controllata la seconda e così via. Non appena una condizione risulta vera, viene eseguito il ramo corrispondente e l’istruzione termina. Anche se risultassero vere altre condizioni successive, viene eseguita sempre e soltanto la prima che risulta vera. </p>
<!--TOC section id="sec64" Condizioni nidificate-->
<h2 class="section" id="sec64">5.7  Condizioni nidificate</h2><!--SEC END --><p>
<a id="hevea_default339"></a></p><p>Si può anche inserire un’istruzione condizionale nel corpo di un’altra istruzione condizionale. Possiamo dunque scrivere l’esempio del paragrafo precedente anche in questo modo:</p><pre class="verbatim">if x == y:
    print('x e y sono uguali')
else:
    if x &lt; y:
        print('x è minore di y')
    else:
        print('x è maggiore di y')
</pre><p>
La condizione più esterna contiene due rami: il primo contiene un’istruzione semplice, il secondo un’altra istruzione <span class="c003">if</span> che a sua volta ha due ramificazioni. Entrambi i rami del secondo <span class="c003">if</span> sono istruzioni di stampa, ma potrebbero anche contenere a loro volta ulteriori istruzioni condizionali.</p><p>Anche se l’indentazione delle istruzioni aiuta ad evidenziare la struttura, le <span class="c009">condizioni nidificate</span> diventano rapidamente difficili da leggere, quindi è meglio usarle con moderazione.</p><p>Gli operatori logici permettono spesso di semplificare le istruzioni condizionali nidificate. Il codice seguente può essere riscritto usando un’unica condizione:</p><pre class="verbatim">if 0 &lt; x:
    if x &lt; 10:
        print('x è un numero positivo a una cifra.')
</pre><p>
Infatti, dato che l’istruzione di stampa è eseguita solo se si verificano entrambe le condizioni, possiamo ottenere lo stesso risultato usando l’operatore <span class="c003">and</span>:</p><pre class="verbatim">if 0 &lt; x and x &lt; 10:
    print('x è un numero positivo a una cifra.')
</pre><p>Per una condizione di questo tipo, Python consente anche un’opzione sintattica più concisa:</p><pre class="verbatim">if 0 &lt; x &lt; 10:
    print('x è un numero positivo a una cifra.')
</pre>
<!--TOC section id="sec65" Ricorsione-->
<h2 class="section" id="sec65">5.8  Ricorsione</h2><!--SEC END --><p>
<a id="recursion"></a>
<a id="hevea_default340"></a></p><p>Abbiamo visto che è del tutto normale che una funzione ne chiami un’altra, ma è anche consentito ad una funzione di chiamare se stessa. L’utilità può non essere immediatamente comprensibile, ma questa è una delle cose più magiche che un programma possa fare. Per fare un esempio, diamo un’occhiata a questa funzione:</p><pre class="verbatim">def contoallarovescia(n):
    if n &lt;= 0:
        print('Via!')
    else:
        print(n)
        contoallarovescia(n-1)
</pre><p>
Se <span class="c003">n</span> vale 0 o è negativo, la funzione scrive la parola “Via!”.
Altrimenti scrive il numero <span class="c003">n</span> e poi chiama la funzione <span class="c003">contoallarovescia</span> (cioè se stessa) passando un argomento che vale <span class="c003">n-1</span>.</p><p>Cosa succede quando chiamiamo la funzione in questo modo?</p><pre class="verbatim">&gt;&gt;&gt; contoallarovescia(3)
</pre><p>
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=3</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 3, poi chiama se stessa...</p><blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=2</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 2, poi chiama se stessa...<blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=1</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 1, poi chiama se stessa...<blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=0</span>, e dato che <span class="c003">n</span> è uguale a 0, stampa la parola “Via!” e poi ritorna.
</blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=1</span> ritorna.
</p></blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=2</span> ritorna.
</p></blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=3</span> ritorna.</p><p>E infine ritorniamo in <code>__main__</code>. Il risultato finale è questo:
<a id="hevea_default341"></a></p><pre class="verbatim">3
2
1
Via!
</pre><p>
Una funzione che chiama se stessa si dice <span class="c009">ricorsiva</span> e la procedura che la esegue è detta <span class="c009">ricorsione</span>.
<a id="hevea_default342"></a>
<a id="hevea_default343"></a></p><p>Come secondo esempio, scriviamo una funzione che stampi una data stringa per <span class="c003">n</span> volte.</p><pre class="verbatim">def stampa_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    stampa_n(s, n-1)
</pre><p>
Se <span class="c003">n &lt;= 0</span> l’<span class="c009">istruzione di ritorno</span> <span class="c003">return</span> provoca l’uscita dalla funzione. Il flusso dell’esecuzione torna immediatamente al chiamante, e le righe rimanenti della funzione non vengono eseguite.
<a id="hevea_default344"></a>
<a id="hevea_default345"></a></p><p>Il resto della funzione è simile a <span class="c003">contoallarovescia</span>: visualizza la stringa <span class="c003">s</span> e chiama se stessa per <span class="c008">n</span>−1 altre volte. Il numero di righe risultanti sarà <span class="c003">1 + (n - 1)</span>, che corrisponde a
<span class="c003">n</span>.</p><p>Per esempi semplici come questi, è forse più facile usare un ciclo <span class="c003">for</span>. Vedremo però più avanti degli esempi difficili da scrivere con un ciclo <span class="c003">for</span> ma facili con la ricorsione; meglio quindi cominciare subito a prendere mano.
<a id="hevea_default346"></a>
<a id="hevea_default347"></a></p>
<!--TOC section id="sec66" Diagrammi di stack delle funzioni ricorsive-->
<h2 class="section" id="sec66">5.9  Diagrammi di stack delle funzioni ricorsive</h2><!--SEC END --><p>
<a id="recursive.stack"></a>
<a id="hevea_default348"></a>
<a id="hevea_default349"></a>
<a id="hevea_default350"></a></p><p>Nel Paragrafo <a href="#stackdiagram">3.9</a>, abbiamo usato un diagramma di stack per raffigurare lo stato di un programma nel corso di una chiamata di funzione. Lo stesso tipo di diagramma può servire a capire come lavora una funzione ricorsiva.</p><p>Ad ogni chiamata di funzione, Python crea un frame che contiene le variabili locali interne alla funzione ed i suoi parametri. Nel caso di una funzione ricorsiva, possono esserci contemporaneamente più frame della stessa funzione nello stack.</p><p>La Figura <a href="#fig.stack2">5.1</a> mostra il diagramma di stack della funzione <span class="c003">contoallarovescia</span> chiamata con <span class="c003">n = 3</span>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian005.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 5.1: Diagramma di stack.</td></tr>
</table></div>
<a id="fig.stack2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Come al solito, il livello superiore dello stack è il frame di <code>__main__</code>, che
è vuoto, perché non vi abbiamo creato alcuna variabile né gli abbiamo passato alcun argomento.
<a id="hevea_default351"></a>
<a id="hevea_default352"></a></p><p>Nei quattro frame di <span class="c003">contoallarovescia</span>, il parametro <span class="c003">n</span> ha valori differenti. Il livello inferiore dello stack, dove <span class="c003">n=0</span>, è chiamato <span class="c009">caso base</span>. Quest’ultimo non effettua ulteriori chiamate ricorsive, quindi non produce ulteriori frame.</p><p>Come esercizio, disegnate il diagramma di stack della funzione <code>stampa_n</code> chiamata con <code>s='Ciao'</code> e <span class="c003">n=2</span>. Poi, scrivete una funzione di nome <code>fai_n</code> che accetti come argomenti un oggetto funzione e un numero <span class="c003">n</span>, e che chiami per <span class="c003">n</span> volte la funzione data.</p>
<!--TOC section id="sec67" Ricorsione infinita-->
<h2 class="section" id="sec67">5.10  Ricorsione infinita</h2><!--SEC END --><p>
<a id="hevea_default353"></a>
<a id="hevea_default354"></a></p><p><a id="hevea_default355"></a></p><p>Se una ricorsione non raggiunge mai un caso base, continua ad effettuare chiamate ricorsive all’infinito e il programma non può terminare. Questa situazione è nota come <span class="c009">ricorsione infinita</span>, e di solito non è considerata un fatto positivo.
Ecco un programma minimale che genera una ricorsione infinita:</p><pre class="verbatim">def ricorsiva():
    ricorsiva()
</pre><p>
Nella maggior parte degli ambienti di programmazione, un programma con una ricorsione infinita non viene eseguito davvero all’infinito. Python mostra un messaggio di errore quando viene raggiunto il massimo livello di ricorsione consentito:
<a id="hevea_default356"></a>
<a id="hevea_default357"></a></p><pre class="verbatim">  File "&lt;stdin&gt;", line 2, in ricorsiva
  File "&lt;stdin&gt;", line 2, in ricorsiva
  File "&lt;stdin&gt;", line 2, in ricorsiva
                  .   
                  .
                  .
  File "&lt;stdin&gt;", line 2, in ricorsiva
RuntimeError: Maximum recursion depth exceeded
</pre><p>
Questo traceback è un po’ più grande di quello che abbiamo visto nel capitolo precedente. Quando si verifica l’errore, nello stack ci sono oltre 1000 frame di <span class="c003">ricorsiva</span>!</p><p>Se vi imbattete accidentalmente in una ricorsione infinita, rivedete la vostra funzione per accertare che esista un caso base che non genera una ulteriore chiamata ricorsiva. E se c’è un caso base, controllate che venga sicuramente raggiunto.</p>
<!--TOC section id="sec68" Input da tastiera-->
<h2 class="section" id="sec68">5.11  Input da tastiera</h2><!--SEC END --><p>
<a id="hevea_default358"></a></p><p>I programmi che abbiamo scritto finora non accettano dati in ingresso da parte dell’utente, ed eseguono sempre le stesse operazioni.</p><p>In Python esiste una funzione predefinita chiamata <code>input</code> che sospende il programma ed attende che l’utente scriva qualcosa. Quando l’utente preme il tasto <span class="c005">Invio</span> oppure <span class="c005">Enter</span>, il programma riprende e <code>input</code> restituisce quello che l’utente ha inserito, come stringa. In Python 2, la funzione si chiama invece <code>raw_input</code> .
<a id="hevea_default359"></a>
<a id="hevea_default360"></a>
<a id="hevea_default361"></a></p><pre class="verbatim">&gt;&gt;&gt; testo = input()
Cosa stai aspettando?
&gt;&gt;&gt; testo
'Cosa stai aspettando?'
</pre><p>
Prima dell’inserimento dei dati, è buona norma visualizzare un messaggio, chiamato prompt, che informa l’utente di ciò che deve inserire. A questo scopo, <code>input</code> accetta un prompt come argomento:
<a id="hevea_default362"></a></p><pre class="verbatim">&gt;&gt;&gt; nome = input('Come...ti chiami?\n')
Come...ti chiami?
Artù, Re dei Bretoni!
&gt;&gt;&gt; nome
'Artù, Re dei Bretoni!'
</pre><p>
La sequenza <code>\n</code> alla fine del prompt rappresenta un <span class="c009">ritorno a capo</span>,
un carattere speciale che provoca un’interruzione di riga. Ecco perché l’input dell’utente compare sulla riga successiva sotto al prompt.
<a id="hevea_default363"></a></p><p>Se l’input atteso deve essere un numero intero, si può provare a convertire il valore inserito in <span class="c003">int</span>:</p><pre class="verbatim">&gt;&gt;&gt; prompt = 'Qual è la velocità in volo di una rondine?\n'
&gt;&gt;&gt; velocita = input(prompt)
Qual è la velocità in volo di una rondine?
42
&gt;&gt;&gt; int(velocita)
42
</pre><p>
Ma se la stringa inserita contiene qualcosa di diverso da dei valori numerici, si verifica un errore:</p><pre class="verbatim">&gt;&gt;&gt; velocita = input(prompt)
Qual è la velocità in volo di una rondine?
Cosa intendi, una rondine europea o africana?
&gt;&gt;&gt; int(velocita)
ValueError: invalid literal for int() with base 10
</pre><p>
Vedremo più avanti come trattare questo tipo di errori.
<a id="hevea_default364"></a>
<a id="hevea_default365"></a></p>
<!--TOC section id="sec69" Debug-->
<h2 class="section" id="sec69">5.12  Debug</h2><!--SEC END --><p>
<a id="whitespace"></a>
<a id="hevea_default366"></a>
<a id="hevea_default367"></a></p><p>Quando si verifica un errore di sintassi o di runtime, il messaggio d’errore contiene molte informazioni, ma può essere sovrabbondante. Di solito le parti più utili sono:</p><ul class="itemize"><li class="li-itemize">Che tipo di errore era, e</li><li class="li-itemize">Dove si è verificato.</li></ul><p>Gli errori di sintassi di solito sono facili da trovare, con qualche eccezione. Gli spaziatori possono essere insidiosi, perché spazi e tabulazioni non sono visibili e non siamo abituati a tenerne conto.
<a id="hevea_default368"></a></p><pre class="verbatim">&gt;&gt;&gt; x = 5
&gt;&gt;&gt;  y = 6
  File "&lt;stdin&gt;", line 1
    y = 6
    ^
IndentationError: unexpected indent
</pre><p>
In questo esempio, il problema è che la seconda riga è erroneamente indentata di uno spazio, mentre dovrebbe stare al margine sinistro. Ma il messaggio di errore punta su <span class="c003">y</span>, portando fuori strada. In genere, i messaggi di errore indicano dove il problema è venuto a galla, ma il vero errore potrebbe essere in un punto precedente del codice, a volte anche nella riga precedente.</p><p><a id="hevea_default369"></a></p><p>Lo stesso vale per gli errori di runtime. </p><p>Supponiamo di voler calcolare un rapporto segnale/rumore in decibel. La formula è
<span class="c008">SNR</span><sub><span class="c008">db</span></sub> = 10 log<sub>10</sub> (<span class="c008">P</span><sub><span class="c008">segnale</span></sub> / <span class="c008">P</span><sub><span class="c008">rumore</span></sub>). In Python si può scrivere:</p><pre class="verbatim">import math
potenza_segnale = 9
potenza_rumore = 10
rapporto = potenza_segnale // potenza_rumore
decibel = 10 * math.log10(rapporto)
print(decibel)
</pre><p>
Se avviate questo programma, compare un messaggio di errore.
<a id="hevea_default370"></a>
<a id="hevea_default371"></a></p><pre class="verbatim">Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibel = 10 * math.log10(rapporto)
ValueError: math domain error
</pre><p>
Il messaggio punta alla riga 5, ma lì non c’è niente di sbagliato. Per trovare il vero errore, può essere utile stampare il valore di <span class="c003">rapporto</span>, che risulta essere 0. Il problema sta nella riga 4, perché calcola una divisione intera anziché una normale divisione.
<a id="hevea_default372"></a></p><p>Prendetevi la briga di leggere attentamente i messaggi di errore, ma non date per scontato che tutto quello che dicono sia esatto.</p>
<!--TOC section id="sec70" Glossario-->
<h2 class="section" id="sec70">5.13  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">divisione intera:</span></dt><dd class="dd-description"> Operatore, che ha per simbolo <span class="c003">//</span>, che divide due numeri e arrotonda il risultato all’intero inferiore (ovvero, verso l’infinito negativo).
<a id="hevea_default373"></a></dd><dt class="dt-description"><span class="c009">operatore modulo:</span></dt><dd class="dd-description"> Operatore matematico, che ha per simbolo (<span class="c003">%</span>), che restituisce il resto della divisione tra due operandi interi.
<a id="hevea_default374"></a>
<a id="hevea_default375"></a></dd><dt class="dt-description"><span class="c009">espressione booleana:</span></dt><dd class="dd-description"> Espressione il cui valore è o vero 
(<span class="c003">True</span>) o falso (<span class="c003">False</span>).
<a id="hevea_default376"></a></dd><dt class="dt-description"><span class="c009">operatore di confronto:</span></dt><dd class="dd-description"> Operatore che confronta due valori detti operandi: <span class="c003">==</span>, <span class="c003">!=</span>, <span class="c003">&gt;</span>, <span class="c003">&lt;</span>, <span class="c003">&gt;=</span>, e <span class="c003">&lt;=</span>.</dd><dt class="dt-description"><span class="c009">operatore logico:</span></dt><dd class="dd-description"> Operatore che unisce delle espressioni booleane: <span class="c003">and</span>, <span class="c003">or</span>, e <span class="c003">not</span>.</dd><dt class="dt-description"><span class="c009">istruzione condizionale:</span></dt><dd class="dd-description"> Istruzione che controlla il flusso di esecuzione del programma, variandolo a seconda di determinate condizioni.
<a id="hevea_default377"></a></dd><dt class="dt-description"><span class="c009">condizione:</span></dt><dd class="dd-description"> Espressione booleana in un’istruzione condizionale che determina quale ramificazione sarà eseguita.
<a id="hevea_default378"></a></dd><dt class="dt-description"><span class="c009">istruzione composta:</span></dt><dd class="dd-description"> Istruzione che consiste di un’intestazione e di un corpo. L’intestazione deve terminare con i due punti (:) e il corpo deve essere indentato rispetto ad essa.
<a id="hevea_default379"></a></dd><dt class="dt-description"><span class="c009">ramificazione:</span></dt><dd class="dd-description"> Uno dei blocchi di istruzioni alternative presenti in un’istruzione condizionale.
<a id="hevea_default380"></a></dd><dt class="dt-description"><span class="c009">condizioni in serie:</span></dt><dd class="dd-description"> Istruzione condizionale con una serie di ramificazioni alternative.
<a id="hevea_default381"></a></dd><dt class="dt-description"><span class="c009">condizione nidificata (o annidata):</span></dt><dd class="dd-description"> Un’istruzione condizionale inserita in una ramificazione di un’altra istruzione condizionale.
<a id="hevea_default382"></a></dd><dt class="dt-description"><span class="c009">istruzione di ritorno:</span></dt><dd class="dd-description"> Un’istruzione che fa terminare immediatamente una funzione e ritorna al chiamante.</dd><dt class="dt-description"><span class="c009">ricorsione:</span></dt><dd class="dd-description"> Procedura che chiama la stessa funzione attualmente in esecuzione.
<a id="hevea_default383"></a></dd><dt class="dt-description"><span class="c009">caso base:</span></dt><dd class="dd-description"> Ramificazione di un’istruzione condizionale, posta in una funzione ricorsiva, che non esegue a sua volta una chiamata ricorsiva.
<a id="hevea_default384"></a></dd><dt class="dt-description"><span class="c009">ricorsione infinita:</span></dt><dd class="dd-description"> Una ricorsione priva di un caso base, oppure che non lo raggiunge mai. Nell’evenienza, causa un errore in esecuzione.
<a id="hevea_default385"></a></dd></dl>
<!--TOC section id="sec71" Esercizi-->
<h2 class="section" id="sec71">5.14  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Il modulo <span class="c003">time</span> contiene una funzione, anch’essa di nome <span class="c003">time</span>, che restituisce l’attuale GMT (Tempo Medio di Greenwich) riferito ad un “tempo zero”, che è un momento arbitrario usato come punto di riferimento. Nei sistemi UNIX, questo “tempo zero” è il 1 gennaio 1970.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</em></pre><p><em>Realizzate uno script che acquisisca il tempo attuale e lo converta in un tempo in ore, minuti e secondi, più i giorni trascorsi dal “tempo zero”.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default386"></a><p><em>L’ultimo teorema di Fermat afferma che non esistono interi positivi
</em><span class="c008">a</span><em>, </em><span class="c008">b</span><em>, e </em><span class="c008">c</span><em> tali che</em></p><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008">a</span><sup><span class="c008">n</span></sup> + <span class="c008">b</span><sup><span class="c008">n</span></sup> = <span class="c008">c</span><sup><span class="c008">n</span></sup> </td></tr>
</table><p><em>
per qualsiasi valore di </em><span class="c008">n</span><em> maggiore di 2.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <code>verifica_fermat</code> che richieda quattro parametri—<span class="c003">a</span>, <span class="c003">b</span>, <span class="c003">c</span> e <span class="c003">n</span>—e controlli se il teorema regge. Se </em><span class="c008">n</span><em> è maggiore di 2 e fosse</em><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008"><em>a</em></span><sup><span class="c008"><em>n</em></span></sup><em> + <span class="c008">b</span></em><sup><span class="c008"><em>n</em></span></sup><em> = <span class="c008">c</span></em><sup><span class="c008"><em>n</em></span></sup><em> </em></td></tr>
</table><p><em>
il programma dovrebbe visualizzare: “Santi Numi, Fermat si è sbagliato!”,
altrimenti: “No, questo non è vero.”</em></p></li><li class="li-enumerate"><em>Scrivete una funzione che chieda all’utente di inserire valori di <span class="c003">a</span>, <span class="c003">b</span>, <span class="c003">c</span> e <span class="c003">n</span>, li converta in interi e usi <code>verifica_fermat</code> per controllare se violano il teorema di Fermat.</em></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default387"></a><p><em>Dati tre bastoncini, può essere possibile o meno riuscire a sistemarli in modo da formare un triangolo. Per esempio, se uno dei bastoncini misura 12 centimetri e gli altri due 1 centimetro, non riuscirete a far toccare le estremità di tutti e tre i bastoncini. Date tre lunghezze, c’è una semplice regola per controllare se è possibile formare un triangolo:</em></p><blockquote class="quotation"><em>
Se una qualsiasi delle tre lunghezze è maggiore della somma delle altre due, non potete formare un triangolo. (Se la somma di due lunghezze è uguale alla terza, si ha un triangolo “degenere”.)
</em></blockquote><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <code>triangolo</code> che riceva tre interi come argomenti e che mostri “Si”’ o “No”, a seconda che si possa o meno formare un triangolo con dei bastoncini delle tre lunghezze date.</em></li><li class="li-enumerate"><em>Scrivete una funzione che chieda all’utente di inserire tre lunghezze, le converta in interi, e le passi a <code>triangolo</code> per verificare se si possa o meno formare un triangolo.</em></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Qual è l’output del seguente programma?
Disegnate un diagramma di stack che illustri lo stato del programma nel momento in cui stampa il risultato.</em></p><pre class="verbatim"><em>def ricorsione(n, s):
    if n == 0:
        print(s)
    else:
        ricorsione(n-1, n+s)

ricorsione(3, 0)
</em></pre><ol class="enumerate" type=1><li class="li-enumerate"><em>Cosa succede se chiamate la funzione in questo modo: <span class="c003">ricorsione(-1, 0)</span>?</em></li><li class="li-enumerate"><em>Scrivete una stringa di documentazione che spieghi tutto quello che serve per usare questa funzione (e niente di più).</em></li></ol></div><p>Gli esercizi seguenti utilizzano il modulo turtle, descritto nel Capitolo <a href="#turtlechap">4</a>:
<a id="hevea_default388"></a></p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  <p><em>Leggete la seguente funzione e cercate di capire cosa fa (vedere gli esempi nel Capitolo </em><a href="#turtlechap"><em>4</em></a><em>). Quindi eseguitela per controllare se avevate indovinato.</em></p><pre class="verbatim"><em>def disegna(t, lunghezza, n):
    if n == 0:
        return
    angolo = 50
    t.fd(lunghezza*n)
    t.lt(angolo)
    disegna(t, lunghezza, n-1)
    t.rt(2*angolo)
    disegna(t, lunghezza, n-1)
    t.lt(angolo)
    t.bk(lunghezza*n)
</em></pre></div><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian006.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 5.2: Una curva di Koch.</td></tr>
</table></div>
<a id="fig.koch"></a>
<div class="center"><hr class="c019"></div></blockquote><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  
<a id="hevea_default389"></a><p><em>La curva di Koch è un frattale che somiglia a quello in Figura </em><a href="#fig.koch"><em>5.2</em></a><em>. Per disegnare una curva di Koch di lunghezza </em><span class="c008">x</span><em>, dovete:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a sinistra di 60 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a destra di 120 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a sinistra di 60 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li></ol><p><em>Ad eccezione di quando </em><span class="c008">x</span><em> è minore di 3: in questo caso si disegna una linea dritta lunga </em><span class="c008">x</span><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <span class="c003">koch</span> che preveda una tartaruga e una lunghezza come parametri, e che usi la tartaruga per disegnare una curva di Koch della data lunghezza.</em></li><li class="li-enumerate"><em>Scrivete una funzione chiamata <span class="c003">fioccodineve</span> che disegni tre curve di Koch per ottenere il contorno di un fiocco di neve.</em><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/koch.py"><em><span class="c003">http://thinkpython2.com/code/koch.py</span></em></a><em>.</em></p></li><li class="li-enumerate"><em>La curva di Koch può essere generalizzata in alcuni modi. Consultate 
</em><a href="http://it.wikipedia.org/wiki/Curva_di_Koch"><em><span class="c003">http://it.wikipedia.org/wiki/Curva_di_Koch</span></em></a><em> per degli esempi e implementate quello che preferite.</em></li></ol></div>
<!--TOC chapter id="sec72" Funzioni produttive-->
<h1 class="chapter" id="sec72">Chapter 6  Funzioni produttive</h1><!--SEC END --><p>
<a id="fruitchap"></a></p><p>Molte tra le funzioni di Python che abbiamo usato, come quelle matematiche, producono dei valori di ritorno. Ma quelle che abbiamo scritto noi finora sono tutte “vuote”: hanno un qualche effetto, come visualizzare un testo o muovere tartarughe, ma non hanno un valore di ritorno. In questo capitolo vedremo come si scrivono le funzioni che chiameremo “produttive”.</p>
<!--TOC section id="sec73" Valori di ritorno-->
<h2 class="section" id="sec73">6.1  Valori di ritorno</h2><!--SEC END --><p>
<a id="hevea_default390"></a></p><p>La chiamata di una funzione genera un nuovo valore, che di solito viene associato ad una variabile o si usa come parte di un’espressione.</p><pre class="verbatim">e = math.exp(1.0)
altezza = raggio * math.sin(radianti)
</pre><p>
Le funzioni che abbiamo scritto finora sono “vuote”. Detto in modo semplicistico, non hanno valore di ritorno; ma a voler essere precisi, il loro valore di ritorno è <span class="c003">None</span>.</p><p>In questo capitolo scriveremo finalmente delle funzioni che restituiscono un valore e che chiameremo funzioni “produttive”.
Facciamo un primo esempio con <span class="c003">area</span>, che calcola l’area di un cerchio di dato raggio:</p><pre class="verbatim">def area(raggio):
    a = math.pi * raggio**2
    return a
</pre><p>
Abbiamo già incontrato l’istruzione <span class="c003">return</span>, ma in una funzione produttiva questa istruzione include un’espressione. Il suo significato è: “ritorna subito da questa funzione e usa l’espressione seguente come valore di ritorno”. L’espressione può essere anche complessa, e allora possiamo riscrivere la funzione in modo più compatto:
<a id="hevea_default391"></a>
<a id="hevea_default392"></a></p><pre class="verbatim">def area(raggio):
    return math.pi * raggio**2
</pre><p>
Peraltro, una <span class="c009">variabile temporanea</span> come <span class="c003">a</span> può rendere più agevole il debug.
<a id="hevea_default393"></a></p><p>Talvolta occorre prevedere più istruzioni di ritorno, una per ciascuna ramificazione di un’istruzione condizionale:</p><pre class="verbatim">def valore_assoluto(x):
    if x &lt; 0:
        return -x
    else:
        return x
</pre><p>
Dato che queste istruzioni <span class="c003">return</span> si trovano in due rami di una
condizione alternativa, solo una delle due sarà effettivamente eseguita.</p><p>Non appena viene eseguita un’istruzione <span class="c003">return</span>, la funzione termina senza eseguire ulteriori istruzioni. Il codice che viene a trovarsi dopo l’istruzione <span class="c003">return</span> o in ogni altro punto che non può essere raggiunto dal flusso di esecuzione, è detto <span class="c009">codice morto</span>.
<a id="hevea_default394"></a></p><p>In una funzione produttiva, occorre accertarsi che ogni possibile percorso del flusso di esecuzione del programma conduca ad un’istruzione <span class="c003">return</span>. Per esempio:</p><pre class="verbatim">def valore_assoluto(x):
    if x &lt; 0:
        return -x
    if x &gt; 0:
        return x
</pre><p>
Questa funzione ha un difetto, in quanto se <span class="c003">x</span> è uguale a 0, nessuna delle due condizioni è vera e la funzione termina senza incontrare un’istruzione <span class="c003">return</span>. Se il flusso di esecuzione arriva alla fine della funzione, il valore di ritorno sarà <span class="c003">None</span>, che non è di certo il valore assoluto di 0.
<a id="hevea_default395"></a>
<a id="hevea_default396"></a></p><pre class="verbatim">&gt;&gt;&gt; print(valore_assoluto(0))
None
</pre><p>
A proposito: Python contiene già la funzione <span class="c003">abs</span> che calcola il valore assoluto.
<a id="hevea_default397"></a>
<a id="hevea_default398"></a></p><p>Per esercitarvi, scrivete una funzione di nome <span class="c003">compara</span> che prenda due valori, <span class="c003">x</span> e <span class="c003">y</span>, e restituisca
<span class="c003">1</span> se <span class="c003">x &gt; y</span>, <span class="c003">0</span> se <span class="c003">x == y</span>, e <span class="c003">-1</span> se <span class="c003">x &lt; y</span>.
<a id="hevea_default399"></a>
<a id="hevea_default400"></a></p>
<!--TOC section id="sec74" Sviluppo incrementale-->
<h2 class="section" id="sec74">6.2  Sviluppo incrementale</h2><!--SEC END --><p>
<a id="incremental.development"></a>
<a id="hevea_default401"></a></p><p>Scrivendo funzioni di dimensioni sempre maggiori, aumenterà anche il tempo da dedicare al debug.</p><p>Per affrontare programmi di complessità crescente, suggerisco una tecnica chiamata <span class="c009">sviluppo incrementale</span>. Lo scopo dello sviluppo incrementale è evitare lunghe sessioni di debug, aggiungendo e provando solo piccole parti di codice alla volta.
<a id="hevea_default402"></a>
<a id="hevea_default403"></a></p><p>Come esempio, supponiamo di voler trovare la distanza tra due punti, note le coordinate (<span class="c008">x</span><sub>1</sub>, <span class="c008">y</span><sub>1</sub>) e (<span class="c008">x</span><sub>2</sub>, <span class="c008">y</span><sub>2</sub>).
Per il teorema di Pitagora, la distanza è:</p><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008">distanza</span> = </td><td class="dcell"><span class="c007">√</span></td><td class="dcell"><table class="c002 cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td class="c011">(<span class="c008">x</span><sub>2</sub> − <span class="c008">x</span><sub>1</sub>)<sup>2</sup> + (<span class="c008">y</span><sub>2</sub> − <span class="c008">y</span><sub>1</sub>)<sup>2</sup></td></tr>
</table></td></tr>
</table><p>
Per prima cosa dobbiamo considerare quale interfaccia deve avere in Python la funzione <span class="c003">distanza</span>. In altre parole, quali sono i dati in ingresso (cioè i parametri), e cosa deve restituire in uscita (cioè il valore di ritorno).</p><p>Nel nostro caso, i dati di ingresso (o di <em>input</em>) sono i due punti, rappresentabili attraverso le loro coordinate (due coppie di numeri); il risultato (o <em>output</em>) è la distanza, espressa con un valore decimale.</p><p>Si può subito scrivere un primo abbozzo di funzione:</p><pre class="verbatim">def distanza(x1, y1, x2, y2):
    return 0.0
</pre><p>
Ovviamente questa prima stesura non calcola ancora la distanza, ma restituisce sempre 0. Però è già una funzione sintatticamente corretta e può essere eseguita: potete quindi provarla prima di procedere a renderla più complessa.</p><p>Proviamo allora la nuova funzione, chiamandola con dei valori di esempio:</p><pre class="verbatim">&gt;&gt;&gt; distanza(1, 2, 4, 6)
0.0
</pre><p>
Ho scelto questi valori in modo che la loro distanza orizzontale sia 3 e quella verticale 4. In tal modo, il risultato è pari a 5: l’ipotenusa di un triangolo rettangolo i cui cateti sono lunghi 3 e 4. Quando proviamo una funzione è sempre utile sapere prima il risultato.
<a id="hevea_default404"></a></p><p>A questo punto, abbiamo verificato che la funzione è sintatticamente corretta e possiamo cominciare ad aggiungere righe di codice nel corpo. Un passo successivo plausibile è quello di calcolare le differenze <span class="c008">x</span><sub>2</sub> − <span class="c008">x</span><sub>1</sub> e <span class="c008">y</span><sub>2</sub> − <span class="c008">y</span><sub>1</sub>. Nella nuova versione assegneremo queste differenze a due variabili temporanee e le visualizzeremo.</p><pre class="verbatim">def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print('dx è ', dx)
    print('dy è ', dy)
    return 0.0
</pre><p>
Se la funzione è giusta, usando gli stessi valori di prima dovrebbe mostrare <code>dx è 3</code> e <code>dy è 4</code>. Se le cose stanno così, siamo certi che la funzione si comporta in maniera corretta sia nel ricevere gli argomenti che nell’elaborazione dei primi calcoli. In caso contrario, dovremo comunque controllare solo poche righe.</p><p>Procediamo calcolando la somma dei quadrati di <span class="c003">dx</span> e <span class="c003">dy</span>:</p><pre class="verbatim">def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquadr = dx**2 + dy**2
    print('dsquadr è: ', dsquadr)
    return 0.0
</pre><p>
Di nuovo, eseguiamo il programma in questa fase e controlliamo il risultato, che nel nostro caso dovrebbe essere 25.
Infine, usiamo la funzione radice quadrata <span class="c003">math.sqrt</span> per calcolare e restituire il risultato:
<a id="hevea_default405"></a>
<a id="hevea_default406"></a></p><pre class="verbatim">def distanza(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquadr = dx**2 + dy**2
    risultato = math.sqrt(dsquadr)
    return risultato
</pre><p>
Se tutto funziona, abbiamo finito. Altrimenti, possiamo stampare per verifica il valore di <span class="c003">risultato</span> prima dell’istruzione <span class="c003">return</span>.</p><p>La versione definitiva della funzione non deve mostrare nulla quando viene eseguita; deve solo restituire un valore. Le istruzioni di stampa che avevamo inserito erano utili per il debug, ma una volta verificato che tutto funziona vanno rimosse. Pezzi di codice temporaneo come questi sono detti <span class="c009">“impalcature”</span>, perché sono di aiuto nella fase di costruzione del programma ma non fanno parte del prodotto finale. 
<a id="hevea_default407"></a></p><p>Quando si inizia a programmare, è bene aggiungere solo poche righe di codice alla volta. Poi, con l’esperienza, potrete scrivere e fare il debug di blocchi di codice sempre più corposi. In ogni caso, la tecnica di sviluppo incrementale potrà farvi risparmiare un bel po’ di tempo di debug.</p><p>Ecco i punti chiave di questa tecnica:</p><ol class="enumerate" type=1><li class="li-enumerate">Iniziare con un programma che funziona e fare ogni volta piccole aggiunte. Ad ogni passo, se dovesse esserci un errore, avrete già idea di dove potrebbe trovarsi.</li><li class="li-enumerate">Assegnare i valori intermedi a delle variabili temporanee, così da poterli visualizzare e controllare.</li><li class="li-enumerate">Una volta ottenuto un programma funzionante, rimuovere le istruzioni temporanee e consolidare le istruzioni multiple in espressioni composte, a meno che il programma non diventi troppo difficile da leggere.</li></ol><p>Come esercizio, usate lo sviluppo incrementale per scrivere una funzione
di nome <span class="c003">ipotenusa</span>, che restituisca la lunghezza dell’ipotenusa di un
triangolo rettangolo, date le lunghezze dei cateti come argomenti.
Prendete nota di ogni passo del processo di sviluppo man mano che procedete.
<a id="hevea_default408"></a></p>
<!--TOC section id="sec75" Composizione-->
<h2 class="section" id="sec75">6.3  Composizione</h2><!--SEC END --><p>
<a id="hevea_default409"></a>
<a id="hevea_default410"></a></p><p>Come avrete intuito, è possibile chiamare una funzione dall’interno di un’altra funzione. Scriveremo come esempio una funzione che prende due punti geometrici, il centro di un cerchio ed un punto sulla sua circonferenza, e calcola l’area del cerchio.</p><p>Supponiamo che le coordinate del centro del cerchio siano memorizzate nelle variabili <span class="c003">xc</span> e <span class="c003">yc</span>, e quelle del punto sulla circonferenza in <span class="c003">xp</span> e <span class="c003">yp</span>. Innanzitutto, bisogna trovare il raggio del cerchio, che è pari alla distanza tra i due punti. La funzione <span class="c003">distanza</span> che abbiamo appena scritto, ci torna utile:</p><pre class="verbatim">raggio = distanza(xc, yc, xp, yp)
</pre><p>
Il passo successivo è trovare l’area del cerchio di quel raggio; anche questa funzione l’abbiamo già scritta:</p><pre class="verbatim">risultato = area(raggio)
</pre><p>
Incapsulando il tutto in una sola funzione otteniamo:
<a id="hevea_default411"></a></p><pre class="verbatim">def area_cerchio(xc, yc, xp, yp):
    raggio = distanza(xc, yc, xp, yp)
    risultato = area(raggio)
    return risultato
</pre><p>
Le variabili temporanee <span class="c003">raggio</span> e <span class="c003">risultato</span> sono utili per lo sviluppo
e il debug ma, una volta constatato che il programma funziona, possiamo riscrivere la funzione in modo più conciso componendo le chiamate di funzione:</p><pre class="verbatim">def area_cerchio(xc, yc, xp, yp):
    return area(distanza(xc, yc, xp, yp))
</pre>
<!--TOC section id="sec76" Funzioni booleane-->
<h2 class="section" id="sec76">6.4  Funzioni booleane</h2><!--SEC END --><p>
<a id="boolean"></a></p><p>Le funzioni possono anche restituire valori booleani (vero o falso), cosa che è spesso utilizzata per includere al loro interno dei test, anche complessi. 
<a id="hevea_default412"></a>
Per esempio:</p><pre class="verbatim">def divisibile(x, y):
    if x % y == 0:
        return True
    else:
        return False
</pre><p>
È prassi assegnare come nomi alle funzioni booleane dei predicati che, con accezione interrogativa, attendono una risposta sì/no; <code>divisibile</code> restituisce <span class="c003">True</span> o <span class="c003">False</span> per rispondere alla domanda se è vero o no che <span class="c003">x</span> è divisibile per <span class="c003">y</span>.</p><p>Facciamo un esempio:</p><pre class="verbatim">&gt;&gt;&gt; divisibile(6, 4)
False
&gt;&gt;&gt; divisibile(6, 3)
True
</pre><p>
Possiamo scrivere la funzione in modo ancora più conciso, in quanto il risultato dell’operatore di confronto <span class="c003">==</span> è anch’esso un booleano, restituendolo direttamente:</p><pre class="verbatim">def divisibile(x, y):
    return x % y == 0
</pre><p>
Le funzioni booleane sono usate spesso nelle istruzioni condizionali:
<a id="hevea_default413"></a></p><pre class="verbatim">if divisibile(x, y):
    print('x è divisibile per y')
</pre><p>
Potreste anche scrivere in questo modo:</p><pre class="verbatim">if divisibile(x, y) == True:
    print('x è divisibile per y')
</pre><p>
ma il confronto supplementare è superfluo.</p><p>Scrivete ora, per esercizio, una funzione <code>compreso_tra(x, y, z)</code> che restituisca <span class="c003">True</span> se <span class="c008">x</span> ≤ <span class="c008">y</span> ≤ <span class="c008">z</span> o <span class="c003">False</span> altrimenti.</p>
<!--TOC section id="sec77" Altro sulla ricorsione-->
<h2 class="section" id="sec77">6.5  Altro sulla ricorsione</h2><!--SEC END --><p>
<a id="more.recursion"></a>
<a id="hevea_default414"></a>
<a id="hevea_default415"></a>
<a id="hevea_default416"></a>
<a id="hevea_default417"></a></p><p>Abbiamo trattato solo una piccola parte di Python, ma è interessante sapere che questo sottoinsieme costituisce un linguaggio di programmazione <em>completo</em>, vale a dire che tutto ciò che è calcolabile può essere espresso con questo linguaggio. Qualsiasi programma esistente potrebbe essere scritto usando solo le caratteristiche del linguaggio che avete appreso finora (a dire il vero, servirebbe anche qualche altro comando per controllare i dispositivi come mouse, dischi, ecc.).</p><p>La prova di questa affermazione è un compito tutt’altro che banale svolto per la prima volta da Alan Turing, uno dei pionieri dell’informatica (qualcuno puntualizzerebbe che era un matematico, ma molti dei primi informatici erano dei matematici). Per questo motivo, è detto Tesi di Turing.
Per una trattazione più completa (ed accurata) della Tesi di Turing, consiglio il libro di Michael Sipser, <em>Introduction to the Theory of Computation</em>.</p><p>Per darvi un’idea di ciò che potete fare con gli strumenti imparati finora, analizziamo alcune funzioni matematiche definite ricorsivamente. Una funzione ricorsiva è una sorta di definizione circolare, cioè la sua definizione contiene un riferimento alla cosa che si sta definendo. Una definizione circolare propriamente detta, non è certo utile:</p><dl class="description"><dt class="dt-description"><span class="c009">vorpale:</span></dt><dd class="dd-description"> aggettivo usato per descrivere qualcosa di vorpale.
<a id="hevea_default418"></a>
<a id="hevea_default419"></a></dd></dl><p>Sarebbe fastidioso trovare una definizione simile in un vocabolario.
D’altra parte, se andate a vedere la definizione della funzione fattoriale, che è indicata dal simbolo, !), trovate qualcosa del genere:</p><table class="display dcenter"><tr class="c016"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c014">&nbsp;</td><td class="c011">&nbsp;</td><td class="c012">0! = 1 </td></tr>
<tr><td class="c014">&nbsp;</td><td class="c011">&nbsp;</td><td class="c012"><span class="c008">n</span>! = <span class="c008">n</span> (<span class="c008">n</span>−1)!
</td></tr>
</table></td></tr>
</table><p>
Questa definizione afferma che il fattoriale di 0 è 1 e che il fattoriale di ogni altro valore <span class="c008">n</span>, è <span class="c008">n</span> moltiplicato per il fattoriale di <span class="c008">n</span>−1.</p><p>Pertanto, 3! è 3 moltiplicato 2!, che a sua volta è 2 moltiplicato 1!, che
a sua volta è 1 moltiplicato 0! (cioè 1). Riassumendo il tutto, 3! è uguale a 3 per 2 per 1 per 1, che fa 6.
<a id="hevea_default420"></a>
<a id="hevea_default421"></a>
<a id="hevea_default422"></a></p><p>Se potete scrivere una definizione ricorsiva di qualcosa, potete anche scrivere un programma Python per valutarla. Per prima cosa occorre individuare quali parametri deve avere la funzione. Il <span class="c003">fattoriale</span> ha evidentemente un solo parametro, un intero:</p><pre class="verbatim">def fattoriale(n):
</pre><p>
Se l’argomento è 0, dobbiamo solo restituire il valore 1:</p><pre class="verbatim">def fattoriale(n):
    if n == 0:
        return 1
</pre><p>
Altrimenti, e qui viene il bello, dobbiamo fare una chiamata ricorsiva per trovare il fattoriale di <span class="c008">n</span>−1 e poi moltiplicare questo valore per <span class="c008">n</span>:</p><pre class="verbatim">def fattoriale(n):
    if n == 0:
        return 1
    else:
        ricors = fattoriale(n-1)
        risultato = n * ricors
        return risultato
</pre><p>
Il flusso di esecuzione del programma è simile a quello di <span class="c003">contoallarovescia</span> del Paragrafo <a href="#recursion">5.8</a>. Se chiamiamo <span class="c003">fattoriale</span>
con il valore 3:</p><p>Dato che 3 è diverso da 0, seguiamo il secondo ramo e calcoliamo il fattoriale
di <span class="c003">n-1</span>...</p><blockquote class="quote">
Dato che 2 è diverso da 0, seguiamo il secondo ramo e calcoliamo il fattoriale di <span class="c003">n-1</span>...<blockquote class="quote">
Dato che 1 è diverso da 0, seguiamo il secondo ramo e calcoliamo il fattoriale di <span class="c003">n-1</span>...<blockquote class="quote">
Dato che 0 è uguale a 0, seguiamo il primo ramo e ritorniamo 1 senza fare altre chiamate ricorsive.
</blockquote><p>Il valore di ritorno (1) è moltiplicato per <span class="c008">n</span>, che è 1, e il risultato
ritorna al chiamante.
</p></blockquote><p>Il valore di ritorno (1) è moltiplicato per <span class="c008">n</span>, che è 2, e il risultato
ritorna al chiamante.
</p></blockquote><p>Il valore di ritorno (2) è moltiplicato per <span class="c008">n</span>, che è 3, e il risultato, 6, diventa il valore di ritorno della chiamata di funzione che ha fatto partire l’intera procedura.
<a id="hevea_default423"></a></p><p>La Figura <a href="#fig.stack3">6.1</a> mostra il diagramma di stack per tutta questa sequenza di chiamate di funzione:</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian007.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 6.1: Diagramma di stack .</td></tr>
</table></div>
<a id="fig.stack3"></a>
<div class="center"><hr class="c019"></div></blockquote><p>I valori di ritorno sono illustrati mentre vengono passati all’indietro verso l’alto della pila. In ciascun frame, il valore di ritorno è quello di <span class="c003">risultato</span>, che è il prodotto di <span class="c003">n</span> e <span class="c003">ricors</span>.
<a id="hevea_default424"></a>
<a id="hevea_default425"></a></p><p>Notate che nell’ultimo frame le variabili locali <span class="c003">ricors</span> e <span class="c003">risultato</span> non esistono, perché il ramo che le crea non viene eseguito.</p>
<!--TOC section id="sec78" Salto sulla fiducia-->
<h2 class="section" id="sec78">6.6  Salto sulla fiducia</h2><!--SEC END --><p>
<a id="hevea_default426"></a>
<a id="hevea_default427"></a></p><p>Seguire il flusso di esecuzione è il modo giusto di leggere i programmi, ma
può diventare rapidamente labirintico se le dimensioni del codice aumentano. Un metodo alternativo è quello che io chiamo “salto sulla fiducia”. Quando arrivate ad una chiamata di funzione, invece di seguire il flusso di esecuzione, <em>date per scontato</em> che la funzione chiamata si comporti correttamente e che restituisca il valore esatto.</p><p>Nei fatti, già praticate questo atto di fede quando utilizzate le funzioni predefinite: se chiamate <span class="c003">math.cos</span> o <span class="c003">math.exp</span>, non andate a controllare il corpo di quelle funzioni: date per scontato che funzionino a dovere perché quelli che hanno scritto le funzioni predefinite sono senz’altro dei validi programmatori.</p><p>Lo stesso ragionamento vale quando chiamate una vostra funzione: per esempio, nel Paragrafo <a href="#boolean">6.4</a> avevamo scritto la funzione <code>divisibile</code> per controllare se un numero è divisibile per un altro. Quando ci siamo convinti che la funzione è corretta,—controllando e provando il codice—possiamo poi usarla senza doverne ricontrollare ancora il corpo.
<a id="hevea_default428"></a></p><p>Idem quando avete delle chiamate ricorsive: invece di seguire il flusso di esecuzione, potete partire dal presupposto che la chiamata ricorsiva funzioni
(restituendo il risultato corretto), per poi chiedervi: “Supponendo che io trovi il fattoriale di <span class="c008">n</span>−1, posso calcolare il fattoriale di <span class="c008">n</span>?”. È chiaro che potete farlo, moltiplicando per <span class="c008">n</span>.</p><p>Certo, è strano partire dal presupposto che una funzione sia giusta quando non avete ancora finito di scriverla, ma non per nulla si chiama "salto sulla fiducia"!</p>
<!--TOC section id="sec79" Un altro esempio-->
<h2 class="section" id="sec79">6.7  Un altro esempio</h2><!--SEC END --><p>
<a id="one.more.example"></a></p><p><a id="hevea_default429"></a>
<a id="hevea_default430"></a>
Dopo il <span class="c003">fattoriale</span>, l’esempio più noto di funzione matematica definita ricorsivamente è la funzione <span class="c003">fibonacci</span>, che ha la seguente definizione: (vedere <a href="http://it.wikipedia.org/wiki/Successione_di_Fibonacci"><span class="c003">http://it.wikipedia.org/wiki/Successione_di_Fibonacci</span></a>):
</p><table class="display dcenter"><tr class="c016"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c014">&nbsp;</td><td class="c011">&nbsp;</td><td class="c012"><span class="c008">fibonacci</span>(0) = 0 </td></tr>
<tr><td class="c014">&nbsp;</td><td class="c011">&nbsp;</td><td class="c012"><span class="c008">fibonacci</span>(1) = 1 </td></tr>
<tr><td class="c014">&nbsp;</td><td class="c011">&nbsp;</td><td class="c012"><span class="c008">fibonacci</span>(<span class="c008">n</span>) = <span class="c008">fibonacci</span>(<span class="c008">n</span>−1) + <span class="c008">fibonacci</span>(<span class="c008">n</span>−2)
</td></tr>
</table></td></tr>
</table><p>
Che tradotta in Python è:</p><pre class="verbatim">def fibonacci(n):
    if n == 0:
        return 0
    elif  n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
</pre><p>
Con una funzione simile, provare a seguire il flusso di esecuzione vi farebbe venire il mal di testa anche con valori di <span class="c008">n</span> piuttosto piccoli. Ma in virtù del “salto sulla fiducia”, dando per scontato che le due chiamate ricorsive funzionino correttamente, è chiaro che la somma dei loro valori di ritorno sarà corretta.
<a id="hevea_default431"></a></p>
<!--TOC section id="sec80" Controllo dei tipi-->
<h2 class="section" id="sec80">6.8  Controllo dei tipi</h2><!--SEC END --><p>
<a id="guardian"></a></p><p>Cosa succede se chiamiamo <span class="c003">fattoriale</span> passando 1.5 come argomento?
<a id="hevea_default432"></a>
<a id="hevea_default433"></a>
<a id="hevea_default434"></a>
<a id="hevea_default435"></a></p><pre class="verbatim">&gt;&gt;&gt; fattoriale(1.5)
RuntimeError: Maximum recursion depth exceeded
</pre><p>
Parrebbe una ricorsione infinita. Come mai?
La funzione ha un caso base—quando <span class="c003">n == 0</span>. Ma se <span class="c003">n</span> non è intero,
<em>manchiamo</em> il caso base e la ricorsione non si ferma più.
<a id="hevea_default436"></a></p><p>Alla prima chiamata ricorsiva, infatti, il valore di <span class="c003">n</span> è 0.5.
Alla successiva diventa -0.5. Da lì in poi, il valore passato alla funzione diventa ogni volta più piccolo di una unità (cioè più negativo) e non potrà mai essere 0.</p><p>Abbiamo due scelte. Possiamo provare a generalizzare la funzione <span class="c003">fattoriale</span> perché elabori anche numeri a virgola mobile, oppure possiamo fare in modo che la funzione controlli preventivamente il tipo degli argomenti che riceve. La prima opzione è chiamata funzione gamma, ma è un po’ oltre gli scopi di questo libro; quindi sceglieremo la seconda.
<a id="hevea_default437"></a></p><p>Possiamo usare la funzione predefinita <span class="c003">isinstance</span> per verificare il tipo di argomento. E visto che ci siamo, ci assicureremo anche che il numero sia positivo:
<a id="hevea_default438"></a>
<a id="hevea_default439"></a></p><pre class="verbatim">def fattoriale(n):
    if not isinstance(n, int):
        print('Il fattoriale è definito solo per numeri interi.')
        return None
    elif n &lt; 0:
        print('Il fattoriale non è definito per interi negativi.')
        return None
    elif n == 0:
        return 1
    else:
        return n * fattoriale(n-1)
</pre><p>
Il primo caso base gestisce i tipi non interi; il secondo, gli interi negativi. In entrambi i casi, il programma mostra un messaggio di errore e restituisce il valore <span class="c003">None</span> per indicare che qualcosa non ha funzionato:</p><pre class="verbatim">&gt;&gt;&gt; print(fattoriale('alfredo'))
Il fattoriale è definito solo per numeri interi.
None
&gt;&gt;&gt; print(fattoriale(-2))
Il fattoriale non è definito per interi negativi.
None
</pre><p>
Se superiamo entrambi i controlli, possiamo essere
certi che <span class="c008">n</span> è un intero positivo oppure zero, e che la ricorsione avrà
termine.
<a id="hevea_default440"></a>
<a id="hevea_default441"></a>
<a id="hevea_default442"></a></p><p>Questo programma illustra uno schema chiamato <span class="c009">condizione di guardia</span>.
Le prime due condizioni fanno da “guardiani”, difendendo il codice successivo da valori che potrebbero causare errori. Le condizioni di guardia rendono possibile la convalida del codice.</p><p>Nel Paragrafo <a href="#raise">11.4</a> vedremo un’alternativa più flessibile della stampa di messaggi di errore: sollevare un’eccezione.</p>
<!--TOC section id="sec81" Debug-->
<h2 class="section" id="sec81">6.9  Debug</h2><!--SEC END --><p>
<a id="factdebug"></a></p><p>La suddivisione di un programma di grandi dimensioni in funzioni più piccole, crea dei naturali punti di controllo per il debug. Se una funzione non va, ci sono tre possibilità da prendere in esame:
<a id="hevea_default443"></a></p><ul class="itemize"><li class="li-itemize">C’è qualcosa di sbagliato negli argomenti che la funzione sta accettando: è violata una precondizione.</li><li class="li-itemize">C’è qualcosa di sbagliato nella funzione: è violata una postcondizione.</li><li class="li-itemize">C’è qualcosa di sbagliato nel valore di ritorno o nel modo in cui viene usato.</li></ul><p>Per escludere la prima possibilità, potete aggiungere un’istruzione di stampa all’inizio della funzione per visualizzare i valori dei parametri (e magari i loro tipi). O potete scrivere del codice che controlla esplicitamente le precondizioni.
<a id="hevea_default444"></a>
<a id="hevea_default445"></a></p><p>Se i parametri sembrano corretti, aggiungete un’istruzione di stampa prima di ogni istruzione <span class="c003">return</span> e visualizzate il valore di ritorno. Se possibile, controllate i risultati calcolandoveli a parte. Cercate di chiamare la funzione fornendole dei valori che permettono un agevole controllo del risultato (come nel Paragrafo <a href="#incremental.development">6.2</a>).</p><p>Se la funzione sembra a posto, controllate la chiamata per essere sicuri che il valore di ritorno venga usato correttamente (e soprattutto, venga usato!).
<a id="hevea_default446"></a></p><p>Aggiungere istruzioni di stampa all’inizio e alla fine di una funzione può aiutare a rendere più chiaro il flusso di esecuzione. Ecco una versione di <span class="c003">fattoriale</span> con delle istruzioni di stampa:</p><pre class="verbatim">def fattoriale(n):
    spazi = ' ' * (4 * n)
    print(spazi, 'fattoriale', n)
    if n == 0:
        print(spazi, 'ritorno 1')
        return 1
    else:
        ricors = fattoriale(n-1)
        risultato = n * ricors
        print(spazi, 'ritorno ', risultato)
        return risultato
</pre><p>
<span class="c003">spazi</span> è una stringa di caratteri di spaziatura che controlla l’indentazione dell’output. Ecco il risultato di <span class="c003">fattoriale(4)</span> :</p><pre class="verbatim">                 fattoriale 4
             fattoriale 3
         fattoriale 2
     fattoriale 1
 fattoriale 0
 ritorno 1
     ritorno 1
         ritorno 2
             ritorno 6
                 ritorno 24
</pre><p>
Se il flusso di esecuzione vi confonde, questo tipo di output può aiutarvi. Ci vuole un po’ di tempo per sviluppare delle “impalcature” efficaci, ma in compenso queste possono far risparmiare molto tempo di debug.</p>
<!--TOC section id="sec82" Glossario-->
<h2 class="section" id="sec82">6.10  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">variabile temporanea:</span></dt><dd class="dd-description"> Variabile a cui si assegna un risultato intermedio di un calcolo complesso.
<a id="hevea_default447"></a></dd><dt class="dt-description"><span class="c009">codice morto:</span></dt><dd class="dd-description"> Porzione di un programma che non può mai essere eseguita, spesso perché compare dopo un’istruzione <span class="c003">return</span>.
<a id="hevea_default448"></a></dd><dt class="dt-description"><span class="c009">sviluppo incrementale:</span></dt><dd class="dd-description"> Tecnica di sviluppo del programma volta ad evitare il debug, aggiungendo e provando piccole porzioni di codice alla volta.
<a id="hevea_default449"></a></dd><dt class="dt-description"><span class="c009">impalcatura:</span></dt><dd class="dd-description"> Codice temporaneo utilizzato durante lo sviluppo del programma e che non fa parte della versione finale.
<a id="hevea_default450"></a></dd><dt class="dt-description"><span class="c009">condizione di guardia:</span></dt><dd class="dd-description"> Schema di programmazione che si avvale di un’istruzione condizionale per controllare e gestire le circostanze che possono causare un errore.
<a id="hevea_default451"></a>
<a id="hevea_default452"></a></dd></dl>
<!--TOC section id="sec83" Esercizi-->
<h2 class="section" id="sec83">6.11  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Disegnate un diagramma di stack del seguente programma. Che cosa visualizza?
</em><a id="hevea_default453"></a></p><pre class="verbatim"><em>def b(z):
    prod = a(z, z)
    print(z, prod)
    return prod

def a(x, y):
    x = x + 1
    return x * y

def c(x, y, z):
    totale = x + y + z
    quadrato = b(totale)**2
    return quadrato

x = 1
y = x + 1
print(c(x, y+3, x+y))
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="ackermann"></a><p><em>La funzione di Ackermann, </em><span class="c008">A</span>(<span class="c008">m</span>, <span class="c008">n</span>)<em>, è così definita:</em></p><table class="display dcenter"><tr class="c016"><td class="dcell"><table class="c001 cellpading0"><tr><td class="c014"><table class="display"><tr class="c016"><td class="dcell"><span class="c008">A</span>(<span class="c008">m</span>, <span class="c008">n</span>) = </td><td class="dcell"><table class="display"><tr class="c016"><td class="dcell">⎧<br>
⎪<br>
⎨<br>
⎪<br>
⎩</td><td class="dcell"><table class="c001 cellpading0"><tr><td class="c012">              <span class="c008">n</span>+1</td><td class="c012">se  <span class="c008">m</span> = 0 </td></tr>
<tr><td class="c012">        <span class="c008">A</span>(<span class="c008">m</span>−1, 1)</td><td class="c012">se  <span class="c008">m</span> &gt; 0  e  <span class="c008">n</span> = 0 </td></tr>
<tr><td class="c012"><span class="c008">A</span>(<span class="c008">m</span>−1, <span class="c008">A</span>(<span class="c008">m</span>, <span class="c008">n</span>−1))</td><td class="c012">se  <span class="c008">m</span> &gt; 0  e  <span class="c008">n</span> &gt; 0.
</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p><em>
Vedere anche </em><a href="http://it.wikipedia.org/wiki/Funzione_di_Ackermann"><span class="c003"><em>http://it.wikipedia.org/wiki/Funzione_di_Ackermann</em></span></a><em>.
Scrivete una funzione di nome <span class="c003">ack</span> che valuti la funzione di Ackermann.
Usate la vostra funzione per calcolare <span class="c003">ack(3, 4)</span>, vi dovrebbe risultare 125.
Cosa succede per valori maggiori di <span class="c003">m</span> e <span class="c003">n</span>?
Soluzione: </em><a href="http://thinkpython2.com/code/ackermann.py"><span class="c003"><em>http://thinkpython2.com/code/ackermann.py</em></span></a><em>.
</em><a id="hevea_default454"></a>
<a id="hevea_default455"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="palindrome"></a><p><em>Un palindromo è una parola che si legge nello stesso modo sia da sinistra verso destra che viceversa, come “ottetto” e “radar”. In termini ricorsivi, una parola è un palindromo se la prima e l’ultima lettera sono uguali e ciò che resta in mezzo è un palindromo.
</em><a id="hevea_default456"></a></p><p><em>Quelle che seguono sono funzioni che hanno una stringa come parametro e restituiscono rispettivamente la prima lettera, l’ultima lettera, e quelle in mezzo:</em></p><pre class="verbatim"><em>def prima(parola):
    return parola[0]

def ultima(parola):
    return parola[-1]

def mezzo(parola):
    return parola[1:-1]
</em></pre><p><em>
Vedremo meglio come funzionano nel Capitolo </em><a href="#strings"><em>8</em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete queste funzioni in un file script <span class="c003">palindromo.py</span>
e provatele. Cosa succede se chiamate <span class="c003">mezzo</span> con una stringa di due lettere? E di una lettera? E con la stringa vuota, che si scrive <code>''</code> e non contiene caratteri?</em></li><li class="li-enumerate"><em>Scrivete una funzione di nome <code>palindromo</code> che riceva una stringa come argomento e restituisca <span class="c003">True</span> se è un palindromo e <span class="c003">False</span> altrimenti. Ricordate che potete usare la funzione predefinita <span class="c003">len</span> per controllare la lunghezza di una stringa.</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/palindrome_soln.py"><em><span class="c003">http://thinkpython2.com/code/palindrome_soln.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Un numero, <span class="c003">a</span>, è una potenza di <span class="c003">b</span> se è divisibile per <span class="c003">b</span>
e <span class="c003">a/b</span> è a sua volta una potenza di <span class="c003">b</span>. Scrivete una funzione di nome
<code>potenza</code> che prenda come parametri <span class="c003">a</span> e <span class="c003">b</span>
e che restituisca <span class="c003">True</span> se <span class="c003">a</span> è una potenza di <span class="c003">b</span>.
Nota: dovete pensare bene al caso base.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  
<a id="hevea_default457"></a>
<a id="hevea_default458"></a><p><em>Il massimo comun divisore (MCD) di due interi </em><span class="c008">a</span><em> e </em><span class="c008">b</span><em> è il numero intero più grande che divide entrambi senza dare resto. </em></p><p><em>Un modo per trovare il MCD di due numeri si basa sull’osservazione che, se </em><span class="c008">r</span><em> è il resto della divisione tra </em><span class="c008">a</span><em> e </em><span class="c008">b</span><em>, allora </em><span class="c008">mcd</span>(<span class="c008">a</span>,
<span class="c008">b</span>) = <span class="c008">mcd</span>(<span class="c008">b</span>, <span class="c008">r</span>)<em>. Come caso base, possiamo usare </em><span class="c008">mcd</span>(<span class="c008">a</span>, 0) = <span class="c008">a</span><em>.</em></p><p><em>Scrivete una funzione di nome
<code>mcd</code> che abbia come parametri <span class="c003">a</span> e <span class="c003">b</span>
e restituisca il loro massimo comun divisore.</em></p><p><em>Fonte: Questo esercizio è basato su un esempio in </em>Structure and Interpretation of Computer Programs<em> di Abelson e Sussman.</em></p></div>
<!--TOC chapter id="sec84" Iterazione-->
<h1 class="chapter" id="sec84">Chapter 7  Iterazione</h1><!--SEC END --><p>In questo capitolo parleremo dell’iterazione, che è la capacità di eseguire ripetutamente uno stesso blocco di istruzioni. Abbiamo visto una sorta di iterazione nel Paragrafo <a href="#recursion">5.8</a>, usando la ricorsione. Ne abbiamo visto un tipo nel Paragrafo <a href="#repetition">4.2</a>, dove abbiamo utilizzato un ciclo <span class="c003">for</span>. Qui ne vedremo un tipo ulteriore, che usa l’istruzione <span class="c003">while</span>. Ma prima, qualche altro dettaglio sull’assegnazione delle variabili.</p>
<!--TOC section id="sec85" Riassegnazione-->
<h2 class="section" id="sec85">7.1  Riassegnazione</h2><!--SEC END --><p>
<a id="hevea_default459"></a>
<a id="hevea_default460"></a>
<a id="hevea_default461"></a></p><p>Vi sarete forse già accorti che è possibile effettuare più assegnazioni ad una stessa variabile. Una nuova assegnazione fa sì che la variabile faccia riferimento ad un nuovo valore, cessando di riferirsi a quello vecchio.</p><pre class="verbatim">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; x
7
</pre><p>
La prima volta che visualizziamo <span class="c003">x</span>, il suo valore è 5; la seconda volta è 7.</p><p>La Figura <a href="#fig.assign2">7.1</a> illustra il diagramma di stato per questa <span class="c009">riassegnazione</span>. 
<a id="hevea_default462"></a></p><p>Ora, è bene chiarire un punto che è frequente motivo di confusione.
Dato che Python usa (<span class="c003">=</span>) per le assegnazioni, potreste interpretare l’istruzione <span class="c003">a = b</span> come un’espressione matematica di uguaglianza, cioè una proposizione per cui <span class="c003">a</span> e <span class="c003">b</span> sono uguali. Questo non è corretto.
<a id="hevea_default463"></a></p><p>In primo luogo, l’equivalenza è una relazione simmetrica, cioè vale in entrambi i sensi, mentre l’assegnazione non lo è: in matematica se <span class="c008">a</span>=7 allora è anche 7=<span class="c008">a</span>. Ma in Python l’istruzione <span class="c003">a = 7</span> è valida mentre <span class="c003">7 = a</span> non lo è.</p><p>Inoltre, in matematica un’uguaglianza è o vera o falsa, e rimane tale: se ora <span class="c008">a</span>=<span class="c008">b</span> allora <span class="c008">a</span> sarà sempre uguale a <span class="c008">b</span>.
In Python, un’assegnazione può rendere due variabili temporaneamente uguali, ma non è affatto detto che l’uguaglianza permanga:</p><pre class="verbatim">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = a    # a e b ora sono uguali
&gt;&gt;&gt; a = 3    # a e b non sono più uguali
&gt;&gt;&gt; b
5
</pre><p>
La terza riga modifica il valore di <span class="c003">a</span> ma non quello di <span class="c003">b</span>, quindi <span class="c003">a</span> e <span class="c003">b</span> non sono più uguali.</p><p>Anche se le riassegnazioni di variabile sono spesso utili, vanno usate con cautela. Se il valore di una variabile cambia di frequente, può rendere il codice difficile da leggere e correggere.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian008.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 7.1: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.assign2"></a>
<div class="center"><hr class="c019"></div></blockquote>
<!--TOC section id="sec86" Aggiornare le variabili-->
<h2 class="section" id="sec86">7.2  Aggiornare le variabili</h2><!--SEC END --><p>
<a id="update"></a></p><p><a id="hevea_default464"></a>
<a id="hevea_default465"></a></p><p>Una delle forme più comuni di riassegnazione è l’<span class="c009">aggiornamento</span>,
dove il nuovo valore della variabile dipende da quello precedente.</p><pre class="verbatim">&gt;&gt;&gt; x = x + 1
</pre><p>
Questo significa: “prendi il valore attuale di <span class="c003">x</span>, aggiungi uno, e aggiorna <span class="c003">x</span> al nuovo valore.”</p><p>Se tentate di aggiornare una variabile inesistente, si verifica un errore perché Python valuta il lato destro prima di assegnare un valore a <span class="c003">x</span>:</p><pre class="verbatim">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined
</pre><p>
Prima di aggiornare una variabile occorre quindi <span class="c009">inizializzarla</span>,
di solito con una comune assegnazione:
<a id="hevea_default466"></a></p><pre class="verbatim">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1
</pre><p>
L’aggiornamento di una variabile aggiungendo 1 è detto <span class="c009">incremento</span>;
sottrarre 1 è detto invece <span class="c009">decremento</span>.
<a id="hevea_default467"></a>
<a id="hevea_default468"></a></p>
<!--TOC section id="sec87" L’istruzione <span class="c003">while</span>-->
<h2 class="section" id="sec87">7.3  L’istruzione <span class="c003">while</span></h2><!--SEC END --><p>
<a id="hevea_default469"></a>
<a id="hevea_default470"></a>
<a id="hevea_default471"></a></p><p>Spesso i computer sono usati per automatizzare dei compiti ripetitivi: ripetere operazioni identiche o simili senza fare errori, è qualcosa che i computer fanno molto bene e le persone piuttosto male. Nella programmazione, la ripetizione è chiamata anche <span class="c009">iterazione</span>.</p><p>Abbiamo già visto due funzioni, <span class="c003">contoallarovescia</span> e <code>stampa_n</code>, che iterano usando la ricorsione. Dato che l’iterazione è un’operazione molto frequente, Python fornisce varie caratteristiche del linguaggio per renderla più semplice da implementare. Una è l’istruzione <span class="c003">for</span>, che abbiamo già visto nel Paragrafo <a href="#repetition">4.2</a> e sulla quale torneremo.</p><p>Un’altra istruzione è <span class="c003">while</span>. Ecco una variante di <span class="c003">contoallarovescia</span> che usa l’istruzione <span class="c003">while</span>:</p><pre class="verbatim">def contoallarovescia(n):
    while n &gt; 0:
        print(n)
        n = n-1
    print('Via!')
</pre><p>
Si può quasi leggere il programma con l’istruzione <span class="c003">while</span> come fosse scritto in inglese: significa “Finché (while) <span class="c003">n</span> è maggiore di 0, stampa il valore di <span class="c003">n</span> e poi decrementa <span class="c003">n</span> di 1. Quando arrivi a 0, stampa la stringa <span class="c003">Via!</span>”
<a id="hevea_default472"></a></p><p>In modo più formale, questo è il flusso di esecuzione di un’istruzione <span class="c003">while</span>:</p><ol class="enumerate" type=1><li class="li-enumerate">Determina se la condizione è vera (<span class="c003">True</span>) o falsa (<span class="c003">False</span>).</li><li class="li-enumerate">Se la condizione è falsa, esce dal ciclo <span class="c003">while</span> e continua l’esecuzione dalla prima istruzione successiva.</li><li class="li-enumerate">Se la condizione è vera, esegue il blocco di istruzioni nel corpo del ciclo while e vi rimane, ritornando al punto 1.</li></ol><p>Questo tipo di flusso è chiamato ciclo, (in inglese <em>loop</em>), perché il terzo punto ritorna ciclicamente da capo. 
<a id="hevea_default473"></a>
<a id="hevea_default474"></a>
<a id="hevea_default475"></a></p><p>Il corpo del ciclo deve cambiare il valore di una o più variabili in modo che la condizione prima o poi diventi falsa e il ciclo abbia termine. Altrimenti, il ciclo verrebbe ripetuto continuamente, dando luogo ad un <span class="c009">ciclo infinito</span>. Una fonte inesauribile di divertimento per gli informatici, è osservare che le istruzioni dello shampoo:
“lava, risciacqua, ripeti” sono un ciclo infinito.</p><p><a id="hevea_default476"></a></p><p>Nel caso di <span class="c003">contoallarovescia</span>, è evidente che il ciclo terminerà: se <span class="c003">n</span> è zero o negativo, il ciclo non viene mai eseguito. Altrimenti, <span class="c003">n</span> diventa via via più piccolo ad ogni ripetizione del ciclo stesso, fino a diventare, prima o poi, zero. </p><p>In altri cicli, può non essere così evidente. Per esempio:</p><pre class="verbatim">def sequenza(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n è pari
            n = n / 2
        else:               # n è dispari
            n = n*3+1
</pre><p>
La condizione di questo ciclo è <span class="c003">n != 1</span>, per cui il ciclo si ripeterà
fino a quando <span class="c003">n</span> non sarà uguale a <span class="c003">1</span>, cosa che rende falsa la condizione.</p><p>Ad ogni ripetizione del ciclo, il programma stampa il valore di <span class="c003">n</span> e poi controlla se è pari o dispari. Se è pari, <span class="c003">n</span> viene diviso per 2. Se è dispari, <span class="c003">n</span> è moltiplicato per 3 e al risultato viene aggiunto 1. Se per esempio il valore passato a <span class="c003">sequenza</span> è 3, i valori risultanti di <span class="c003">n</span> saranno nell’ordine 3, 10, 5, 16, 8, 4, 2, 1.</p><p>Dato che <span class="c003">n</span> a volte sale e a volte scende, non c’è modo di stabilire che <span class="c003">n</span> raggiungerà 1 in modo da terminare il ciclo. Solo per qualche particolare valore di <span class="c003">n</span>, possiamo dimostrarlo: ad esempio, se il valore di partenza è una potenza di 2, <span class="c003">n</span> sarà per forza un numero pari ad ogni ciclo, fino a raggiungere 1. L’esempio precedente finisce proprio con una sequenza simile, a partire dal numero 16.
<a id="hevea_default477"></a></p><p>La domanda difficile è se il programma giunga a termine per <em>qualsiasi</em> valore positivo di <span class="c003">n</span>. Sinora, nessuno è riuscito a dimostrarlo <em>né</em> a smentirlo! (Vedere <a href="http://it.wikipedia.org/wiki/Congettura_di_Collatz"><span class="c003">http://it.wikipedia.org/wiki/Congettura_di_Collatz</span></a>.)</p><p>Come esercizio, riscrivete la funzione <code>stampa_n</code> del Paragrafo <a href="#recursion">5.8</a> usando l’iterazione al posto della ricorsione.</p>
<!--TOC section id="sec88" <span class="c003">break</span>-->
<h2 class="section" id="sec88">7.4  <span class="c003">break</span></h2><!--SEC END --><p>
<a id="hevea_default478"></a>
<a id="hevea_default479"></a></p><p>Vi può capitare di poter stabilire il momento in cui è necessario terminare un ciclo solo mentre il flusso di esecuzione si trova nel bel mezzo del corpo. In questi casi potete usare l’istruzione <span class="c003">break</span> per interrompere il ciclo e saltarne fuori.</p><p>Per esempio, supponiamo che vogliate ricevere delle risposte dall’utente, fino a quando non viene digitata la parola <span class="c003">fine</span>. Potete scrivere:</p><pre class="verbatim">while True:
    riga = input('&gt; ')
    if riga == 'fine':
        break
    print(riga)

print('Finito!')
</pre><p>
La condizione del ciclo è <span class="c003">True</span>, che è sempre vera per definizione, quindi il ciclo è destinato a continuare, a meno che non incontri l’istruzione <span class="c003">break</span>.</p><p>Ad ogni ripetizione, il programma mostra come prompt il simbolo <span class="c003">&gt;</span>.
Se l’utente scrive <span class="c003">fine</span>, l’istruzione <span class="c003">break</span> interrompe il ciclo, altrimenti il programma ripete quello che l’utente ha scritto e ritorna da capo. Ecco un esempio di esecuzione:</p><pre class="verbatim">&gt; non ho finito
non ho finito
&gt; fine
Finito!
</pre><p>
Questo modo di scrivere i cicli <span class="c003">while</span> è frequente, perché vi permette di controllare la condizione ovunque all’interno del ciclo (e non solo all’inizio) e di esprimere la condizione di stop in modo affermativo (“fermati quando succede questo”) piuttosto che negativo (“continua fino a quando non succede questo”).</p>
<!--TOC section id="sec89" Radici quadrate-->
<h2 class="section" id="sec89">7.5  Radici quadrate</h2><!--SEC END --><p>
<a id="squareroot"></a>
<a id="hevea_default480"></a></p><p>I cicli si usano spesso per calcolare risultati numerici, partendo da un valore approssimativo che viene migliorato iterativamente con approssimazioni successive.
<a id="hevea_default481"></a></p><p>Per esempio, un modo di calcolare le radici quadrate è il metodo di Newton. Supponiamo di voler calcolare la radice quadrata di <span class="c008">a</span>. A partire da una qualunque stima, <span class="c008">x</span>, possiamo calcolare una stima migliore con la formula seguente:</p><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008">y</span> = </td><td class="dcell"><table class="display"><tr><td class="dcell c010"><span class="c008">x</span> + <span class="c008">a</span>/<span class="c008">x</span></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell c010">2</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Supponiamo per esempio che <span class="c008">a</span> sia 4 e <span class="c008">x</span> sia 3:</p><pre class="verbatim">&gt;&gt;&gt; a = 4
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.16666666667
</pre><p>
Il risultato è più vicino al valore vero (√<span class="c015">4</span> = 2). Se ripetiamo il procedimento usando la nuova stima, ci avviciniamo ulteriormente:</p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00641025641
</pre><p>
Dopo qualche ulteriore passaggio, la stima diventa quasi esatta:
<a id="hevea_default482"></a></p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00001024003
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00000000003
</pre><p>
In generale, non possiamo sapere <em>a priori</em> quanti passaggi ci vorranno per ottenere la risposta esatta, ma sapremo che ci saremo arrivati quando la stima non cambierà più:</p><pre class="verbatim">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
</pre><p>
Possiamo fermarci quando <span class="c003">y == x</span>. Ecco quindi un ciclo che parte da una stima iniziale, <span class="c003">x</span>, e la migliora fino a quando non cambia più:</p><pre class="verbatim">while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
</pre><p>
Per la maggior parte dei valori di <span class="c003">a</span>, questo codice funziona bene, ma in genere è pericoloso testare l’uguaglianza su valori decimali di tipo <span class="c003">float</span>,
perché sono solo approssimativamente esatti: la maggior parte dei numeri razionali come 1/3, e irrazionali, come √<span class="c015">2</span>, non possono essere rappresentati in modo preciso con un <span class="c003">float</span>.
<a id="hevea_default483"></a>
<a id="hevea_default484"></a></p><p>Piuttosto di controllare se <span class="c003">x</span> e <span class="c003">y</span> sono identici, è meglio usare la funzione predefinita <span class="c003">abs</span> per calcolare il valore assoluto della loro differenza:</p><pre class="verbatim">    if abs(y-x) &lt; epsilon:
        break
</pre><p>
Dove <code>epsilon</code> è un valore molto piccolo, come <span class="c003">0.0000001</span>, che determina quando i due numeri confrontati sono abbastanza vicini da poter essere considerati praticamente uguali.</p>
<!--TOC section id="sec90" Algoritmi-->
<h2 class="section" id="sec90">7.6  Algoritmi</h2><!--SEC END --><p>
<a id="hevea_default485"></a></p><p>Il metodo di Newton è un esempio di <span class="c009">algoritmo</span>: è un’operazione meccanica per risolvere un tipo di problema (in questo caso, calcolare la radice quadrata).</p><p>Per capire cosa sia un algoritmo, può essere utile iniziare a vedere cosa non è un algoritmo. Quando a scuola vi insegnarono a fare le moltiplicazioni dei numeri a una cifra, probabilmente avevate imparato a memoria le tabelline, che significa ricordare 100 specifiche soluzioni. Una conoscenza di questo tipo non è algoritmica.</p><p>Ma se eravate dei bambini un po’ pigri, probabilmente avevate imparato qualche trucchetto. Per esempio, per trovare il prodotto tra <span class="c008">n</span> e 9, si scrive <span class="c008">n</span>−1 come prima cifra e 10−<span class="c008">n</span> come seconda cifra. Questo trucco è una soluzione generica per moltiplicare per nove qualunque numero a una cifra. Questo è un algoritmo!
<a id="hevea_default486"></a>
<a id="hevea_default487"></a></p><p>Similmente, le tecniche che avete imparato per l’addizione con riporto, la sottrazione con prestito e le divisioni lunghe sono tutte algoritmi. Una caratteristica degli algoritmi è che non richiedono intelligenza per essere eseguiti. Sono procedimenti meccanici in cui ad ogni passo ne segue un altro, secondo delle semplici regole.</p><p>L’esecuzione di un algoritmo, in sé, è una cosa noiosa e ripetitiva. D’altra parte, la procedura di realizzazione di un algoritmo è interessante, intellettualmente stimolante, e una parte cruciale di quella che chiamiamo programmazione.</p><p>Alcune delle cose che le persone fanno in modo naturale senza difficoltà o senza nemmeno pensarci, sono le più difficili da esprimere con algoritmi. Capire il linguaggio naturale è un esempio calzante. Lo facciamo tutti, ma finora nessuno è stato in grado di spiegare <em>come</em> lo facciamo, almeno non sotto forma di un algoritmo.</p>
<!--TOC section id="sec91" Debug-->
<h2 class="section" id="sec91">7.7  Debug</h2><!--SEC END --><p>
<a id="bisectbug"></a></p><p>Quando inizierete a scrivere programmi di grandi dimensioni, impiegherete più tempo per il debug: più codice significa più probabilità di commettere un errore e più posti in cui gli errori possono annidarsi.
<a id="hevea_default488"></a></p><p>Un metodo per ridurre il tempo di debug è il “debug binario”.
Se nel vostro programma ci sono 100 righe e le controllate una ad una, ci vorranno 100 passaggi.</p><p>Provate invece a dividere il problema in due. Cercate verso la metà del programma un valore intermedio che potete controllare. Aggiungete un’istruzione di stampa (o qualcos’altro di controllabile) ed eseguite il programma.</p><p>Se il controllo nel punto mediano non è corretto, deve esserci un problema nella prima metà del programma. Se invece è corretto, l’errore sarà nella seconda metà.</p><p>Per ogni controllo eseguito in questa maniera, dimezzate le righe da controllare. Dopo 6 passaggi (che sono meno di 100), dovreste teoricamente arrivare a una o due righe di codice.</p><p>In pratica, non è sempre chiaro quale sia la “metà del programma” e non è sempre possibile controllare. Non ha neanche molto senso contare le righe e trovare la metà esatta. Meglio considerare i punti del programma dove è più probabile che vi siano errori e quelli dove è facile posizionare dei controlli. Poi, scegliere un punto dove stimate che le probabilità che l’errore sia prima o dopo quel punto siano circa le stesse.</p>
<!--TOC section id="sec92" Glossario-->
<h2 class="section" id="sec92">7.8  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">riassegnazione:</span></dt><dd class="dd-description"> Assegnazione di un nuovo valore ad una variabile che esiste già.
<a id="hevea_default489"></a></dd><dt class="dt-description"><span class="c009">aggiornamento:</span></dt><dd class="dd-description"> Riassegnazione in cui il nuovo valore della variabile dipende da quello precedente.
<a id="hevea_default490"></a></dd><dt class="dt-description"><span class="c009">inizializzazione:</span></dt><dd class="dd-description"> Assegnazione che fornisce un valore iniziale ad una variabile da aggiornare successivamente.
<a id="hevea_default491"></a></dd><dt class="dt-description"><span class="c009">incremento:</span></dt><dd class="dd-description"> Aggiornamento che aumenta il valore di una variabile (spesso di una unità).
<a id="hevea_default492"></a></dd><dt class="dt-description"><span class="c009">decremento:</span></dt><dd class="dd-description"> Aggiornamento che riduce il valore di una variabile.
<a id="hevea_default493"></a></dd><dt class="dt-description"><span class="c009">iterazione:</span></dt><dd class="dd-description"> Ripetizione di una serie di istruzioni utilizzando una funzione ricorsiva oppure un ciclo.
<a id="hevea_default494"></a></dd><dt class="dt-description"><span class="c009">ciclo infinito:</span></dt><dd class="dd-description"> Ciclo in cui la condizione che ne determina la fine non è mai soddisfatta.
<a id="hevea_default495"></a></dd><dt class="dt-description"><span class="c009">algoritmo:</span></dt><dd class="dd-description"> Una procedura generica per risolvere una categoria di problemi.
<a id="hevea_default496"></a></dd></dl>
<!--TOC section id="sec93" Esercizi-->
<h2 class="section" id="sec93">7.9  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  
<a id="hevea_default497"></a><p><em>Copiate il ciclo del Paragrafo </em><a href="#squareroot"><em>7.5</em></a><em> e incapsulatelo in una funzione
di nome <code>mia_radq</code> che prenda <span class="c003">a</span> come parametro, scelga un valore appropriato di <span class="c003">x</span>, e restituisca una stima del valore della radice quadrata di <span class="c003">a</span>. </em><a id="hevea_default498"></a></p><p><em>Quale verifica, scrivete una funzione di nome <code>test_radq</code> che stampi una tabella come questa:</em></p><pre class="verbatim"><em>a   mia_radq(a)   math.sqrt(a)  diff
-   ----------    ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
</em></pre><p><em>
La prima colonna è un numero, </em><span class="c008">a</span><em>; la seconda è la radice quadrata di </em><span class="c008">a</span><em> calcolata con <code>mia_radq</code>; la terza è la radice quadrata calcolata con <span class="c003">math.sqrt</span>; la quarta è il valore assoluto della differenza tra le due stime.
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default499"></a>
<a id="hevea_default500"></a><p><em>La funzione predefinita <span class="c003">eval</span> valuta un’espressione sotto forma di stringa, usando l’interprete Python. Ad esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; eval('1 + 2 * 3')
7
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval('math.sqrt(5)')
2.2360679774997898
&gt;&gt;&gt; eval('type(math.pi)')
&lt;class 'float'&gt;
</em></pre><p><em>
Scrivete una funzione di nome <code>eval_ciclo</code> che chieda iterativamente all’utente di inserire un dato, prenda il dato inserito e lo valuti con <span class="c003">eval</span>, infine visualizzi il risultato.</em></p><p><em>Deve continuare fino a quando l’utente non scrive <code>'fatto'</code>, e poi restituire il valore dell’ultima espressione che ha valutato.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default501"></a><p><em>Il matematico Srinivasa Ramanujan scoprì una serie infinita che può essere usata per generare un’approssimazione di </em>1 / π<em>:
</em><a id="hevea_default502"></a></p><table class="display dcenter"><tr class="c016"><td class="dcell"><table class="display"><tr><td class="dcell c010">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell c010">π</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell c010"><table class="display"><tr class="c016"><td class="dcell">2</td><td class="dcell"><span class="c007">√</span></td><td class="dcell"><table class="c002 cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td class="c011">2</td></tr>
</table></td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell c010">9801</td></tr>
</table></td><td class="dcell"> 
</td><td class="dcell"><table class="display"><tr><td class="dcell c010">∞</td></tr>
<tr><td class="dcell c010"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell c010"><span class="c008">k</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell c010">(4<span class="c008">k</span>)!(1103+26390<span class="c008">k</span>)</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell c010">(<span class="c008">k</span>!)<sup>4</sup> 396<sup>4<span class="c008">k</span></sup></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p><em>Scrivete una funzione di nome <code>stima_pi</code> che utilizzi questa formula per calcolare e restituire una stima di </em>π<em>. Deve usare un ciclo <span class="c003">while</span>
per calcolare gli elementi della sommatoria, fino a quando l’ultimo termine è più piccolo di <span class="c003">1e-15</span> (che è la notazione di Python per </em>10<sup>−15</sup><em>).
Controllate il risultato confrontandolo con <span class="c003">math.pi</span>.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/pi.py"><em><span class="c003">http://thinkpython2.com/code/pi.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec94" Stringhe-->
<h1 class="chapter" id="sec94">Chapter 8  Stringhe</h1><!--SEC END --><p>
<a id="strings"></a></p><p>Le stringhe non sono valori come gli interi, i float e i booleani. Una stringa è una <span class="c009">sequenza</span>, vale a dire un insieme ordinato di valori di altra natura. In questo capitolo vedrete come si accede ai caratteri che compongono una stringa e imparerete alcuni metodi che le stringhe espongono.
<a id="hevea_default503"></a></p>
<!--TOC section id="sec95" Una stringa è una sequenza-->
<h2 class="section" id="sec95">8.1  Una stringa è una sequenza</h2><!--SEC END --><p>
<a id="hevea_default504"></a>
<a id="hevea_default505"></a>
<a id="hevea_default506"></a></p><p>Una stringa è una sequenza di caratteri. Potete accedere ai singoli caratteri usando gli operatori parentesi quadre:</p><pre class="verbatim">&gt;&gt;&gt; frutto = 'banana'
&gt;&gt;&gt; lettera = frutto[1]
</pre><p>
La seconda istruzione seleziona il carattere numero 1 della variabile <span class="c003">frutto</span> e lo assegna alla variabile <span class="c003">lettera</span>. 
<a id="hevea_default507"></a></p><p>L’espressione all’interno delle parentesi quadre è chiamato <span class="c009">indice</span>. 
L’indice è un numero intero che indica (di qui il nome) il carattere della sequenza che desiderate estrarre.</p><p>Ma il risultato potrebbe lasciarvi perplessi:</p><pre class="verbatim">&gt;&gt;&gt; lettera
a
</pre><p>
Per la maggior parte delle persone, la prima lettera di <code>'banana'</code> è <span class="c003">b</span>, non
<span class="c003">a</span>. Ma per gli informatici, premesso che l’indice è la posizione a partire dall’inizio della stringa, la posizione della prima lettera è considerata la numero zero, non uno.</p><pre class="verbatim">&gt;&gt;&gt; lettera = frutto[0]
&gt;&gt;&gt; lettera
b
</pre><p>
Quindi <span class="c003">b</span> è la “zero-esima” lettera di <code>'banana'</code>, <span class="c003">a</span>
è la prima lettera (“1-esima”), e <span class="c003">n</span> è la seconda (“2-esima”)
lettera.
<a id="hevea_default508"></a>
<a id="hevea_default509"></a></p><p>Potete usare come indice qualsiasi espressione, compresi variabili e operatori:</p><pre class="verbatim">&gt;&gt;&gt; i = 1
&gt;&gt;&gt; frutto[i]
'a'
&gt;&gt;&gt; frutto[i+1]
'n'
</pre><p>Tuttavia, il valore risultante deve essere un intero. Altrimenti succede questo:
<a id="hevea_default510"></a>
<a id="hevea_default511"></a>
<a id="hevea_default512"></a></p><pre class="verbatim">&gt;&gt;&gt; lettera = frutto[1.5]
TypeError: string indices must be integers
</pre>
<!--TOC section id="sec96" <span class="c003">len</span>-->
<h2 class="section" id="sec96">8.2  <span class="c003">len</span></h2><!--SEC END --><p>
<a id="hevea_default513"></a>
<a id="hevea_default514"></a></p><p><span class="c003">len</span> è una funzione predefinita che restituisce il numero di caratteri contenuti in una stringa:</p><pre class="verbatim">&gt;&gt;&gt; frutto = 'banana'
&gt;&gt;&gt; len(frutto)
6
</pre><p>
Per estrarre l’ultimo carattere di una stringa, si potrebbe pensare di scrivere qualcosa del genere:
<a id="hevea_default515"></a>
<a id="hevea_default516"></a></p><pre class="verbatim">&gt;&gt;&gt; lunghezza = len(frutto)
&gt;&gt;&gt; ultimo = frutto[lunghezza]
IndexError: string index out of range
</pre><p>
La ragione dell’<span class="c003">IndexError</span> è che non c’è nessuna lettera in <span class="c003">’banana’</span> con indice 6. Siccome partiamo a contare da zero, le sei lettere sono numerate da 0 a 5. Per estrarre l’ultimo carattere, dobbiamo perciò sottrarre 1 da <span class="c003">lunghezza</span>:</p><pre class="verbatim">&gt;&gt;&gt; ultimo = frutto[lunghezza-1]
&gt;&gt;&gt; ultimo
'a'
</pre><p>
Oppure, possiamo usare utilmente gli indici negativi, che contano a ritroso dalla fine della stringa: l’espressione <span class="c003">frutto[-1]</span> ricava l’ultimo carattere della stringa, <span class="c003">frutto[-2]</span> il penultimo carattere, e così via.
<a id="hevea_default517"></a></p>
<!--TOC section id="sec97" Attraversamento con un ciclo <span class="c003">for</span>-->
<h2 class="section" id="sec97">8.3  Attraversamento con un ciclo <span class="c003">for</span></h2><!--SEC END --><p>
<a id="for"></a>
<a id="hevea_default518"></a>
<a id="hevea_default519"></a>
<a id="hevea_default520"></a>
<a id="hevea_default521"></a>
<a id="hevea_default522"></a></p><p>Parecchi tipi di calcolo comportano l’elaborazione di una stringa, un carattere per volta. Spesso iniziano dal primo carattere, selezionano un carattere per volta, eseguono una certa operazione e continuano fino alla fine della stringa. Questo tipo di elaborazione è detta <span class="c009">attraversamento</span>. Un modo per scrivere un attraversamento è quello di usare un ciclo <span class="c003">while</span>:</p><pre class="verbatim">indice = 0
while indice &lt; len(frutto):
    lettera = frutto[indice]
    print(lettera)
    indice = indice + 1
</pre><p>
Questo ciclo attraversa tutta la stringa e ne mostra le singole lettere, ciascuna su una riga separata. La condizione del ciclo è <span class="c003">indice &lt; len(frutto)</span>, per cui quando <span class="c003">indice</span> è uguale alla lunghezza della stringa, la condizione diventa falsa e il corpo del ciclo non viene più eseguito. L’ultimo carattere a cui si accede è quello di indice <span class="c003">len(frutto)-1</span>, cioè l’ultimo carattere della stringa.</p><p>Come esercizio, scrivete una funzione che riceva una stringa come argomento e ne stampi i singoli caratteri, uno per riga, partendo dall’ultimo a ritroso.</p><p>Un altro modo di scrivere un attraversamento è usare un ciclo <span class="c003">for</span>:</p><pre class="verbatim">for lettera in frutto:
    print(lettera)
</pre><p>
Ad ogni ciclo, il successivo carattere della stringa viene assegnato alla variabile <span class="c003">lettera</span>. Il ciclo continua finché non rimangono più caratteri da analizzare.
<a id="hevea_default523"></a>
<a id="hevea_default524"></a>
<a id="hevea_default525"></a></p><p>L’esempio che segue illustra come usare il concatenamento (addizione di stringhe) e un ciclo <span class="c003">for</span> per generare una serie alfabetica (cioè, disposta in ordine alfabetico). Nel libro <em>Make Way for Ducklings</em> di Robert McCloskey, ci sono degli anatroccoli che si chiamano Jack, Kack, Lack, Mack, Nack, Ouack, Pack, e Quack. Questo ciclo restituisce i nomi in ordine:</p><pre class="verbatim">prefissi = 'JKLMNOPQ'
suffisso = 'ack'

for lettera in prefissi:
    print(lettera + suffisso)
</pre><p>
Il risultato del programma è:</p><pre class="verbatim">Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</pre><p>
È evidente che non è del tutto giusto, dato che “Ouack” e “Quack” sono scritti in modo errato.</p><p>Provate a modificare il programma per correggere questo errore.</p>
<!--TOC section id="sec98" Slicing-->
<h2 class="section" id="sec98">8.4  Slicing</h2><!--SEC END --><p>
<a id="slice"></a>
<a id="hevea_default526"></a>
<a id="hevea_default527"></a>
<a id="hevea_default528"></a>
<a id="hevea_default529"></a>
<a id="hevea_default530"></a></p><p>Un segmento o porzione di stringa è chiamato <span class="c009">slice</span>. L’operazione di selezione di una porzione di stringa è simile alla selezione di un carattere, ed è detta <span class="c009">slicing</span>:</p><pre class="verbatim">&gt;&gt;&gt; s = 'Monty Python'
&gt;&gt;&gt; s[0:5]
'Monty'
&gt;&gt;&gt; s[6:12]
'Python'
</pre><p>
L’operatore <span class="c003">[n:m]</span> restituisce la porzione di stringa nell’intervallo compreso tra l’“n-esimo” carattere incluso fino all’“m-esimo” escluso. Questo comportamento è poco intuitivo, e per tenerlo a mente può essere d’aiuto immaginare gli indici puntare <em>tra</em> i caratteri, come spiegato nella Figura <a href="#fig.banana">8.1</a>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian009.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 8.1: Indici di slicing.</td></tr>
</table></div>
<a id="fig.banana"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Se non è specificato il primo indice (quello prima dei due punti :), la porzione parte dall’inizio della stringa. Se manca il secondo indice, la porzione arriva fino in fondo alla stringa:</p><pre class="verbatim">&gt;&gt;&gt; frutto = 'banana'
&gt;&gt;&gt; frutto[:3]
'ban'
&gt;&gt;&gt; frutto[3:]
'ana'
</pre><p>
Se il primo indice è maggiore o uguale al secondo, il risultato è una <span class="c009">stringa vuota</span>, rappresentata da due apici consecutivi.
<a id="hevea_default531"></a></p><pre class="verbatim">&gt;&gt;&gt; frutto = 'banana'
&gt;&gt;&gt; frutto[3:3]
''
</pre><p>
Una stringa vuota non contiene caratteri e ha lunghezza 0, ma a parte questo è a tutti gli effetti una stringa come le altre.</p><p>Proseguendo con l’esempio, data una stringa di nome <span class="c003">frutto</span>, secondo voi che cosa significa <span class="c003">frutto[:]</span>? Provate a vedere.
<a id="hevea_default532"></a>
<a id="hevea_default533"></a></p>
<!--TOC section id="sec99" Le stringhe sono immutabili-->
<h2 class="section" id="sec99">8.5  Le stringhe sono immutabili</h2><!--SEC END --><p>
<a id="hevea_default534"></a>
<a id="hevea_default535"></a>
<a id="hevea_default536"></a></p><p>Per sostituire un carattere all’interno di una stringa, potreste pensare di utilizzare l’operatore <span class="c003">[]</span> sul lato sinistro di un’assegnazione, per esempio così:
<a id="hevea_default537"></a>
<a id="hevea_default538"></a></p><pre class="verbatim">&gt;&gt;&gt; saluto = 'Ciao, mondo!'
&gt;&gt;&gt; saluto[0] = 'M'
TypeError: 'str' object does not support item assignment
</pre><p>
L’“oggetto” (<em>object</em>) in questo caso è la stringa, e l’“elemento” (<em>item</em>) è il carattere che avete tentato di assegnare. Per ora, consideriamo un oggetto come la stessa cosa di un valore, ma più avanti (Paragrafo <a href="#equivalence">10.10</a>) puntualizzeremo meglio questa definizione. 
<a id="hevea_default539"></a>
<a id="hevea_default540"></a>
<a id="hevea_default541"></a>
<a id="hevea_default542"></a>
<a id="hevea_default543"></a></p><p>La ragione dell’errore è che le stringhe sono <span class="c009">immutabili</span>, in altre parole, non è consentito cambiare una stringa esistente. La cosa migliore da fare è creare una nuova stringa, variante dell’originale:</p><pre class="verbatim">&gt;&gt;&gt; saluto = 'Ciao, mondo!'
&gt;&gt;&gt; nuovo_saluto = 'M' + saluto[1:]
&gt;&gt;&gt; nuovo_saluto
'Miao, mondo!'
</pre><p>
Questo esempio concatena una nuova prima lettera con la restante porzione di <span class="c003">saluto</span>. Non ha alcun effetto sulla stringa di origine, che resta invariata.
<a id="hevea_default544"></a></p>
<!--TOC section id="sec100" Ricerca-->
<h2 class="section" id="sec100">8.6  Ricerca</h2><!--SEC END --><p>
<a id="find"></a></p><p>Cosa fa la funzione seguente?
<a id="hevea_default545"></a>
<a id="hevea_default546"></a></p><pre class="verbatim">def trova(parola, lettera):
    indice = 0
    while indice &lt; len(parola):
        if parola[indice] == lettera:
            return indice
        indice = indice + 1
    return -1
</pre><p>
In un certo senso, <span class="c003">trova</span> è l’inverso dell’operatore <span class="c003">[]</span>.
Anziché prendere un indice ed estrarre il carattere corrispondente, prende un carattere e trova l’indice in corrispondenza del quale appare il carattere. Se non trova il carattere indicato nella parola data, la funzione restituisce <span class="c003">-1</span>.</p><p>Per la prima volta incontriamo l’istruzione <span class="c003">return</span> all’interno di un ciclo. Se <span class="c003">parola[indice] == lettera</span>, la funzione interrompe il ciclo e ritorna immediatamente, restituendo <span class="c003">indice</span>. </p><p>Se il carattere non compare nella stringa data, il programma termina il ciclo normalmente e restituisce <span class="c003">-1</span>.</p><p>Questo schema di calcolo—attraversare una sequenza e ritornare quando si trova ciò che si sta cercando—è chiamato <span class="c009">ricerca</span>.
<a id="hevea_default547"></a>
<a id="hevea_default548"></a>
<a id="hevea_default549"></a></p><p>Come esercizio, modificate la funzione <span class="c003">trova</span> in modo che richieda un terzo parametro, che rappresenta la posizione da cui si deve cominciare la ricerca all’interno della stringa <span class="c003">parola</span>.</p>
<!--TOC section id="sec101" Cicli e contatori-->
<h2 class="section" id="sec101">8.7  Cicli e contatori</h2><!--SEC END --><p>
<a id="counter"></a>
<a id="hevea_default550"></a>
<a id="hevea_default551"></a>
<a id="hevea_default552"></a>
<a id="hevea_default553"></a></p><p>Il programma seguente conta il numero di volte in cui la lettera <span class="c003">a</span>
compare in una stringa:</p><pre class="verbatim">parola = 'banana'
conta = 0
for lettera in parola:
    if lettera == 'a':
        conta = conta + 1
print(conta)
</pre><p>
Si tratta di un altro schema di calcolo chiamato <span class="c009">contatore</span>. La variabile <span class="c003">conta</span> è inizializzata a 0, quindi incrementata di uno per ogni volta che viene trovata una <span class="c003">a</span>.
Al termine del ciclo, <span class="c003">conta</span> contiene il risultato: il numero totale di lettere <span class="c003">a</span> nella stringa.</p><p>Come esercizio, incapsulate questo codice in una funzione di nome <span class="c003">conta</span>, e generalizzatela in modo che accetti come argomenti sia la stringa che la lettera da cercare.
Quindi, riscrivete questa funzione in modo che, invece di attraversare completamente la stringa, faccia uso della versione a tre parametri di <span class="c003">trova</span>, vista nel precedente paragrafo.
<a id="hevea_default554"></a></p>
<!--TOC section id="sec102" Metodi delle stringhe-->
<h2 class="section" id="sec102">8.8  Metodi delle stringhe</h2><!--SEC END --><p>
<a id="optional"></a></p><p>Le stringhe espongono dei metodi che permettono di effettuare molte utili operazioni. Un <span class="c009">metodo</span> è simile a una funzione—riceve argomenti e restituisce un valore—ma la sintassi è diversa. Prendiamo ad esempio il metodo <span class="c003">upper</span>, che prende una stringa e crea una nuova stringa di tutte lettere maiuscole.
<a id="hevea_default555"></a>
<a id="hevea_default556"></a></p><p>Al posto della sintassi delle funzioni, <span class="c003">upper(parola)</span>, si usa la sintassi dei metodi, <span class="c003">parola.upper()</span>.</p><pre class="verbatim">&gt;&gt;&gt; parola = 'banana'
&gt;&gt;&gt; nuova_parola = parola.upper()
&gt;&gt;&gt; nuova_parola
BANANA
</pre><p>
Questa forma di notazione a punto, in inglese <em>dot notation</em>, specifica il nome del metodo, <span class="c003">upper</span>, preceduto dal nome della stringa a cui va applicato il metodo, <span class="c003">parola</span>. Le parentesi vuote indicano che il metodo non ha argomenti.
<a id="hevea_default557"></a>
<a id="hevea_default558"></a></p><p>La chiamata di un metodo è detta <span class="c009">invocazione</span>; nel nostro caso, diciamo che stiamo invocando <span class="c003">upper</span> su <span class="c003">parola</span>.
<a id="hevea_default559"></a></p><p>Visto che ci siamo, esiste un metodo delle stringhe chiamato <span class="c003">find</span> che è molto simile alla funzione che abbiamo scritto prima:</p><pre class="verbatim">&gt;&gt;&gt; parola = 'banana'
&gt;&gt;&gt; indice = parola.find('a')
&gt;&gt;&gt; indice
1
</pre><p>
In questo esempio, abbiamo invocato <span class="c003">find</span> su <span class="c003">parola</span> e abbiamo passato come parametro la lettera che stiamo cercando.</p><p>In realtà, il metodo <span class="c003">find</span> è più generale della nostra funzione: può ricercare anche sottostringhe e non solo singoli caratteri:</p><pre class="verbatim">&gt;&gt;&gt; parola.find('na')
2
</pre><p>
Di default, <span class="c003">find</span> parte dall’inizio della stringa, ma può ricevere come secondo argomento l’indice da cui partire:
<a id="hevea_default560"></a></p><pre class="verbatim">&gt;&gt;&gt; parola.find('na', 3)
4
</pre><p>
Questo è un esempio di <span class="c009">argomento opzionale</span>; <span class="c003">find</span> può anche avere un terzo argomento opzionale, l’indice in corrispondenza del quale fermarsi:</p><pre class="verbatim">&gt;&gt;&gt; nome = 'bob'
&gt;&gt;&gt; nome.find('b', 1, 2)
-1
</pre><p>
In quest’ultimo caso la ricerca fallisce, perché <span class="c003">b</span> non è compreso nell’intervallo da <span class="c003">1</span> a <span class="c003">2</span>, in quanto <span class="c003">2</span> si considera escluso. Questo comportamento rende <span class="c003">find</span> coerente con l’operatore di slicing.</p>
<!--TOC section id="sec103" L’operatore <span class="c003">in</span>-->
<h2 class="section" id="sec103">8.9  L’operatore <span class="c003">in</span></h2><!--SEC END --><p>
<a id="inboth"></a>
<a id="hevea_default561"></a>
<a id="hevea_default562"></a>
<a id="hevea_default563"></a>
<a id="hevea_default564"></a></p><p>La parola <span class="c003">in</span> è un operatore booleano che confronta due stringhe e restituisce <span class="c003">True</span> se la prima è una sottostringa della seconda:</p><pre class="verbatim">&gt;&gt;&gt; 'a' in 'banana'
True
&gt;&gt;&gt; 'seme' in 'banana'
False
</pre><p>
Ad esempio, la funzione che segue stampa tutte le lettere di <span class="c003">parola1</span> che compaiono anche in <span class="c003">parola2</span>:</p><pre class="verbatim">def in_entrambe(parola1, parola2):
    for lettera in parola1:
        if lettera in parola2:
            print(lettera)
</pre><p>
Con qualche nome di variabile scelto bene, Python a volte si legge quasi come fosse un misto di inglese e italiano: “per (ogni) lettera in parola1, se (la) lettera (è) in parola2, stampa (la) lettera.”</p><p>Ecco cosa succede se paragonate carote e patate:</p><pre class="verbatim">&gt;&gt;&gt; in_entrambe('carote', 'patate')
a
t
e
</pre>
<!--TOC section id="sec104" Confronto di stringhe-->
<h2 class="section" id="sec104">8.10  Confronto di stringhe</h2><!--SEC END --><p>
<a id="hevea_default565"></a>
<a id="hevea_default566"></a></p><p>Gli operatori di confronto funzionano anche sulle stringhe. Per controllare se
due stringhe sono uguali:</p><pre class="verbatim">if parola == 'banana':
    print('Tutto ok, banane.')
</pre><p>
Altri operatori di confronto sono utili per mettere le parole in ordine alfabetico:</p><pre class="verbatim">if parola &lt; 'banana':
    print('La tua parola,' + parola + ', viene prima di banana.')
elif parola &gt; 'banana':
    print('La tua parola,' + parola + ', viene dopo banana.')
else:
    print('Tutto ok, banane.')
</pre><p>
Attenzione che Python non gestisce le lettere maiuscole e minuscole come siamo abituati: in un confronto, le lettere maiuscole vengono sempre prima di tutte le minuscole, così che:</p><pre class="verbatim">La tua parola, Papaya, viene prima di banana.
</pre><p>
Questo problema si risolve facilmente convertendo le stringhe in un formato standard, ad esempio tutte lettere minuscole, prima di effettuare il confronto.</p>
<!--TOC section id="sec105" Debug-->
<h2 class="section" id="sec105">8.11  Debug</h2><!--SEC END --><p>
<a id="hevea_default567"></a>
<a id="hevea_default568"></a></p><p>Quando usate gli indici per l’attraversamento dei valori di una sequenza, non è facile determinare bene l’inizio e la fine. Ecco una funzione che dovrebbe confrontare due parole e restituire <span class="c003">True</span> quando una parola è scritta al contrario dell’altra, ma contiene due errori:</p><pre class="verbatim">def al_contrario(parola1, parola2):
    if len(parola1) != len(parola2):
        return False
    
    i = 0
    j = len(parola2)

    while j &gt; 0:
        if parola1[i] != parola2[j]:
            return False
        i = i+1
        j = j-1

    return True
</pre><p>
La prima istruzione <span class="c003">if</span> controlla se le parole sono della stessa lunghezza. Se non è così, possiamo restituire immediatamente <span class="c003">False</span>. Altrimenti, per il resto della funzione, possiamo presupporre che le parole abbiano pari lunghezza. È un altro esempio di condizione di guardia, vista nel Paragrafo <a href="#guardian">6.8</a>.
<a id="hevea_default569"></a>
<a id="hevea_default570"></a>
<a id="hevea_default571"></a></p><p><span class="c003">i</span> e <span class="c003">j</span> sono indici: <span class="c003">i</span> attraversa <span class="c003">parola1</span>
in avanti, mentre <span class="c003">j</span> attraversa <span class="c003">parola2</span> a ritroso. Se troviamo due lettere che non coincidono, possiamo restituire subito <span class="c003">False</span> Se continuiamo per tutto il ciclo e tutte le lettere coincidono, il valore di ritorno è <span class="c003">True</span>.</p><p>Se proviamo la funzione con i valori “pots” e “stop”, ci aspetteremmo di ricevere di ritorno <span class="c003">True</span>, invece risulta un IndexError:
<a id="hevea_default572"></a>
<a id="hevea_default573"></a></p><pre class="verbatim">&gt;&gt;&gt; al_contrario('pots', 'stop')
...
  File "reverse.py", line 15, in al_contrario
    if parola1[i] != parola2[j]:
IndexError: string index out of range
</pre><p>
Per fare il debug, la mia prima mossa è di stampare il valore degli indici appena prima della riga dove è comparso l’errore.</p><pre class="verbatim">    while j &gt; 0:
        print(i, j)       # stampare qui
        
        if parola1[i] != parola2[j]:
            return False
        i = i+1
        j = j-1
</pre><p>
Ora, eseguendo di nuovo il programma, ho qualche informazione in più:</p><pre class="verbatim">&gt;&gt;&gt; al_contrario('pots', 'stop')
0 4
...
IndexError: string index out of range
</pre><p>
Alla prima esecuzione del ciclo, il valore di <span class="c003">j</span> è 4,
che è fuori intervallo della stringa <code>'pots'</code>.
Infatti l’indice dell’ultimo carattere è 3, e il valore iniziale di <span class="c003">j</span> va corretto in <span class="c003">len(parola2)-1</span>.</p><p>Se correggo l’errore e rieseguo ancora il programma:</p><pre class="verbatim">&gt;&gt;&gt; al_contrario('pots', 'stop')
0 3
1 2
2 1
True
</pre><p>
Stavolta il risultato è giusto, ma pare che il ciclo sia stato eseguito solo per tre volte, il che è sospetto. Per avere un’idea di cosa stia succedendo, è utile disegnare un diagramma di stato. Durante la prima iterazione, il frame di <code>al_contrario</code> è illustrato in Figura <a href="#fig.state4">8.2</a>.
<a id="hevea_default574"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian010.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 8.2: Diagramma di Stato.</td></tr>
</table></div>
<a id="fig.state4"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Mi sono preso la libertà di disporre le variabili nel frame e di aggiungere delle linee tratteggiate per evidenziare che i valori di <span class="c003">i</span> e
<span class="c003">j</span> indicano i caratteri in <span class="c003">parola1</span> e <span class="c003">parola2</span>.</p><p>Partendo da questo diagramma, sviluppate il programma su carta cambiando i valori di <span class="c003">i</span> e <span class="c003">j</span> ad ogni iterazione. Trovate e correggete il secondo errore in questa funzione.
<a id="isreverse"></a></p>
<!--TOC section id="sec106" Glossario-->
<h2 class="section" id="sec106">8.12  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">oggetto:</span></dt><dd class="dd-description"> Qualcosa a cui una variabile può fare riferimento. Per ora, potete utilizzare “oggetto” e “valore” indifferentemente.
<a id="hevea_default575"></a></dd><dt class="dt-description"><span class="c009">sequenza:</span></dt><dd class="dd-description"> Una raccolta ordinata di valori, in cui ciascun valore è identificato da un numero intero.
<a id="hevea_default576"></a></dd><dt class="dt-description"><span class="c009">elemento:</span></dt><dd class="dd-description"> Uno dei valori di una sequenza.
<a id="hevea_default577"></a></dd><dt class="dt-description"><span class="c009">indice:</span></dt><dd class="dd-description"> Un valore intero usato per selezionare un elemento di una sequenza, come un carattere in una stringa. In Python gli indici partono da 0.
<a id="hevea_default578"></a></dd><dt class="dt-description"><span class="c009">slice:</span></dt><dd class="dd-description"> Porzione di una stringa identificata tramite un intervallo di indici.
<a id="hevea_default579"></a></dd><dt class="dt-description"><span class="c009">stringa vuota:</span></dt><dd class="dd-description"> Una stringa priva di caratteri e di lunghezza 0, rappresentata da due apici o virgolette successivi.
<a id="hevea_default580"></a></dd><dt class="dt-description"><span class="c009">immutabile:</span></dt><dd class="dd-description"> Detto di una sequenza i cui elementi non possono essere cambiati.
<a id="hevea_default581"></a></dd><dt class="dt-description"><span class="c009">attraversare:</span></dt><dd class="dd-description"> Iterare attraverso gli elementi di una sequenza, effettuando su ciascuno un’operazione simile.
<a id="hevea_default582"></a></dd><dt class="dt-description"><span class="c009">ricerca:</span></dt><dd class="dd-description"> Schema di attraversamento che si ferma quando trova ciò che si sta cercando.
<a id="hevea_default583"></a>
<a id="hevea_default584"></a></dd><dt class="dt-description"><span class="c009">contatore:</span></dt><dd class="dd-description"> Variabile utilizzata per contare qualcosa, solitamente inizializzata a zero e poi incrementata.
<a id="hevea_default585"></a></dd><dt class="dt-description"><span class="c009">invocazione:</span></dt><dd class="dd-description"> Istruzione che chiama un metodo.
<a id="hevea_default586"></a></dd><dt class="dt-description"><span class="c009">argomento opzionale:</span></dt><dd class="dd-description"> Un argomento di una funzione o di un metodo che non è obbligatorio.
<a id="hevea_default587"></a>
<a id="hevea_default588"></a></dd></dl>
<!--TOC section id="sec107" Esercizi-->
<h2 class="section" id="sec107">8.13  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  
<a id="hevea_default589"></a>
<a id="hevea_default590"></a><p><em>Leggete la documentazione dei metodi delle stringhe sul sito
</em><a href="http://docs.python.org/3/library/stdtypes.html#string-methods"><span class="c003"><em>http://docs.python.org/3/library/stdtypes.html#string-methods</em></span></a><em>.
Fate degli esperimenti con alcuni metodi per assicurarvi di avere capito come funzionano. <span class="c003">strip</span> e <span class="c003">replace</span> sono particolarmente utili.</em></p><p><em>La documentazione utilizza una sintassi che può risultare poco chiara. Per esempio, in <code>find(sub[, start[, end]])</code>, le parentesi quadre indicano dei parametri opzionali (non vanno digitate). Quindi <span class="c003">sub</span> è obbligatorio, ma
<span class="c003">start</span> è opzionale, e se indicate <span class="c003">start</span>, allora <span class="c003">end</span> è a sua volta opzionale.
</em><a id="hevea_default591"></a>
<a id="hevea_default592"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default593"></a>
<a id="hevea_default594"></a><p><em>Esiste un metodo delle stringhe di nome <span class="c003">count</span> che è simile alla funzione del Paragrafo </em><a href="#counter"><em>8.7</em></a><em>. Leggete la documentazione del metodo e scrivete un’invocazione che conti il numero di <span class="c003">a</span> in <code>'banana'</code>.
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default595"></a>
<a id="hevea_default596"></a>
<a id="hevea_default597"></a><p><em>Nello slicing, si può specificare un terzo indice che stabilisce lo </em>step<em> o “passo”, cioè il numero di elementi da saltare tra un carattere estratto e il successivo. Uno step di 2 significa estrarre un carattere ogni 2 (uno sì, uno no), 3 significa uno ogni 3 (uno sì, due no), ecc.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; frutto = 'banana'
&gt;&gt;&gt; frutto[0:5:2]
'bnn'
</em></pre><p><em>Uno step di -1 fa scorrere all’indietro nella parola, per cui lo slicing <code>[::-1]</code> genera una stringa scritta al contrario.
</em><a id="hevea_default598"></a></p><p><em>Usate questo costrutto per scrivere una variante di una sola riga della funzione <code>palindromo</code> dell’Esercizio </em><a href="#palindrome"><em>3</em></a><em>.
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Tutte le funzioni che seguono </em>dovrebbero<em> controllare se una stringa contiene almeno una lettera minuscola, ma qualcuna di esse è sbagliata. Per ogni funzione, descrivete cosa fa in realtà (supponendo che il parametro sia una stringa).</em></p><pre class="verbatim"><em>def una_minuscola1(s):
    for c in s:
        if c.islower():
            return True
        else:
            return False

def una_minuscola2(s):
    for c in s:
        if 'c'.islower():
            return 'True'
        else:
            return 'False'

def una_minuscola3(s):
    for c in s:
        flag = c.islower()
    return flag

def una_minuscola4(s):
    flag = False
    for c in s:
        flag = flag or c.islower()
    return flag

def una_minuscola5(s):
    for c in s:
        if not c.islower():
            return False
    return True
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  
<a id="hevea_default599"></a><p><a id="exrotate"></a><em>
Un cifrario di Cesare è un metodo di criptazione debole che consiste nel “ruotare” ogni lettera di una parola di un dato numero di posti seguendo la sequenza alfabetica, ricominciando da capo quando necessario. Ad esempio ’A’ ruotata di 3 posti diventa ’D’, ’Z’ ruotata di 1 posto diventa ’A’.</em></p><p><em>Per ruotare una parola, si ruota ciascuna delle sue lettere dello stesso numero di posti prefissato.
Per esempio, “cheer” ruotata di 7 dà “jolly” e “melon” ruotata di -10
dà “cubed”. Nel film </em>2001: Odissea nello Spazio<em>, il computer di bordo si chiama HAL, che non è altro che IBM ruotato di -1.</em></p><p><em>Scrivete una funzione di nome <code>ruota_parola</code> che richieda una stringa e un intero come parametri, e che restituisca una nuova stringa che contiene le lettere della stringa di partenza ruotate della quantità indicata.</em></p><p><em>Potete usare le funzioni predefinite <span class="c003">ord</span>, che converte un carattere in un codice numerico, e <span class="c003">chr</span>, che converte i codici numerici in caratteri.
Le lettere sono codificate con il loro numero di ordine alfabetico, per esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; ord('c') - ord('a')
2
</em></pre><p><em>Dato che <code>'c'</code> è la “2-esima” lettera dell’alfabeto. Ma attenzione: i codici numerici delle lettere maiuscole sono diversi.</em></p><p><em>Su Internet, talvolta, vengono codificate in ROT13 (un cifrario di Cesare con rotazione 13) delle barzellette potenzialmente offensive. Se non siete suscettibili, cercatene qualcuna e decodificatela. Soluzione: </em><a href="http://thinkpython2.com/code/rotate.py"><em><span class="c003">http://thinkpython2.com/code/rotate.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec108" Esercitazione: Giochi con le parole-->
<h1 class="chapter" id="sec108">Chapter 9  Esercitazione: Giochi con le parole</h1><!--SEC END --><p>
<a id="wordplay"></a></p><p>Questo capitolo contiene la seconda esercitazione, in cui dovrete risolvere dei quesiti che consistono nel ricercare parole che hanno delle particolari proprietà. Ad esempio, cercherete i più lunghi palindromi della lingua inglese e le parole le cui lettere sono disposte in ordine alfabetico. Illustrerò anche un’altra tecnica di sviluppo: la riduzione ad un problema già risolto.</p>
<!--TOC section id="sec109" Leggere elenchi di parole-->
<h2 class="section" id="sec109">9.1  Leggere elenchi di parole</h2><!--SEC END --><p>
<a id="wordlist"></a></p><p>Per gli esercizi di questo capitolo ci serve un elenco di parole in inglese. Ci sono parecchi elenchi di parole disponibili sul Web, ma uno dei più adatti ai nostri scopi è quello raccolto da Grady Ward, di pubblico dominio, parte del progetto lessicale Moby (vedere <a href="http://wikipedia.org/wiki/Moby_Project"><span class="c003">http://wikipedia.org/wiki/Moby_Project</span></a>). È un elenco di 113.809 parole ufficiali per cruciverba, cioè parole che sono considerate valide in un gioco di parole crociate o altri giochi con le parole. Nella raccolta Moby il nome del file è <span class="c003">113809of.fic</span>; potete anche scaricare una copia chiamata più semplicemente <span class="c003">words.txt</span>, dal sito
<a href="http://thinkpython2.com/code/words.txt"><span class="c003">http://thinkpython2.com/code/words.txt</span></a>.
<a id="hevea_default600"></a>
<a id="hevea_default601"></a></p><p>Il file è in testo semplice, e potete aprirlo con qualsiasi editor di testo, ma anche leggerlo con Python: la funzione predefinita <span class="c003">open</span> richiede come parametro il nome di un file e restituisce un <span class="c009">oggetto file</span> che potete utilizzare per questo scopo.
<a id="hevea_default602"></a>
<a id="hevea_default603"></a>
<a id="hevea_default604"></a>
<a id="hevea_default605"></a></p><pre class="verbatim">&gt;&gt;&gt; fin = open('words.txt')
</pre><p>
<span class="c003">fin</span> è un nome comunemente usato per un oggetto file usato per operazioni di input.</p><p>L’oggetto file comprende alcuni metodi di lettura, come <span class="c003">readline</span>, che legge i caratteri da un file finché non giunge ad un ritorno a capo, e restituisce il risultato sotto forma di stringa:
<a id="hevea_default606"></a>
<a id="hevea_default607"></a></p><pre class="verbatim">&gt;&gt;&gt; fin.readline()
'aa\n'
</pre><p>
La prima parola di questa speciale lista è “aa”, che è un tipo di lava vulcanica. La sequenza <code>\n</code> rappresenta il carattere di ritorno a capo che separa questa parola dalla successiva.</p><p>L’oggetto file tiene traccia del punto in cui si trova all’interno del file, così quando chiamate nuovamente <span class="c003">readline</span>, ottenete la parola successiva:</p><pre class="verbatim">&gt;&gt;&gt; fin.readline()
'aah\n'
</pre><p>
La parola successiva è “aah”, che è perfettamente valida per cui non fate quella faccia! Oppure, se il carattere di ritorno a capo vi dà fastidio, potete sbarazzarvene con il metodo delle stringhe <span class="c003">strip</span>:
<a id="hevea_default608"></a>
<a id="hevea_default609"></a></p><pre class="verbatim">&gt;&gt;&gt; riga = fin.readline()
&gt;&gt;&gt; parola = riga.strip()
&gt;&gt;&gt; parola
'aahed'
</pre><p>
Potete anche usare un oggetto file all’interno di un ciclo <span class="c003">for</span>.
Questo programma legge <span class="c003">words.txt</span> e stampa ogni parola, una per riga:
<a id="hevea_default610"></a>
<a id="hevea_default611"></a></p><pre class="verbatim">fin = open('words.txt')
for riga in fin:
    parola = riga.strip()
    print(parola)
</pre>
<!--TOC section id="sec110" Esercizi-->
<h2 class="section" id="sec110">9.2  Esercizi</h2><!--SEC END --><p>Le soluzioni a questi esercizi sono discusse nel prossimo paragrafo. Tentate almeno di risolverli prima di continuare la lettura.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete un programma che legga il file <span class="c003">words.txt</span> e stampi solo le parole composte da più di 20 caratteri (caratteri spaziatori esclusi).
</em><a id="hevea_default612"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Nel 1939, Ernest Vincent Wright pubblicò una novella di 50.000 parole dal titolo
</em>Gadsby<em> che non conteneva alcuna lettera “e”. Dato che la “e” è la lettera più comune nella lingua inglese, non è una cosa facile.</em></p><p><em>Infatti, in italiano non ho mai composto un piccolo brano siffatto: sono pochi i vocaboli privi tali da riuscirci; finora non ho trovato alcun modo, ma conto di arrivarci in alcuni giorni, pur con un po’ di difficoltà! Ma ora, basta così.</em></p><p><em>Scrivete una funzione di nome <code>niente_e</code> che restituisca <span class="c003">True</span> se una data parola non contiene la lettera “e”.</em></p><p><em>Modificate il programma del paragrafo precedente in modo che stampi solo le parole dell’elenco prive della lettera “e”, e ne calcoli la percentuale sul totale delle parole.
</em><a id="hevea_default613"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>   <p><em>Scrivete una funzione di nome <span class="c003">evita</span> che richieda una parola e una stringa di lettere vietate, e restituisca <span class="c003">True</span> se la parola non contiene alcuna lettera vietata.</em></p><p><em>Modificate poi il programma in modo che chieda all’utente di inserire una stringa di lettere vietate, e poi stampi il numero di parole che non ne contengono alcuna. Riuscite a trovare una combinazione di 5 lettere vietate che escluda il più piccolo numero di parole?</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Scrivete una funzione di nome <code>usa_solo</code> che richieda una parola e una stringa di lettere, e che restituisca <span class="c003">True</span> se la parola contiene solo le lettere indicate. Riuscite a comporre una frase in inglese usando solo le lettere
<span class="c003">acefhlo</span>? Diversa da “Hoe alfalfa”?</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>   <p><em>Scrivete una funzione di nome <code>usa_tutte</code> che richieda una parola e una stringa di lettere richieste e che restituisca <span class="c003">True</span> se la parola utilizza tutte le lettere richieste almeno una volta. Quante parole ci sono che usano tutte le vocali <span class="c003">aeiou</span>? E <span class="c003">aeiouy</span>?</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  <p><em>Scrivete una funzione di nome <code>alfabetica</code> che restituisca 
<span class="c003">True</span> se le lettere di una parola compaiono in ordine alfabetico (le doppie valgono). Quante parole “alfabetiche” ci sono?
</em><a id="hevea_default614"></a></p></div>
<!--TOC section id="sec111" Ricerca-->
<h2 class="section" id="sec111">9.3  Ricerca</h2><!--SEC END --><p>
<a id="search"></a>
<a id="hevea_default615"></a>
<a id="hevea_default616"></a></p><p>Tutti gli esercizi del paragrafo precedente hanno qualcosa in comune: possono essere risolti con lo schema di ricerca che abbiamo visto nel Paragrafo <a href="#find">8.6</a>. L’esempio più semplice è:</p><pre class="verbatim">def niente_e(parola):
    for lettera in parola:
        if lettera == 'e':
            return False
    return True
</pre><p>
Il ciclo <span class="c003">for</span> attraversa i caratteri in <span class="c003">parola</span>. Se trova la lettera “e”, può immediatamente restituire <span class="c003">False</span>; altrimenti deve esaminare la lettera seguente. Se il ciclo termina normalmente, vuol dire che non è stata trovata alcuna “e”, per cui il risultato è <span class="c003">True</span>.
<a id="hevea_default617"></a>
<a id="hevea_default618"></a>
<a id="hevea_default619"></a></p><p>Si potrebbe scrivere questa funzione in modo più conciso usando l’operatore <span class="c003">in</span>, ma ho preferito iniziare con questa versione perché dimostra la logica dello schema di ricerca.
<a id="hevea_default620"></a></p><p><span class="c003">evita</span> è una versione più generale di <code>niente_e</code>, ma la struttura è la stessa:</p><pre class="verbatim">def evita(parola, vietate):
    for lettera in parola:
        if lettera in vietate:
            return False
    return True
</pre><p>
Possiamo restituire <span class="c003">False</span> appena troviamo una delle lettere vietate; se arriviamo alla fine del ciclo, viene restituito <span class="c003">True</span>.</p><p><code>usa_solo</code> è simile, solo che il senso della condizione è invertito:</p><pre class="verbatim">def usa_solo(parola, valide):
    for lettera in parola: 
        if lettera not in valide:
            return False
    return True
</pre><p>
Invece di un elenco di lettere vietate, ne abbiamo uno di lettere disponibili. Se in <span class="c003">parola</span> troviamo una lettera che non è una di quelle <span class="c003">valide</span>, possiamo restituire <span class="c003">False</span>.</p><p><code>usa_tutte</code> è ancora simile, solo che rovesciamo il ruolo della parola e della stringa di lettere:</p><pre class="verbatim">def usa_tutte(parola, richieste):
    for lettera in richieste: 
        if lettera not in parola:
            return False
    return True
</pre><p>
Invece di attraversare le lettere in <span class="c003">parola</span>, il ciclo attraversa le lettere richieste. Se una qualsiasi delle lettere richieste non compare nella parola, restituiamo <span class="c003">False</span>.
<a id="hevea_default621"></a></p><p>Ma se avete pensato davvero da informatici, avrete riconosciuto che <code>usa_tutte</code> era un’istanza di un problema già risolto in precedenza, e avrete scritto:</p><pre class="verbatim">def usa_tutte(parola, richieste):
    return usa_solo(richieste, parola)
</pre><p>
Ecco un esempio di metodo di sviluppo di un programma chiamato <span class="c009">riduzione ad un problema già risolto</span>, che significa che avete riconosciuto che il problema su cui state lavorando è un’istanza di un problema già risolto in precedenza, al quale potete applicare una soluzione che avevate già sviluppato.
<a id="hevea_default622"></a>
<a id="hevea_default623"></a></p>
<!--TOC section id="sec112" Cicli con gli indici-->
<h2 class="section" id="sec112">9.4  Cicli con gli indici</h2><!--SEC END --><p>
<a id="hevea_default624"></a>
<a id="hevea_default625"></a></p><p>Ho scritto le funzioni del paragrafo precedente utilizzando dei cicli <span class="c003">for</span>
perché avevo bisogno solo dei caratteri nelle stringhe e non dovevo fare nulla con gli indici.</p><p>Per <code>alfabetica</code> dobbiamo comparare delle lettere adiacenti, che è un po’ laborioso con un ciclo <span class="c003">for</span>:</p><pre class="verbatim">def alfabetica(parola):
    precedente = parola[0]
    for c in parola:
        if c &lt; precedente:
            return False
        precedente = c
    return True
</pre><p>Un’alternativa è usare la ricorsione:</p><pre class="verbatim">def alfabetica(parola):
    if len(parola) &lt;= 1:
        return True
    if parola[0] &gt; parola[1]:
        return False
    return alfabetica(parola[1:])
</pre><p>E un’altra opzione è usare un ciclo <span class="c003">while</span>:</p><pre class="verbatim">def alfabetica(parola):
    i = 0
    while i &lt; len(parola)-1:
        if parola[i+1] &lt; parola[i]:
            return False
        i = i+1
    return True
</pre><p>
Il ciclo comincia da <span class="c003">i=0</span> e finisce a <span class="c003">i=len(parola)-1</span>. Ogni volta che viene eseguito, il ciclo confronta l’ <span class="c008">i</span>-esimo carattere (consideratelo come il carattere attuale) con l’ <span class="c008">i</span>+1-esimo carattere (consideratelo come quello successivo).</p><p>Se il carattere successivo è minore di quello attuale (cioè viene alfabeticamente prima), allora abbiamo scoperto un’interruzione nella serie alfabetica e la funzione restituisce <span class="c003">False</span>.</p><p>Se arriviamo a fine ciclo senza trovare difetti, la parola ha superato il test. Per convincervi che il ciclo è terminato correttamente, prendete un esempio come <code>'flossy'</code>. La lunghezza della parola è 6, quindi l’ultima ripetizione del ciclo si ha quando <span class="c003">i</span> è 4, che è l’indice del penultimo carattere. Nell’ultima iterazione, il penultimo carattere è comparato all’ultimo, che è quello che vogliamo.
<a id="hevea_default626"></a></p><p>Ecco una variante di <code>palindromo</code> (vedere l’Esercizio <a href="#palindrome">3</a>) che usa due indici; uno parte dall’inizio e aumenta, uno parte dalla fine e diminuisce.</p><pre class="verbatim">def palindromo(parola):
    i = 0
    j = len(parola)-1

    while i&lt;j:
        if parola[i] != parola[j]:
            return False
        i = i+1
        j = j-1

    return True
</pre><p>Oppure, possiamo ridurre ad un problema già risolto e scrivere:</p><pre class="verbatim">def palindromo(parola):
    return al_contrario(parola, parola)
</pre><p>
<a id="hevea_default627"></a>
<a id="hevea_default628"></a></p><p>Usando <code>al_contrario</code> del Paragrafo <a href="#isreverse">8.11</a>.</p>
<!--TOC section id="sec113" Debug-->
<h2 class="section" id="sec113">9.5  Debug</h2><!--SEC END --><p>
<a id="hevea_default629"></a>
<a id="hevea_default630"></a>
<a id="hevea_default631"></a></p><p>Collaudare i programmi non è facile. Le funzioni di questo capitolo sono relativamente agevoli da provare, perché potete facilmente controllare il risultato da voi. Nonostante ciò, scegliere un insieme di parole che riescano a escludere ogni possibile errore è un qualcosa tra il difficile e l’impossibile.</p><p>Prendiamo ad esempio <code>niente_e</code>. Ci sono due evidenti casi da controllare: le parole che hanno una o più ’e’ devono dare come risultato <span class="c003">False</span>;
quelle che invece non hanno ‘e’, <span class="c003">True</span>. E fin qui, in un caso o nell’altro, non c’è niente di particolarmente difficile.</p><p>Per ciascun caso ci sono alcuni sottocasi meno ovvi. Tra le parole che contengono “e”, dovreste provare parole che iniziano con “e”, finiscono con “e”, hanno “e” da qualche parte nel mezzo della parola. Dovreste poi provare parole lunghe, parole corte e parole cortissime. Nello specifico, la stringa vuota è un esempio di <span class="c009">caso particolare</span>, che è uno dei casi meno ovvi dove si nascondono spesso gli errori.
<a id="hevea_default632"></a></p><p>Oltre che con i casi da voi ideati, sarebbe anche bene fare un test del vostro programma con un elenco di parole come <span class="c003">words.txt</span>. Scansionando l’output potreste intercettare qualche errore, ma attenzione: può trattarsi di un certo tipo di errore (parole che non dovrebbero essere incluse ma invece ci sono) e non di un altro (parole che dovrebbero essere incluse ma non ci sono).</p><p>In linea generale, fare dei test può aiutarvi a trovare i bug, ma non è facile generare un buon insieme di casi di prova, e anche se ci riuscite non potete essere certi che il vostro programma sia corretto al 100 per cento.</p><p>Secondo un leggendario informatico:
<a id="hevea_default633"></a></p><blockquote class="quote">
Il test di un programma può essere usato per dimostrare la presenza di bug, ma mai per dimostrarne l’assenza!<p>— Edsger W. Dijkstra
</p></blockquote><p>
<a id="hevea_default634"></a></p>
<!--TOC section id="sec114" Glossario-->
<h2 class="section" id="sec114">9.6  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">oggetto file:</span></dt><dd class="dd-description"> Un valore che rappresenta un file aperto.
<a id="hevea_default635"></a></dd><dt class="dt-description"><span class="c009">riduzione ad un problema già risolto:</span></dt><dd class="dd-description"> Modo di risolvere un problema esprimendolo come un’istanza di un problema precedentemente risolto.
<a id="hevea_default636"></a>
<a id="hevea_default637"></a></dd><dt class="dt-description"><span class="c009">caso particolare:</span></dt><dd class="dd-description"> un caso atipico o non ovvio (e con meno probabilità di essere gestito correttamente) che viene testato.
<a id="hevea_default638"></a></dd></dl>
<!--TOC section id="sec115" Esercizi-->
<h2 class="section" id="sec115">9.7  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 7</span>  
<a id="hevea_default639"></a>
<a id="hevea_default640"></a>
<a id="hevea_default641"></a><p><em>Questa domanda deriva da un quesito trasmesso nel programma radiofonico </em>Car Talk<em> 
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c003">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
“Ditemi una parola inglese con tre lettere doppie consecutive. Vi dò un paio di parole che andrebbero quasi bene, ma non del tutto. Per esempio la parola “committee”, c-o-m-m-i-t-t-e-e. Sarebbe buona se non fosse per la “i” che si insinua in mezzo. O “Mississippi”: M-i-s-s-i-s-s-i-p-p-i. Togliendo le “i” andrebbe bene. Ma esiste una parola che ha tre coppie di lettere uguali consecutive, e per quanto ne so dovrebbe essere l’unica. Magari ce ne sono altre 500, ma me ne viene in mente solo una. Qual è?”
</em></blockquote><p><em>Scrivete un programma per trovare la parola. Soluzione: </em><a href="http://thinkpython2.com/code/cartalk1.py"><em><span class="c003">http://thinkpython2.com/code/cartalk1.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 8</span>  <em>
Ecco un altro quesito di </em>Car Talk<em>
(</em><a href="http://www.cartalk.com/content/puzzlers"><span class="c003"><em>http://www.cartalk.com/content/puzzlers</em></span></a><em>):
</em><a id="hevea_default642"></a>
<a id="hevea_default643"></a>
<a id="hevea_default644"></a>
<a id="hevea_default645"></a><blockquote class="quote"><em>
“L’altro giorno stavo guidando in autostrada e guardai il mio contachilometri. È a sei cifre, come la maggior parte dei contachilometri, e mostra solo chilometri interi. Se la mia macchina, per esempio, avesse 300.000 km, vedrei 3-0-0-0-0-0.”</em><p><em>“Quello che vidi quel giorno era interessante. Notai che le ultime 4 cifre erano palindrome, cioè si potevano leggere in modo identico sia da sinistra a destra che viceversa. Per esempio 5-4-4-5 è palindromo, per cui il contachilometri avrebbe potuto essere 3-1-5-4-4-5”</em></p><p><em>“Un chilometro dopo, gli ultimi 5 numeri erano palindromi. Per esempio potrei aver letto 3-6-5-4-5-6. Un altro chilometro dopo, le 4 cifre di mezzo erano palindrome. E tenetevi forte: un altro chilometro dopo tutte e 6 erano palindrome!”</em></p><p><em>“La domanda è: quanto segnava il contachilometri la prima volta che guardai?”
</em></p></blockquote><p><em>Scrivete un programma in Python che controlli tutti i numeri a sei cifre e visualizzi i numeri che soddisfano le condizioni sopra indicate. Soluzione: </em><a href="http://thinkpython2.com/code/cartalk2.py"><em><span class="c003">http://thinkpython2.com/code/cartalk2.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 9</span>  <em>
Ecco un altro quesito di </em>Car Talk<em> (</em><a href="http://www.cartalk.com/content/puzzlers"><span class="c003"><em>http://www.cartalk.com/content/puzzlers</em></span></a><em>) che potete risolvere con una ricerca :
</em><a id="hevea_default646"></a>
<a id="hevea_default647"></a>
<a id="hevea_default648"></a><blockquote class="quote"><em>
“Di recente ho fatto visita a mia madre, e ci siamo accorti che le due cifre che compongono la mia età, invertite, formano la sua. Per esempio, se lei avesse 73 anni, io ne avrei 37. Ci siamo domandati quanto spesso succedesse questo negli anni, ma poi abbiamo divagato su altri discorsi senza darci una risposta.”</em><p><em>“Tornato a casa, ho calcolato che le cifre delle nostre età sono state sinora invertibili per sei volte. Ho calcolato anche che se fossimo fortunati succederebbe ancora tra pochi anni, e se fossimo veramente fortunati succederebbe un’altra volta ancora. In altre parole, potrebbe succedere per 8 volte in tutto. La domanda è: quanti anni ho io in questo momento?”</em></p></blockquote><p><em>Scrivete un programma in Python che ricerchi la soluzione a questo quesito. Suggerimento: potrebbe esservi utile il metodo delle stringhe <span class="c003">zfill</span>.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/cartalk3.py"><em><span class="c003">http://thinkpython2.com/code/cartalk3.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec116" Liste-->
<h1 class="chapter" id="sec116">Chapter 10  Liste</h1><!--SEC END --><p>Questo capitolo illustra uno dei più utili tipi predefiniti di Python, le liste. Imparerete anche altri dettagli sugli oggetti, e vedrete cosa succede in presenza di uno stesso oggetto con più nomi.</p>
<!--TOC section id="sec117" Una lista è una sequenza-->
<h2 class="section" id="sec117">10.1  Una lista è una sequenza</h2><!--SEC END --><p>
<a id="sequence"></a></p><p>Come una stringa, una <span class="c009">lista</span> è una sequenza di valori. Mentre in una stringa i valori sono dei caratteri, in una lista possono essere di qualsiasi tipo. I valori che fanno parte della lista sono chiamati <span class="c009">elementi</span>.
<a id="hevea_default649"></a>
<a id="hevea_default650"></a>
<a id="hevea_default651"></a>
<a id="hevea_default652"></a></p><p>Ci sono vari modi per creare una nuova lista; quello più semplice consiste nel
racchiudere i suoi elementi tra parentesi quadrate (<code>[</code> e <code>]</code>):</p><pre class="verbatim">[10, 20, 30, 40]
['Primi piatti', 'Secondi piatti', 'Dessert']
</pre><p>
Il primo esempio è una lista di quattro interi; il secondo è una lista
di tre stringhe. Non è necessario che gli elementi di una stessa lista siano tutti dello stesso tipo: la lista che segue contiene una stringa, un numero in virgola mobile, un intero e (meraviglia!) un’altra lista:</p><pre class="verbatim">['spam', 2.0, 5, [10, 20]]
</pre><p>
Una lista all’interno di un’altra lista è detta lista <span class="c009">nidificata</span>.
<a id="hevea_default653"></a></p><p>Una lista che non contiene elementi è detta lista vuota; potete crearne una scrivendo le due parentesi quadre vuote, <code>[]</code>.
<a id="hevea_default654"></a></p><p>Avrete già intuito che potete assegnare i valori della lista a variabili:</p><pre class="verbatim">&gt;&gt;&gt; formaggi = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; numeri = [42, 123]
&gt;&gt;&gt; vuota = []
&gt;&gt;&gt; print(formaggi, numeri, vuota)
['Cheddar', 'Edam', 'Gouda'] [42, 123] []
</pre><p>
<a id="hevea_default655"></a></p>
<!--TOC section id="sec118" Le liste sono mutabili-->
<h2 class="section" id="sec118">10.2  Le liste sono mutabili</h2><!--SEC END --><p>
<a id="mutable"></a>
<a id="hevea_default656"></a>
<a id="hevea_default657"></a>
<a id="hevea_default658"></a>
<a id="hevea_default659"></a>
<a id="hevea_default660"></a></p><p>La sintassi per accedere agli elementi di una lista è la stessa usata per i caratteri di una stringa: le parentesi quadre, con un’espressione tra parentesi che specifica l’indice dell’elemento. E ricordate che gli indici partono da 0:</p><pre class="verbatim">&gt;&gt;&gt; formaggi[0]
'Cheddar'
</pre><p>
Ma a differenza delle stringhe, le liste sono mutabili. Quando l’operatore parentesi quadre compare sul lato sinistro di un’assegnazione, identifica l’elemento della lista che sarà riassegnato:
<a id="hevea_default661"></a></p><pre class="verbatim">&gt;&gt;&gt; numeri = [42, 123]
&gt;&gt;&gt; numeri[1] = 5
&gt;&gt;&gt; numeri
[42, 5]
</pre><p>
L’elemento di indice 1 di <span class="c003">numeri</span>, che era 123, ora è 5
<a id="hevea_default662"></a>
<a id="hevea_default663"></a></p><p>La Figura <a href="#fig.liststate">10.1</a> mostra il diagramma di stato di <span class="c003">formaggi</span>, <span class="c003">numeri</span> e <span class="c003">vuota</span>:
<a id="hevea_default664"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian011.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 10.1: Diagramma di stato</td></tr>
</table></div>
<a id="fig.liststate"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Le liste possono essere rappresentate da riquadri con la parola “list” all’esterno e i suoi elementi all’interno. <span class="c003">formaggi</span> si riferisce a una lista con tre elementi di indice 0, 1 e 2.
<span class="c003">numeri</span> contiene due elementi; il diagramma mostra che il valore del secondo elemento è stato riassegnato da 123 a 5. <span class="c003">vuota</span> si riferisce a una lista senza elementi.
<a id="hevea_default665"></a>
<a id="hevea_default666"></a>
<a id="hevea_default667"></a></p><p>Gli indici delle liste funzionano nello stesso modo di quelli delle stringhe:</p><ul class="itemize"><li class="li-itemize">L’indice può essere qualsiasi espressione di tipo intero.</li><li class="li-itemize">Se tentate di leggere o modificare un elemento che non esiste, ottenete un messaggio d’errore <span class="c003">IndexError</span>.
<a id="hevea_default668"></a>
<a id="hevea_default669"></a></li><li class="li-itemize">Con un indice di valore negativo, si conta a ritroso dalla fine della
lista.</li></ul><p>
<a id="hevea_default670"></a>
<a id="hevea_default671"></a>
<a id="hevea_default672"></a>
<a id="hevea_default673"></a>
<a id="hevea_default674"></a></p><p>Anche l’operatore <span class="c003">in</span> funziona con le liste:</p><pre class="verbatim">&gt;&gt;&gt; formaggi = ['Cheddar', 'Edam', 'Gouda']
&gt;&gt;&gt; 'Edam' in formaggi
True
&gt;&gt;&gt; 'Brie' in formaggi
False
</pre>
<!--TOC section id="sec119" Attraversamento di una lista-->
<h2 class="section" id="sec119">10.3  Attraversamento di una lista</h2><!--SEC END --><p>
<a id="hevea_default675"></a>
<a id="hevea_default676"></a>
<a id="hevea_default677"></a>
<a id="hevea_default678"></a>
<a id="hevea_default679"></a></p><p>Il modo più frequente di attraversare gli elementi di una lista è un ciclo <span class="c003">for</span>. Anche qui, la sintassi è la stessa delle stringhe:</p><pre class="verbatim">for formaggio in formaggi:
    print(formaggio)
</pre><p>
Questo metodo funziona bene per leggere gli elementi di una lista, ma se volete scrivere o aggiornare degli elementi vi servono gli indici. Un modo per farlo è usare una combinazione delle funzioni predefinite <span class="c003">range</span> e <span class="c003">len</span>:
<a id="hevea_default680"></a>
<a id="hevea_default681"></a></p><pre class="verbatim">for i in range(len(numeri)):
    numeri[i] = numeri[i] * 2
</pre><p>
Questo ciclo attraversa la lista e aggiorna tutti gli elementi. <span class="c003">len</span>
restituisce il numero di elementi della lista. <span class="c003">range</span> restituisce una lista di indici da 0 a <span class="c008">n</span>−1, dove <span class="c008">n</span> è la lunghezza della lista. Ad ogni ripetizione del ciclo, <span class="c003">i</span> prende l’indice dell’elemento successivo. L’istruzione di assegnazione nel corpo usa <span class="c003">i</span> per leggere il vecchio valore dell’elemento e assegnare quello nuovo.
<a id="hevea_default682"></a>
<a id="hevea_default683"></a></p><p>Un ciclo <span class="c003">for</span> su una lista vuota non esegue mai il corpo:</p><pre class="verbatim">for x in []:
    print('Questo non succede mai.')
</pre><p>
Sebbene una lista possa contenerne un’altra, quella nidificata conta sempre come un singolo elemento. Quindi la lunghezza di questa lista è quattro:
<a id="hevea_default684"></a>
<a id="hevea_default685"></a></p><pre class="verbatim">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
<!--TOC section id="sec120" Operazioni sulle liste-->
<h2 class="section" id="sec120">10.4  Operazioni sulle liste</h2><!--SEC END --><p>
<a id="hevea_default686"></a></p><p>L’operatore <span class="c003">+</span> concatena delle liste:
<a id="hevea_default687"></a>
<a id="hevea_default688"></a></p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
[1, 2, 3, 4, 5, 6]
</pre><p>
L’operatore <span class="c003">*</span> ripete una lista per un dato numero di volte:
<a id="hevea_default689"></a>
<a id="hevea_default690"></a></p><pre class="verbatim">&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre><p>
Il primo esempio ripete <span class="c003">[0]</span> per quattro volte. Il secondo ripete la lista <span class="c003">[1, 2, 3]</span> per tre volte.</p>
<!--TOC section id="sec121" Slicing delle liste-->
<h2 class="section" id="sec121">10.5  Slicing delle liste</h2><!--SEC END --><p>
<a id="hevea_default691"></a>
<a id="hevea_default692"></a>
<a id="hevea_default693"></a>
<a id="hevea_default694"></a>
<a id="hevea_default695"></a></p><p>Anche l’operazione di slicing funziona sulle liste:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</pre><p>
Se omettete il primo indice, lo slicing comincia dall’inizio, mentre se manca il secondo, termina alla fine. Se vengono omessi entrambi, lo slicing è una copia dell’intera lista.
<a id="hevea_default696"></a>
<a id="hevea_default697"></a>
<a id="hevea_default698"></a></p><pre class="verbatim">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre><p>
Dato che le liste sono mutabili, spesso è utile farne una copia prima di eseguire operazioni che le modificano.
<a id="hevea_default699"></a></p><p>Un operatore di slicing sul lato sinistro di un’assegnazione, permette di aggiornare più elementi.
<a id="hevea_default700"></a>
<a id="hevea_default701"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; t
['a', 'x', 'y', 'd', 'e', 'f']
</pre>
<!--TOC section id="sec122" Metodi delle liste-->
<h2 class="section" id="sec122">10.6  Metodi delle liste</h2><!--SEC END --><p>
<a id="hevea_default702"></a>
<a id="hevea_default703"></a></p><p>Python fornisce dei metodi che operano sulle liste. Ad esempio,
<span class="c003">append</span> aggiunge un nuovo elemento in coda alla lista:
<a id="hevea_default704"></a>
<a id="hevea_default705"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; t
['a', 'b', 'c', 'd']
</pre><p>
<span class="c003">extend</span> prende una lista come argomento e accoda tutti i suoi elementi:
<a id="hevea_default706"></a>
<a id="hevea_default707"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; t1
['a', 'b', 'c', 'd', 'e']
</pre><p>
Questo esempio lascia immutata la lista <span class="c003">t2</span>.</p><p><span class="c003">sort</span> dispone gli elementi della lista in ordine crescente:
<a id="hevea_default708"></a>
<a id="hevea_default709"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; t
['a', 'b', 'c', 'd', 'e']
</pre><p>
La maggior parte dei metodi delle liste sono vuoti: modificano la lista e restituiscono <span class="c003">None</span>. Se scrivete accidentalmente <span class="c003">t = t.sort()</span>, il risultato vi deluderà.
<a id="hevea_default710"></a>
<a id="hevea_default711"></a>
<a id="hevea_default712"></a></p>
<!--TOC section id="sec123" Mappare, filtrare e ridurre-->
<h2 class="section" id="sec123">10.7  Mappare, filtrare e ridurre</h2><!--SEC END --><p>
<a id="filter"></a></p><p>Per sommare tutti i numeri in una lista, potete usare un ciclo come questo:</p><pre class="verbatim">def somma_tutti(t):
    totale = 0
    for x in t:
        totale += x
    return totale
</pre><p>
<span class="c003">totale</span> è inizializzato a 0. Ad ogni ripetizione del ciclo,
<span class="c003">x</span> prende un elemento dalla lista. L’operatore <span class="c003">+=</span> è una forma abbreviata per aggiornare una variabile. Questa
<span class="c009">istruzione di assegnazione potenziata</span>,
<a id="hevea_default713"></a>
<a id="hevea_default714"></a>
<a id="hevea_default715"></a>
<a id="hevea_default716"></a></p><pre class="verbatim">    totale += x
</pre><p>
è equivalente a</p><pre class="verbatim">    totale = totale + x
</pre><p>
Man mano che il ciclo lavora, <span class="c003">totale</span> accumula la somma degli elementi; una variabile usata in questo modo è detta anche <span class="c009">accumulatore</span>.
<a id="hevea_default717"></a></p><p>Sommare gli elementi di una lista è un’operazione talmente comune che Python contiene una apposita funzione predefinita, <span class="c003">sum</span>:</p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; sum(t)
6
</pre><p>
Una simile operazione che compatta una sequenza di elementi in un singolo valore, è chiamata <span class="c009">riduzione</span>.
<a id="hevea_default718"></a>
<a id="hevea_default719"></a>
<a id="hevea_default720"></a></p><p>Talvolta è necessario attraversare una lista per costruirne contemporaneamente un’altra. Per esempio, la funzione seguente prende una lista di stringhe e restituisce una nuova lista che contiene le stesse stringhe in lettere maiuscole:</p><pre class="verbatim">def tutte_maiuscole(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</pre><p>
<span class="c003">res</span> è inizializzata come una lista vuota; ad ogni ripetizione del ciclo viene accodato un elemento. Pertanto <span class="c003">res</span> è una sorta di accumulatore.
<a id="hevea_default721"></a></p><p>Un’operazione come quella di <code>tutte_maiuscole</code> è chiamata anche <span class="c009">mappa</span>: applica una funzione (in questo caso il metodo <span class="c003">capitalize</span>) su ciascun elemento di una sequenza.
<a id="hevea_default722"></a>
<a id="hevea_default723"></a>
<a id="hevea_default724"></a>
<a id="hevea_default725"></a></p><p>Un’altra operazione frequente è la selezione di alcuni elementi di una lista per formare una sottolista. Per esempio, la seguente funzione prende una lista di stringhe e restituisce una lista che contiene solo le stringhe scritte in lettere maiuscole:</p><pre class="verbatim">def solo_maiuscole(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</pre><p>
<span class="c003">isupper</span> è un metodo delle stringhe che restituisce <span class="c003">True</span> se la stringa contiene solo lettere maiuscole.</p><p>Un’operazione come quella di <code>solo_maiuscole</code> è chiamata <span class="c009">filtro</span> perché seleziona solo alcuni elementi, filtrando gli altri.</p><p>La maggior parte delle operazioni sulle liste possono essere espresse come combinazioni di mappa, filtro e riduzione.</p>
<!--TOC section id="sec124" Cancellare elementi-->
<h2 class="section" id="sec124">10.8  Cancellare elementi</h2><!--SEC END --><p>
<a id="hevea_default726"></a>
<a id="hevea_default727"></a></p><p>Ci sono vari modi per cancellare elementi da una lista. Se conoscete l’indice dell’elemento desiderato, potete usare
<span class="c003">pop</span>:
<a id="hevea_default728"></a>
<a id="hevea_default729"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; t
['a', 'c']
&gt;&gt;&gt; x
'b'
</pre><p>
<span class="c003">pop</span> modifica la lista e restituisce l’elemento che è stato rimosso. Se omettete l’indice, il metodo cancella e restituisce l’ultimo elemento della lista.</p><p>Se non vi serve il valore rimosso, potete usare l’operatore <span class="c003">del</span>:
<a id="hevea_default730"></a>
<a id="hevea_default731"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; t
['a', 'c']
</pre><p>Se conoscete l’elemento da rimuovere ma non il suo indice, potete usare <span class="c003">remove</span>:
<a id="hevea_default732"></a>
<a id="hevea_default733"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; t
['a', 'c']
</pre><p>
Il valore di ritorno di <span class="c003">remove</span> è <span class="c003">None</span>.
<a id="hevea_default734"></a>
<a id="hevea_default735"></a></p><p>Per cancellare più di un elemento potete usare <span class="c003">del</span> con lo slicing:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; t
['a', 'f']
</pre><p>
Come di consueto, lo slicing seleziona gli elementi fino al secondo indice escluso.</p>
<!--TOC section id="sec125" Liste e stringhe-->
<h2 class="section" id="sec125">10.9  Liste e stringhe</h2><!--SEC END --><p>
<a id="hevea_default736"></a>
<a id="hevea_default737"></a>
<a id="hevea_default738"></a></p><p>Una stringa è una sequenza di caratteri e una lista è una sequenza di valori, ma una lista di caratteri non è la stessa cosa di una stringa. Per convertire una stringa in una lista di caratteri, potete usare <span class="c003">list</span>:
<a id="hevea_default739"></a>
<a id="hevea_default740"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; t
['s', 'p', 'a', 'm']
</pre><p>
Poiché <span class="c003">list</span> è una funzione predefinita, va evitato di chiamare una variabile con questo nome. Personalmente evito anche <span class="c003">l</span> perché somiglia troppo a <span class="c003">1</span>. Ecco perché di solito uso <span class="c003">t</span>.</p><p>La funzione <span class="c003">list</span> separa una stringa in singole lettere. Se invece volete spezzare una stringa nelle singole parole, usate il metodo <span class="c003">split</span>:
<a id="hevea_default741"></a>
<a id="hevea_default742"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'profonda nostalgia dei fiordi'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; t
['profonda', 'nostalgia', 'dei', 'fiordi']
</pre><p>
Un argomento opzionale chiamato <span class="c009">delimitatore</span> specifica quale carattere va considerato come separatore delle parole. L’esempio che segue usa il trattino come separatore:
<a id="hevea_default743"></a>
<a id="hevea_default744"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimita = '-'
&gt;&gt;&gt; t = s.split(delimita)
&gt;&gt;&gt; t
['spam', 'spam', 'spam']
</pre><p>
<span class="c003">join</span> è l’inverso di <span class="c003">split</span>: prende una lista di stringhe e concatena gli elementi. <span class="c003">join</span> è un metodo delle stringhe, quindi lo dovete invocare per mezzo del delimitatore e passare la lista come parametro:
<a id="hevea_default745"></a>
<a id="hevea_default746"></a>
<a id="hevea_default747"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['profonda', 'nostalgia', 'dei', 'fiordi']
&gt;&gt;&gt; delimita = ' '
&gt;&gt;&gt; s = delimita.join(t)
&gt;&gt;&gt; s
'profonda nostalgia dei fiordi'
</pre><p>
In questo caso il delimitatore è uno spazio, quindi
<span class="c003">join</span> aggiunge uno spazio tra le parole. Per concatenare delle stringhe senza spazi, basta usare come delimitatore la stringa vuota <code>''</code>.
<a id="hevea_default748"></a></p>
<!--TOC section id="sec126" Oggetti e valori-->
<h2 class="section" id="sec126">10.10  Oggetti e valori</h2><!--SEC END --><p>
<a id="equivalence"></a>
<a id="hevea_default749"></a>
<a id="hevea_default750"></a></p><p>Se eseguiamo queste istruzioni di assegnazione:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
Sappiamo che <span class="c003">a</span> e <span class="c003">b</span> si riferiscono a una stringa, ma non sappiamo se si riferiscono alla <em>stessa</em> stringa.
Ci sono due possibili stati, illustrati in Figura <a href="#fig.list1">10.2</a>.
<a id="hevea_default751"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian012.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 10.2: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.list1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>In un caso, <span class="c003">a</span> e <span class="c003">b</span> si riferiscono a due oggetti diversi che hanno lo stesso valore. Nell’altro, si riferiscono allo stesso oggetto.
<a id="hevea_default752"></a>
<a id="hevea_default753"></a></p><p>Per controllare se due variabili si riferiscono allo stesso oggetto, potete usare l’operatore <span class="c003">is</span>.</p><pre class="verbatim">&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</pre><p>
In questo esempio, Python ha creato un unico oggetto stringa, e sia <span class="c003">a</span> che <span class="c003">b</span> fanno riferimento ad esso.</p><p>Ma se create due liste, ottenete due oggetti distinti:</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</pre><p>
Quindi il diagramma di stato somiglia a quello di Figura <a href="#fig.list2">10.3</a>.
<a id="hevea_default754"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian013.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 10.3: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.list2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>In quest’ultimo caso si dice che le due liste sono <span class="c009">equivalenti</span>,
perché contengono gli stessi elementi, ma non <span class="c009">identiche</span>, perché non sono lo stesso oggetto.
Se due oggetti sono identici, sono anche equivalenti, ma se sono equivalenti non sono necessariamente identici.
<a id="hevea_default755"></a>
<a id="hevea_default756"></a></p><p>Fino ad ora abbiamo usato “oggetto” e “valore” indifferentemente, ma è più preciso dire che un oggetto ha un valore. Se valutate <span class="c003">[1,2,3]</span>, ottenete un oggetto lista il cui valore è una sequenza di interi. Se un’altra lista contiene gli stessi elementi, diciamo che ha lo stesso valore, ma non che è lo stesso oggetto.
<a id="hevea_default757"></a>
<a id="hevea_default758"></a></p>
<!--TOC section id="sec127" Alias-->
<h2 class="section" id="sec127">10.11  Alias</h2><!--SEC END --><p>
<a id="hevea_default759"></a>
<a id="hevea_default760"></a></p><p>Se la variabile <span class="c003">a</span> si riferisce a un oggetto e assegnate <span class="c003">b = a</span>,
allora entrambe le variabili si riferiscono allo stesso oggetto.</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</pre><p>
Il diagramma di stato è quello in Figura <a href="#fig.list3">10.4</a>.
<a id="hevea_default761"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian014.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 10.4: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.list3"></a>
<div class="center"><hr class="c019"></div></blockquote><p>L’associazione tra una variabile e un oggetto è chiamato <span class="c009">riferimento</span>. In questo esempio ci sono due riferimenti allo stesso oggetto.
<a id="hevea_default762"></a></p><p>Un oggetto che ha più di un riferimento ha anche più di un nome, e si dice quindi che l’oggetto ha degli <span class="c009">alias</span>.
<a id="hevea_default763"></a></p><p>Se l’oggetto munito di alias è mutabile, i cambiamenti provocati da un alias si riflettono anche sull’altro:</p><pre class="verbatim">&gt;&gt;&gt; b[0] = 42
&gt;&gt;&gt; a
[42, 2, 3]
</pre><p>
Sebbene questo comportamento possa essere utile, è anche fonte di errori. In genere è più sicuro evitare gli alias quando si sta lavorando con oggetti mutabili.
<a id="hevea_default764"></a></p><p>Per gli oggetti immutabili come le stringhe, gli alias non sono un problema. In questo esempio:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
Non fa quasi mai differenza se <span class="c003">a</span> e <span class="c003">b</span> facciano riferimento alla stessa stringa o meno.</p>
<!--TOC section id="sec128" Liste come argomenti-->
<h2 class="section" id="sec128">10.12  Liste come argomenti</h2><!--SEC END --><p>
<a id="list.arguments"></a>
<a id="hevea_default765"></a>
<a id="hevea_default766"></a>
<a id="hevea_default767"></a>
<a id="hevea_default768"></a>
<a id="hevea_default769"></a></p><p>Quando passate una lista a una funzione, questa riceve un riferimento alla lista. Se la funzione modifica la lista, il chiamante vede la modifica. Per esempio, <code>decapita</code> rimuove il primo elemento di una lista:</p><pre class="verbatim">def decapita(t):
    del t[0]
</pre><p>
Vediamo come si usa:</p><pre class="verbatim">&gt;&gt;&gt; lettere = ['a', 'b', 'c']
&gt;&gt;&gt; decapita(lettere)
&gt;&gt;&gt; lettere
['b', 'c']
</pre><p>
Il parametro <span class="c003">t</span> e la variabile <span class="c003">lettere</span> sono due alias dello stesso oggetto. Il diagramma di stack è riportato in Figura <a href="#fig.stack5">10.5</a>.
<a id="hevea_default770"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian015.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 10.5: Diagramma di stack.</td></tr>
</table></div>
<a id="fig.stack5"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Dato che la lista è condivisa da due frame, la disegno in mezzo.</p><p>È importante distinguere tra operazioni che modificano le liste e operazioni che creano nuove liste. Per esempio il metodo <span class="c003">append</span> modifica una lista, ma l’operatore <span class="c003">+</span> ne crea una nuova.</p><p>Ecco un esempio che usa <span class="c003">append</span>:
<a id="hevea_default771"></a>
<a id="hevea_default772"></a>
<a id="hevea_default773"></a>
<a id="hevea_default774"></a>
</p><pre class="verbatim">&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t2
None
</pre><p>
Il valore di ritorno di <span class="c003">append</span> è <span class="c003">None</span>.</p><p>Un esempio di utilizzo dell’operatore <span class="c003">+</span>:
</p><pre class="verbatim">&gt;&gt;&gt; t3 = t1 + [4]
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t3
[1, 2, 3, 4]
</pre><p>
Il risultato è una nuova lista, e la lista di origine resta immutata.</p><p>Questa differenza è importante quando scrivete delle funzioni che devono modificare delle liste. Per esempio, questa funzione
<em>non</em> cancella il primo elemento della lista:
</p><pre class="verbatim">def non_decapita(t):
    t = t[1:]              # SBAGLIATO!
</pre><p>
L’operatore di slicing crea una nuova lista e l’assegnazione fa in modo che <span class="c003">t</span> si riferisca ad essa, ma tutto ciò non ha effetti sul chiamante.
<a id="hevea_default775"></a>
<a id="hevea_default776"></a>
</p><pre class="verbatim">&gt;&gt;&gt; t4 = [1, 2, 3]
&gt;&gt;&gt; non_decapita(t4)
&gt;&gt;&gt; t4
[1, 2, 3]
</pre><p>
Alla chiamata di <code>non_decapita</code>, <span class="c003">t</span> e <span class="c003">t4</span> fanno riferimento
alla stessa lista. Alla fine, <span class="c003">t</span> fa riferimento ad una nuova lista,
mentre <span class="c003">t4</span> continua a fare riferimento alla stessa lista, non modificata.</p><p>Un’alternativa valida è scrivere una funzione che crea e restituisce una nuova lista. Per esempio, <span class="c003">ritaglia</span> restituisce tutti gli elementi di una lista tranne il primo:</p><pre class="verbatim">def ritaglia(t):
    return t[1:]
</pre><p>
Questa funzione lascia intatta la lista di origine. Ecco come si usa:</p><pre class="verbatim">&gt;&gt;&gt; lettere = ['a', 'b', 'c']
&gt;&gt;&gt; resto = ritaglia(lettere)
&gt;&gt;&gt; resto
['b', 'c']
</pre>
<!--TOC section id="sec129" Debug-->
<h2 class="section" id="sec129">10.13  Debug</h2><!--SEC END --><p>
<a id="hevea_default777"></a></p><p>Un uso poco accurato delle liste (e degli altri oggetti mutabili) può portare a lunghe ore di debug. Ecco alcune delle trappole più comuni e i modi per evitarle:</p><ol class="enumerate" type=1><li class="li-enumerate">La maggior parte dei metodi delle liste modificano l’argomento e restituiscono <span class="c003">None</span>. È il comportamento opposto dei metodi delle stringhe, che restituiscono una nuova stringa e lasciano immutato l’originale.<p>Se siete abituati a scrivere il codice per le stringhe così:</p><pre class="verbatim">parola = parola.strip()
</pre><p>Può venire spontaneo di scrivere il codice per le liste così:</p><pre class="verbatim">t = t.sort()           # SBAGLIATO!
</pre><p>
<a id="hevea_default778"></a>
<a id="hevea_default779"></a></p><p>Ma poiché <span class="c003">sort</span> restituisce <span class="c003">None</span>, l’operazione successiva che eseguite su <span class="c003">t</span> con tutta probabilità fallirà.</p><p>Prima di usare i metodi delle liste e gli operatori, leggetene attentamente la documentazione e fate una prova in modalità interattiva.</p></li><li class="li-enumerate">Scegliete un costrutto e usate sempre quello.<p>Una parte dei problemi delle liste deriva dal fatto che ci sono molti modi per fare le stesse cose. Per esempio, per rimuovere un elemento da una lista potete usare <span class="c003">pop</span>, <span class="c003">remove</span>, <span class="c003">del</span>, oppure lo slicing.</p><p>Per aggiungere un elemento potete usare il metodo <span class="c003">append</span> o l’operatore <span class="c003">+</span>. Supponendo che <span class="c003">t</span> sia una lista e <span class="c003">x</span> un elemento, le espressioni seguenti vanno entrambe bene:</p><pre class="verbatim">t.append(x)
t = t + [x]
</pre><p>Mentre queste sono sbagliate:</p><pre class="verbatim">t.append([x])          # SBAGLIATO!
t = t.append(x)        # SBAGLIATO!
t + [x]                # SBAGLIATO!
t = t + x              # SBAGLIATO!
</pre><p>Provate ognuno di questi esempi in modalità interattiva per verificare quello che fanno. Noterete che solo l’ultima espressione causa un errore di esecuzione; le altre sono consentite, ma fanno la cosa sbagliata.</p></li><li class="li-enumerate">Fate copie per evitare gli alias.
<a id="hevea_default780"></a>
<a id="hevea_default781"></a><p>Se volete usare un metodo come <span class="c003">sort</span> che modifica l’argomento, ma anche mantenere inalterata la lista di origine, potete farne una copia.</p><pre class="verbatim">&gt;&gt;&gt; t = [3, 1, 2]
&gt;&gt;&gt; t2 = t[:]
&gt;&gt;&gt; t2.sort()
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre><p>In questo esempio, si può anche usare la funzione predefinita <span class="c003">sorted</span>,
che restituisce una nuova lista ordinata e lascia intatta quella di origine.
<a id="hevea_default782"></a>
<a id="hevea_default783"></a></p><pre class="verbatim">&gt;&gt;&gt; t2 = sorted(t)
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre></li></ol>
<!--TOC section id="sec130" Glossario-->
<h2 class="section" id="sec130">10.14  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">lista:</span></dt><dd class="dd-description"> Una sequenza di valori.
<a id="hevea_default784"></a></dd><dt class="dt-description"><span class="c009">elemento:</span></dt><dd class="dd-description"> Uno dei valori in una lista (o in altri tipi di sequenza).
<a id="hevea_default785"></a></dd><dt class="dt-description"><span class="c009">lista nidificata:</span></dt><dd class="dd-description"> Lista che è contenuta come elemento in un’altra lista.
<a id="hevea_default786"></a></dd><dt class="dt-description"><span class="c009">accumulatore:</span></dt><dd class="dd-description"> Variabile usata in un ciclo per sommare cumulativamente un risultato.
<a id="hevea_default787"></a></dd><dt class="dt-description"><span class="c009">assegnazione potenziata:</span></dt><dd class="dd-description"> Istruzione che aggiorna un valore di una variabile usando un operatore come <code>+=</code>.
<a id="hevea_default788"></a>
<a id="hevea_default789"></a></dd><dt class="dt-description"><span class="c009">riduzione:</span></dt><dd class="dd-description"> Schema di calcolo che attraversa una sequenza e ne accumula gli elementi in un singolo risultato.
<a id="hevea_default790"></a>
<a id="hevea_default791"></a></dd><dt class="dt-description"><span class="c009">mappa:</span></dt><dd class="dd-description"> Schema di calcolo che attraversa una sequenza ed esegue una stessa operazione su ciascun elemento della sequenza.
<a id="hevea_default792"></a>
<a id="hevea_default793"></a></dd><dt class="dt-description"><span class="c009">filtro:</span></dt><dd class="dd-description"> Schema di calcolo che attraversa una lista e seleziona solo gli elementi che soddisfano un dato criterio.
<a id="hevea_default794"></a>
<a id="hevea_default795"></a></dd><dt class="dt-description"><span class="c009">oggetto:</span></dt><dd class="dd-description"> Qualcosa a cui una variabile può fare riferimento. Un oggetto ha un tipo e un valore.
<a id="hevea_default796"></a></dd><dt class="dt-description"><span class="c009">equivalente:</span></dt><dd class="dd-description"> Avente lo stesso valore.
<a id="hevea_default797"></a></dd><dt class="dt-description"><span class="c009">identico:</span></dt><dd class="dd-description"> Essere lo stesso oggetto (implica anche l’equivalenza).
<a id="hevea_default798"></a></dd><dt class="dt-description"><span class="c009">riferimento:</span></dt><dd class="dd-description"> L’associazione tra una variabile e il suo valore.
<a id="hevea_default799"></a></dd><dt class="dt-description"><span class="c009">alias:</span></dt><dd class="dd-description"> Due o più variabili che si riferiscono allo stesso oggetto, con nomi diversi.
<a id="hevea_default800"></a></dd><dt class="dt-description"><span class="c009">delimitatore:</span></dt><dd class="dd-description"> Carattere o stringa usato per indicare i punti dove una stringa deve essere spezzata.
<a id="hevea_default801"></a></dd></dl>
<!--TOC section id="sec131" Esercizi-->
<h2 class="section" id="sec131">10.15  Esercizi</h2><!--SEC END --><p>Potete scaricare le soluzioni degli esercizi seguenti all’indirizzo
<a href="http://thinkpython2.com/code/list_exercises.py"><span class="c003">http://thinkpython2.com/code/list_exercises.py</span></a>.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete una funzione di nome <code>somma_nidificata</code> che prenda una lista di liste di numeri interi e sommi gli elementi di tutte le liste nidificate.
Esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [[1, 2], [3], [4, 5, 6]]
&gt;&gt;&gt; somma_nidificata(t)
21
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="cumulative"></a>
<a id="hevea_default802"></a><p><em>Scrivete una funzione di nome <code>somma_cumulata</code> che prenda una lista di numeri e restituisca la somma cumulata, cioè una nuova lista dove l’</em><span class="c008">i</span><em>-esimo elemento è la somma dei primi </em><span class="c008">i</span>+1<em> elementi della lista di origine. Per esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; somma_cumulata(t)
[1, 3, 6]
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  <p><em>Scrivete una funzione di nome <code>mediani</code> che prenda una lista e restituisca una nuova lista che contenga tutti gli elementi, esclusi il primo e l’ultimo.
Esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; mediani(t)
[2, 3]
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Scrivete una funzione di nome <code>tronca</code> che prenda una lista, la modifichi togliendo il primo e l’ultimo elemento, e restituisca <span class="c003">None</span>.
Esempio:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; tronca(t)
&gt;&gt;&gt; t
[2, 3]
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  <em>
Scrivete una funzione di nome <code>ordinata</code> che prenda una lista come parametro e restituisca <span class="c003">True</span> se la lista è ordinata in senso crescente, <span class="c003">False</span> altrimenti. Esempio:</em><pre class="verbatim"><em>&gt;&gt;&gt; ordinata([1, 2, 2])
True
&gt;&gt;&gt; ordinata(['b', 'a'])
False
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  
<a id="anagram"></a>
<a id="hevea_default803"></a><p><em>Due parole sono anagrammi se potete ottenerle riordinando le lettere di cui sono composte. Scrivete una funzione di nome <code>anagramma</code>
che riceva due stringhe e restituisca <span class="c003">True</span> se sono anagrammi.
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 7</span>  
<a id="duplicate"></a>
<a id="hevea_default804"></a>
<a id="hevea_default805"></a><p><em>Scrivete una funzione di nome <code>ha_duplicati</code> che richieda una lista e restituisca <span class="c003">True</span> se contiene elementi che compaiono più di una volta. Non deve modificare la lista di origine.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 8</span>  <p><em>Questo è un esercizio sul cosiddetto “Paradosso del compleanno”; potete approfondirlo leggendo </em><a href="http://it.wikipedia.org/wiki/Paradosso_del_compleanno"><em><span class="c003">http://it.wikipedia.org/wiki/Paradosso_del_compleanno</span></em></a><em>.
</em><a id="hevea_default806"></a></p><p><em>Se in una classe ci sono 23 studenti, quante probabilità ci sono che due di loro compiano gli anni lo stesso giorno? Potete stimare questa probabilità generando alcuni campioni a caso di 23 date e controllando le corrispondenze. Suggerimento: per generare date in modo casuale usate la funzione <span class="c003">randint</span> nel modulo <span class="c003">random</span>.
</em><a id="hevea_default807"></a>
<a id="hevea_default808"></a>
<a id="hevea_default809"></a>
<a id="hevea_default810"></a></p><p><em>Potete scaricare la mia soluzione da </em><a href="http://thinkpython2.com/code/birthday.py"><em><span class="c003">http://thinkpython2.com/code/birthday.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 9</span>  
<a id="hevea_default811"></a>
<a id="hevea_default812"></a>
<a id="hevea_default813"></a>
<a id="hevea_default814"></a><p><em>Scrivete una funzione che legga il file <span class="c003">words.txt</span> e crei una lista in cui ogni parola è un elemento. Scrivete due versioni della funzione, una che usi il metodo <span class="c003">append</span> e una il costrutto <span class="c003">t = t + [x]</span>. Quale richiede più tempo di esecuzione? Perché?</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/wordlist.py"><em><span class="c003">http://thinkpython2.com/code/wordlist.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 10</span>  
<a id="wordlist1"></a>
<a id="bisection"></a>
<a id="hevea_default815"></a>
<a id="hevea_default816"></a>
<a id="hevea_default817"></a>
<a id="hevea_default818"></a><p><em>Per controllare se una parola è contenuta in un elenco, è possibile usare l’operatore <span class="c003">in</span>, ma è un metodo lento, perché ricerca le parole seguendo il loro ordine.</em></p><p><em>Dato che le parole sono in ordine alfabetico, possiamo accelerare l’operazione con una ricerca binaria (o per bisezione), che è un po’ come cercare una parola nel vocabolario.
Partite nel mezzo e controllate se la parola che cercate viene prima o dopo la parola di metà elenco. Se prima, cercherete nella prima metà nello stesso modo, se dopo, cercherete nella seconda metà.</em></p><p><em>Ad ogni passaggio, dimezzate lo spazio di ricerca. Se l’elenco ha 113.809 parole, ci vorranno circa 17 passaggi per trovare la parola o concludere che non c’è.</em></p><p><em>Scrivete una funzione di nome <span class="c003">bisezione</span> che richieda una lista ordinata e un valore da ricercare, e restituisca <span class="c003">True</span> se la parola fa parte della lista, o <span class="c003">False</span> se non è presente.
</em><a id="hevea_default819"></a>
<a id="hevea_default820"></a></p><p><em>Oppure, potete leggere la documentazione del modulo <span class="c003">bisect</span> e usare quello! Soluzione: </em><a href="http://thinkpython2.com/code/inlist.py"><span class="c003"><em>http://thinkpython2.com/code/inlist.py</em></span></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 11</span>  
<a id="hevea_default821"></a><p><em>Una coppia di parole è “bifronte” se l’una si legge nel verso opposto dell’altra. Scrivete un programma che trovi tutte le parole bifronti nella lista di parole. Soluzione: </em><a href="http://thinkpython2.com/code/reverse_pair.py"><em><span class="c003">http://thinkpython2.com/code/reverse_pair.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 12</span>  
<a id="hevea_default822"></a><p><em>Due parole si “incastrano” se, prendendo le loro lettere alternativamente dall’una e dall’altra, si forma una nuova parola. Per esempio, le parole inglesi “shoe” and “cold” incastrandosi formano “schooled”.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete un programma che trovi tutte le coppie di parole che possono incastrarsi. Suggerimento: non elaborate tutte le coppie!</em></li><li class="li-enumerate"><em>Riuscite a trovare dei gruppi di tre parole che possono incastrarsi tra loro? Cioè, tre parole da cui, prendendo le lettere una ad una alternativamente, nell’ordine, si formi una nuova parola? (Es. “ace”, “bus” e “as” danno “abacuses”)</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/interlock.py"><em><span class="c003">http://thinkpython2.com/code/interlock.py</span></em></a><em>.
Fonte: Questo esercizio è tratto da un esempio di </em><a href="http://puzzlers.org"><em><span class="c003">http://puzzlers.org</span></em></a><em>.
</em></p></div>
<!--TOC chapter id="sec132" Dizionari-->
<h1 class="chapter" id="sec132">Chapter 11  Dizionari</h1><!--SEC END --><p>Questo capitolo illustra un altro tipo predefinito chiamato dizionario. I dizionari sono una delle migliori caratteristiche di Python; sono i mattoni che costituiscono molti eleganti ed efficienti algoritmi.</p>
<!--TOC section id="sec133" Un dizionario è una mappatura-->
<h2 class="section" id="sec133">11.1  Un dizionario è una mappatura</h2><!--SEC END --><p>
<a id="hevea_default823"></a>
<a id="hevea_default824"></a>
<a id="hevea_default825"></a>
<a id="hevea_default826"></a>
<a id="hevea_default827"></a>
Un <span class="c009">dizionario</span> è simile ad una lista, ma è più generico. Infatti, mentre in una lista gli indici devono essere numeri interi, in un dizionario possono essere (quasi) di ogni tipo.</p><p>Un dizionario contiene una raccolta di indici, chiamati <span class="c009">chiavi</span>, e una raccolta di valori. Ciascuna chiave è associata ad un unico valore. L’associazione tra una chiave e un valore è detta <span class="c009">coppia chiave-valore</span> o anche <span class="c009">elemento</span>.
<a id="hevea_default828"></a></p><p>In linguaggio matematico, un dizionario rappresenta una relazione di corrispondenza, o <span class="c009">mappatura</span>, da una chiave a un valore, e si può dire pertanto che ogni chiave “mappa in” un valore.</p><p>Come esempio, costruiamo un dizionario che trasforma le parole dall’inglese all’italiano, quindi chiavi e valori saranno tutte delle stringhe.</p><p>La funzione <span class="c003">dict</span> crea un nuovo dizionario privo di elementi. Siccome <span class="c003">dict</span> è il nome di una funzione predefinita, è meglio evitare di usarlo come nome di variabile.
<a id="hevea_default829"></a>
<a id="hevea_default830"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2it = dict()
&gt;&gt;&gt; eng2it
{}
</pre><p>Le parentesi graffe, <code>{}</code>, rappresentano un dizionario vuoto. Per aggiungere elementi al dizionario, usate le parentesi quadre:
<a id="hevea_default831"></a>
<a id="hevea_default832"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2it['one'] = 'uno'
</pre><p>
Questa riga crea un elemento che contiene una corrispondenza dalla chiave
<code>'one'</code> al valore <code>'uno'</code>. Se stampiamo di nuovo il dizionario, vedremo ora una coppia chiave-valore separati da due punti:</p><pre class="verbatim">&gt;&gt;&gt; eng2it
{'one': 'uno'}
</pre><p>
Questo formato di output può essere anche usato per gli inserimenti. Ad esempio potete creare un nuovo dizionario con tre elementi:</p><pre class="verbatim">&gt;&gt;&gt; eng2it = {'one': 'uno', 'two': 'due', 'three': 'tre'}
</pre><p>
Se stampate ancora una volta <span class="c003">eng2it</span>, avrete una sorpresa:</p><pre class="verbatim">&gt;&gt;&gt; eng2it
{'one': 'uno', 'three': 'tre', 'two': 'due'}
</pre><p>
L’ordine delle coppie chiave-valore non è necessariamente lo stesso. Se scrivete lo stesso esempio nel vostro computer, potreste ottenere un altro risultato ancora. In genere, l’ordine degli elementi di un dizionario è imprevedibile.</p><p>Ma questo non è un problema, perché gli elementi di un dizionario non sono indicizzati con degli indici numerici. Infatti, per cercare un valore si usano invece le chiavi:</p><pre class="verbatim">&gt;&gt;&gt; eng2it['two']
'due'
</pre><p>
La chiave <code>'two'</code> corrisponde correttamente al valore <code>'due'</code> e l’ordine degli elementi nel dizionario è ininfluente.</p><p>Se la chiave non è contenuta nel dizionario, viene generato un errore::
<a id="hevea_default833"></a>
<a id="hevea_default834"></a></p><pre class="verbatim">&gt;&gt;&gt; print(eng2it['four'])
KeyError: 'four'
</pre><p>
La funzione <span class="c003">len</span> è applicabile ai dizionari, e restituisce il numero di coppie chiave-valore:
<a id="hevea_default835"></a>
<a id="hevea_default836"></a></p><pre class="verbatim">&gt;&gt;&gt; len(eng2it)
3
</pre><p>
Anche l’operatore <span class="c003">in</span> funziona con i dizionari: informa se qualcosa compare come <em>chiave</em> nel dizionario (non è condizione sufficiente che sia contenuto come valore).
<a id="hevea_default837"></a>
<a id="hevea_default838"></a>
<a id="hevea_default839"></a></p><pre class="verbatim">&gt;&gt;&gt; 'one' in eng2it
True
&gt;&gt;&gt; 'uno' in eng2it
False
</pre><p>
Per controllare invece se qualcosa compare come valore, potete usare il metodo <span class="c003">values</span>, che restituisce una raccolta dei valori, e quindi usare l’operatore <span class="c003">in</span>:
<a id="hevea_default840"></a>
<a id="hevea_default841"></a></p><pre class="verbatim">&gt;&gt;&gt; vals = eng2it.values()
&gt;&gt;&gt; 'uno' in vals
True
</pre><p>
L’operatore <span class="c003">in</span> utilizza algoritmi diversi per liste e dizionari. Per le prime, ne ricerca gli elementi in base all’ordine, come nel Paragrafo <a href="#find">8.6</a>. Se la lista si allunga, anche il tempo di ricerca si allunga in proporzione. Per i secondi, Python usa un algoritmo chiamato <span class="c009">tabella hash</span> che ha notevoli proprietà: l’operatore <span class="c003">in</span> impiega sempre circa lo stesso tempo, indipendentemente da quanti elementi contiene il dizionario. Rimando la spiegazione di come ciò sia possibile all’Appendice <a href="#hashtable">B.4</a>: per capirla, occorre prima leggere qualche altro capitolo.
<a id="hevea_default842"></a></p>
<!--TOC section id="sec134" Il dizionario come raccolta di contatori-->
<h2 class="section" id="sec134">11.2  Il dizionario come raccolta di contatori</h2><!--SEC END --><p>
<a id="histogram"></a>
<a id="hevea_default843"></a></p><p>Supponiamo che vi venga data una stringa e che vogliate contare quante volte vi compare ciascuna lettera. Ci sono alcuni modi per farlo:</p><ol class="enumerate" type=1><li class="li-enumerate">Potete creare 26 variabili, una per lettera dell’alfabeto. Quindi, fare un attraversamento della stringa e per ciascun carattere incrementate il contatore corrispondente, magari usando delle condizioni in serie.</li><li class="li-enumerate">Potete creare una lista di 26 elementi, quindi convertire ogni carattere in un numero (usando la funzione predefinita <span class="c003">ord</span>), utilizzare il numero come indice e incrementare il contatore corrispondente.</li><li class="li-enumerate">Potete creare un dizionario con i caratteri come chiavi e i contatori come valore corrispondente. La prima volta che incontrate un carattere, lo aggiungete come elemento al dizionario. Successivamente, incrementerete il valore dell’elemento esistente.</li></ol><p>Ciascuna di queste opzioni esegue lo stesso calcolo, ma lo implementa in modo diverso.
<a id="hevea_default844"></a></p><p>Un’<span class="c009">implementazione</span> è un modo per effettuare un’elaborazione. Le implementazioni non sono tutte uguali, alcune sono migliori di altre: per esempio, un vantaggio dell’implementazione con il dizionario è che non serve sapere in anticipo quali lettere ci siano nella stringa e quali no, dobbiamo solo fare spazio per le lettere che compariranno effettivamente.</p><p>Ecco come potrebbe essere scritto il codice:</p><pre class="verbatim">def istogramma(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
</pre><p>
Il nome di questa funzione è <span class="c003">istogramma</span>, che è un termine statistico per indicare un insieme di contatori (o frequenze).
<a id="hevea_default845"></a>
<a id="hevea_default846"></a>
<a id="hevea_default847"></a></p><p>La prima riga della funzione crea un dizionario vuoto. Il ciclo <span class="c003">for</span> attraversa la stringa. Ad ogni ripetizione, se il carattere <span class="c003">c</span> non compare nel dizionario crea un nuovo elemento di chiave <span class="c003">c</span> e valore iniziale 1 (dato che incontra questa lettera per la prima volta). Se invece <span class="c003">c</span> è già presente, incrementa <span class="c003">d[c]</span> di una unità.
<a id="hevea_default848"></a></p><p>Vediamo come funziona:</p><pre class="verbatim">&gt;&gt;&gt; h = istogramma('brontosauro')
&gt;&gt;&gt; h
{'a': 1, 'b': 1, 'o': 3, 'n': 1, 's': 1, 'r': 2, 'u': 1, 't': 1}
</pre><p>
L’istogramma indica che le lettere <code>'a'</code> e <code>'b'</code>
compaiono una volta, la <code>'o'</code> tre volte e così via.</p><p>I dizionari supportano il metodo <span class="c003">get</span> che richiede una chiave e un valore predefinito. Se la chiave è presente nel dizionario, <span class="c003">get</span> restituisce il suo valore corrispondente, altrimenti restituisce il valore predefinito. Per esempio:
<a id="hevea_default849"></a>
<a id="hevea_default850"></a></p><pre class="verbatim">&gt;&gt;&gt; h = istogramma('a')
&gt;&gt;&gt; h
{'a': 1}
&gt;&gt;&gt; h.get('a', 0)
1
&gt;&gt;&gt; h.get('b', 0)
0
</pre><p>
Come esercizio, usate <span class="c003">get</span> per scrivere <span class="c003">istogramma</span> in modo più compatto. Dovreste riuscire a fare a meno dell’istruzione <span class="c003">if</span>.</p>
<!--TOC section id="sec135" Cicli e dizionari-->
<h2 class="section" id="sec135">11.3  Cicli e dizionari</h2><!--SEC END --><p>
<a id="hevea_default851"></a>
<a id="hevea_default852"></a>
<a id="hevea_default853"></a></p><p>Se usate un dizionario in un ciclo <span class="c003">for</span>, quest’ultimo attraversa le chiavi del dizionario. Per esempio, <code>stampa_isto</code> visualizza ciascuna chiave e il valore corrispondente:</p><pre class="verbatim">def stampa_isto(h):
    for c in h:
        print(c, h[c])
</pre><p>
Ecco come risulta l’output:</p><pre class="verbatim">&gt;&gt;&gt; h = istogramma('parrot')
&gt;&gt;&gt; stampa_isto(h)
a 1
p 1
r 2
t 1
o 1
</pre><p>
Di nuovo, le chiavi sono alla rinfusa. Per attraversare le chiavi disponendole
in ordine, si può utilizzare la funzione predefinita <span class="c003">sorted</span>:
<a id="hevea_default854"></a>
<a id="hevea_default855"></a></p><pre class="verbatim">&gt;&gt;&gt; for chiave in sorted(h):
...     print(chiave, h[chiave])
a 1
o 1
p 1
r 2
t 1
</pre>
<!--TOC section id="sec136" Lookup inverso-->
<h2 class="section" id="sec136">11.4  Lookup inverso</h2><!--SEC END --><p>
<a id="raise"></a>
<a id="hevea_default856"></a>
<a id="hevea_default857"></a>
<a id="hevea_default858"></a>
<a id="hevea_default859"></a></p><p>Dato un dizionario <span class="c003">d</span> e una chiave <span class="c003">k</span>, è facile trovare il valore corrispondente alla chiave: <span class="c003">v = d[k]</span>. Questa operazione è chiamata <span class="c009">lookup</span>.</p><p>Ma se invece volete trovare la chiave <span class="c003">k</span> conoscendo il valore <span class="c003">v</span>?
Avete due problemi: primo, ci possono essere più chiavi che corrispondono al valore <span class="c003">v</span>. A seconda dell’applicazione, potete riuscire a trovarne uno, oppure può essere necessario ricavare una lista che li contenga tutti. Secondo, non c’è una sintassi semplice per fare un <span class="c009">lookup inverso</span>; dovete impostare una ricerca.</p><p>Ecco una funzione che richiede un valore e restituisce la prima chiave a cui corrisponde quel valore:</p><pre class="verbatim">def inverso_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
</pre><p>
Questa funzione è un altro esempio di schema di ricerca, ma usa un’istruzione che non abbiamo mai visto prima, <span class="c003">raise</span>. L’istruzione <span class="c003">raise</span>
solleva un’eccezione; in questo caso genera un errore <span class="c003">LookupError</span>, che è un eccezione predefinita usata per indicare che un’operazione di lookup è fallita.
<a id="hevea_default860"></a>
<a id="hevea_default861"></a>
<a id="hevea_default862"></a>
<a id="hevea_default863"></a>
<a id="hevea_default864"></a>
<a id="hevea_default865"></a></p><p>Se arriviamo a fine ciclo, significa che <span class="c003">v</span>
non compare nel dizionario come valore, per cui solleviamo un’eccezione.</p><p>Ecco un esempio di lookup inverso riuscito:</p><pre class="verbatim">&gt;&gt;&gt; h = istogramma('parrot')
&gt;&gt;&gt; chiave = inverso_lookup(h, 2)
&gt;&gt;&gt; chiave
'r'
</pre><p>
E di uno fallito:</p><pre class="verbatim">&gt;&gt;&gt; chiave = inverso_lookup(h, 3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "&lt;stdin&gt;", line 5, in inverso_lookup
LookupError
</pre><p>
Quando generate un errore, l’effetto è lo stesso di quando lo genera Python: viene stampato un traceback con un messaggio di errore.
<a id="hevea_default866"></a>
<a id="hevea_default867"></a></p><p>L’istruzione <span class="c003">raise</span> può ricevere come parametro opzionale un messaggio di errore dettagliato. Per esempio:</p><pre class="verbatim">&gt;&gt;&gt; raise LookupError('il valore non compare nel dizionario')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
LookupError: il valore non compare nel dizionario
</pre><p>Un lookup inverso è molto più lento di un lookup; se dovete farlo spesso, o se il dizionario diventa molto grande, le prestazioni del vostro programma potrebbero risentirne.</p>
<!--TOC section id="sec137" Dizionari e liste-->
<h2 class="section" id="sec137">11.5  Dizionari e liste</h2><!--SEC END --><p>
<a id="invert"></a></p><p>Le liste possono comparire come valori in un dizionario. Per esempio, se avete un dizionario che fa corrispondere le lettere alle loro frequenze, potreste volere l’inverso; cioè creare un dizionario che a partire dalle frequenze fa corrispondere le lettere. Poiché ci possono essere più lettere con la stessa frequenza, ogni valore del dizionario inverso dovrebbe essere una lista di lettere.
<a id="hevea_default868"></a></p><p>Ecco una funzione che inverte un dizionario:</p><pre class="verbatim">def inverti_diz(d):
    inverso = dict()
    for chiave in d:
        valore = d[chiave]
        if valore not in inverso:
            inverso[valore] = [chiave]
        else:
            inverso[valore].append(chiave)
    return inverso
</pre><p>
Per ogni ripetizione del ciclo, <span class="c003">chiave</span> prende una chiave da <span class="c003">d</span> e 
<span class="c003">valore</span> assume il corrispondente valore. Se <span class="c003">valore</span> non appartiene a <span class="c003">inverso</span>, vuol dire che non è ancora comparso, per cui creiamo un nuovo elemento e lo inizializziamo con un <span class="c009">singleton</span> (lista che contiene un solo elemento). Altrimenti, se il valore era già apparso, accodiamo la chiave corrispondente alla lista esistente.
<a id="hevea_default869"></a></p><p>Ecco un esempio:</p><pre class="verbatim">&gt;&gt;&gt; isto = istogramma('parrot')
&gt;&gt;&gt; isto
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
&gt;&gt;&gt; inverso = inverti_diz(isto)
&gt;&gt;&gt; inverso
{1: ['a', 'p', 't', 'o'], 2: ['r']}
</pre><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian016.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 11.1: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.dict1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La Figura <a href="#fig.dict1">11.1</a> è un diagramma di stato che mostra <span class="c003">isto</span> e <span class="c003">inverso</span>.
Un dizionario viene rappresentato come un riquadro con la scritta <span class="c003">dict</span> sopra e le coppie chiave-valore all’interno. Se i valori sono interi, float o stringhe, li raffiguro dentro il riquadro, lascio invece all’esterno le liste per mantenere semplice il diagramma.
<a id="hevea_default870"></a></p><p>Le liste possono essere valori nel dizionario, come mostra questo esempio, ma non possono essere chiavi. Ecco cosa succede se ci provate:
<a id="hevea_default871"></a>
<a id="hevea_default872"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; d[t] = 'oops'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: list objects are unhashable
</pre><p>
Ho accennato che i dizionari sono implementati usando una tabella hash, e questo implica che alle chiavi deve poter essere applicato un <span class="c009">hash</span>.
<a id="hevea_default873"></a>
<a id="hevea_default874"></a></p><p>Un <span class="c009">hash</span> è una funzione che prende un valore (di qualsiasi tipo) e restituisce un intero. I dizionari usano questi interi, chiamati valori hash, per conservare e consultare le coppie chiave-valore.
<a id="hevea_default875"></a></p><p>Questo sistema funziona se le chiavi sono immutabili; ma se sono mutabili, come le liste, succedono disastri. Per esempio, nel creare una coppia chiave-valore, Python fa l’hashing della chiave e la immagazzina nello spazio corrispondente. Se modificate la chiave e quindi viene nuovamente calcolato l’hash, si collocherebbe in un altro spazio. In quel caso potreste avere due voci della stessa chiave, oppure non riuscire a trovare una chiave. In ogni caso il dizionario non funzionerà correttamente.</p><p>Ecco perché le chiavi devono essere idonee all’hashing, e quelle mutabili come le liste non lo sono. Il modo più semplice per aggirare questo limite è usare le tuple, che vedremo nel prossimo capitolo.</p><p>Dato che i dizionari sono mutabili, non possono essere usati come chiavi ma <em>possono</em> essere usati come valori.</p>
<!--TOC section id="sec138" Memoizzazione-->
<h2 class="section" id="sec138">11.6  Memoizzazione</h2><!--SEC END --><p>
<a id="memoize"></a></p><p>Se vi siete sbizzarriti con la funzione <span class="c003">fibonacci</span> del Paragrafo <a href="#one.more.example">6.7</a>, avrete notato che più grande è l’argomento che passate, maggiore è il tempo necessario per l’esecuzione della funzione. Inoltre, il tempo di elaborazione cresce rapidamente.
<a id="hevea_default876"></a>
<a id="hevea_default877"></a></p><p>Per capire il motivo, confrontate la Figura <a href="#fig.fibonacci">11.2</a>, che mostra il <span class="c009">grafico di chiamata</span> di <span class="c003">fibonacci</span> con <span class="c003">n=4</span>:</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian017.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 11.2: Grafico di chiamata.</td></tr>
</table></div>
<a id="fig.fibonacci"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Un grafico di chiamata mostra l’insieme dei frame della funzione, con linee che collegano ciascun frame ai frame delle funzioni che chiama a sua volta. In cima al grafico, <span class="c003">fibonacci</span> con <span class="c003">n=4</span> chiama <span class="c003">fibonacci</span> con <span class="c003">n=3</span> e <span class="c003">n=2</span>. A sua volta, <span class="c003">fibonacci</span> con <span class="c003">n=3</span> chiama
<span class="c003">fibonacci</span> con <span class="c003">n=2</span> e <span class="c003">n=1</span>. E così via.
<a id="hevea_default878"></a>
<a id="hevea_default879"></a>
<a id="hevea_default880"></a></p><p>Provate a contare quante volte vengono chiamate <span class="c003">fibonacci(0)</span> e <span class="c003">fibonacci(1)</span>. Questa è una soluzione inefficiente del problema, che peggiora ulteriormente al crescere dell’argomento.
<a id="hevea_default881"></a></p><p>Una soluzione migliore è tenere da parte i valori che sono già stati calcolati, conservandoli in un dizionario. La tecnica di conservare per un uso successivo un valore già calcolato, così da non doverlo ricalcolare ogni volta, viene detta <span class="c009">memoizzazione</span>. Ecco una versione di <span class="c003">fibonacci</span> che usa la memoizzazione:</p><pre class="verbatim">memo = {0:0, 1:1}

def fibonacci(n):
    if n in memo:
        return memo[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    memo[n] = res
    return res
</pre><p>
<span class="c003">memo</span> è un dizionario che conserva i numeri di Fibonacci già conosciuti. Parte con due elementi: 0 che corrisponde a 0, e 1 che corrisponde a 1.</p><p>Ogni volta che <span class="c003">fibonacci</span> viene chiamata, controlla innanzitutto <span class="c003">memo</span>.
Se quest’ultimo contiene già il risultato, ritorna immediatamente. Altrimenti deve calcolare il nuovo valore, lo aggiunge al dizionario e lo restituisce.</p><p>Provate ad eseguire questa versione di <span class="c003">fibonacci</span> e a confrontarla con l’originale: troverete che è molto più veloce.</p>
<!--TOC section id="sec139" Variabili globali-->
<h2 class="section" id="sec139">11.7  Variabili globali</h2><!--SEC END --><p>
<a id="hevea_default882"></a></p><p>Nell’esempio precedente, <span class="c003">memo</span> viene creato esternamente alla funzione, pertanto appartiene al frame speciale chiamato <code>__main__</code>.
Le variabili di <code>__main__</code> sono dette anche <span class="c009">globali</span>
perché ad esse possono accedere tutte le funzioni. A differenza delle variabili locali, che sono distrutte una volta terminata l’esecuzione della loro funzione, quelle globali persistono tra una chiamata di funzione e l’altra.
<a id="hevea_default883"></a>
<a id="hevea_default884"></a></p><p>Di frequente le variabili globali vengono usate come controlli o <span class="c009">flag</span>; vale a dire, variabili booleane che indicano quando una certa condizione è soddisfatta (True). Per esempio, alcuni programmi usano un flag di nome <span class="c003">verbose</span> per controllare che livello di dettaglio dare ad un output:</p><pre class="verbatim">verbose = True

def esempio1():
    if verbose:
        print('esempio1 in esecuzione')
</pre><p>
Se cercate di riassegnare una variabile globale, potreste avere una sorpresa. L’esempio seguente vorrebbe controllare se una funzione è stata chiamata:
<a id="hevea_default885"></a></p><pre class="verbatim">stata_chiamata = False

def esempio2():
    stata_chiamata = True         # SBAGLIATO
</pre><p>
Ma se la eseguite vedrete che il valore di <code>stata_chiamata</code>
non cambia. Il motivo è che la funzione <span class="c003">esempio2</span> crea una nuova variabile di nome <code>stata_chiamata</code>, che è locale, viene distrutta al termine della funzione e non ha effetti sulla variabile globale.
<a id="hevea_default886"></a>
<a id="hevea_default887"></a>
<a id="hevea_default888"></a></p><p>Per riassegnare una variabile globale dall’interno di una funzione, dovete
<span class="c009">dichiarare</span> la variabile globale prima di usarla:</p><pre class="verbatim">stata_chiamata = False

def esempio2():
    global stata_chiamata 
    stata_chiamata = True
</pre><p>
L’istruzione <span class="c003">global</span> dice all’interprete una cosa del genere: “In questa funzione, quando dico <code>stata_chiamata</code>, intendo la variabile globale: non crearne una locale”.
<a id="hevea_default889"></a>
<a id="hevea_default890"></a></p><p>Ecco un altro esempio che cerca di aggiornare una variabile globale:</p><pre class="verbatim">conta = 0

def esempio3():
    conta = conta + 1          # SBAGLIATO
</pre><p>
Se lo eseguite, ottenete:
<a id="hevea_default891"></a>
<a id="hevea_default892"></a></p><pre class="verbatim">UnboundLocalError: local variable 'conta' referenced before assignment
</pre><p>
Python presume che <span class="c003">conta</span> all’interno della funzione sia una variabile locale, e con questa premessa significa che state usando la variabile prima di averla inizializzata. La soluzione è ancora quella di dichiarare <span class="c003">conta</span> globale.
<a id="hevea_default893"></a></p><pre class="verbatim">def esempio3():
    global conta
    conta += 1
</pre><p>
Se una variabile globale fa riferimento ad un valore mutabile, potete modificare il valore senza dichiarare la variabile:
<a id="hevea_default894"></a></p><pre class="verbatim">noto = {0:0, 1:1}

def esempio4():
    noto[2] = 1
</pre><p>
Pertanto, potete aggiungere, rimuovere e sostituire elementi di una lista o dizionario globali; tuttavia, se volete riassegnare la variabile, occorre dichiararla:</p><pre class="verbatim">def esempio5():
    global noto
    noto = dict()
</pre><p>
Le variabili globali possono risultare utili, ma se ce ne sono molte e le modificate di frequente, possono rendere difficile il debug del programma. </p>
<!--TOC section id="sec140" Debug-->
<h2 class="section" id="sec140">11.8  Debug</h2><!--SEC END --><p>
<a id="hevea_default895"></a></p><p>Se lavorate con banche dati di grosse dimensioni, può diventare oneroso fare il debug stampando e controllando i risultati di output manualmente. Ecco allora alcuni suggerimenti per fare il debug in queste situazioni:</p><dl class="description"><dt class="dt-description"><span class="c009">Ridurre l’input:</span></dt><dd class="dd-description"> Se possibile, riducete le dimensioni della banca dati. Per esempio, se il programma legge un file di testo, cominciate con le sole prime 10 righe o con il più piccolo campione che riuscite a trovare. Potete anche adattare i file stessi, o (meglio) modificare il programma, in modo che legga solo le prime <span class="c003">n</span> righe.<p>Se c’è un errore, potete ridurre <span class="c003">n</span> al più piccolo valore per il quale si manifesta l’errore, poi aumentarlo gradualmente finché non trovate e correggete l’errore.</p></dd><dt class="dt-description"><span class="c009">Controllare riassunti e tipi:</span></dt><dd class="dd-description"> Invece di stampare e controllare l’intera banca dati, prendete in considerazione di stampare riassunti dei dati: ad esempio il numero di elementi in un dizionario o la sommatoria di una lista di numeri.<p>Una causa frequente di errori in esecuzione è un valore che non è del tipo giusto. Per fare il debug di questo tipo di errori basta spesso stampare il tipo di un valore.</p></dd><dt class="dt-description"><span class="c009">Scrivere controlli automatici:</span></dt><dd class="dd-description"> Talvolta è utile scrivere del codice per controllare automaticamente gli errori. Per esempio, se dovete calcolare la media di una lista di numeri, potete controllare che il risultato non sia maggiore dell’elemento più grande della lista e non sia minore del più piccolo. Questo è detto “controllo di congruenza” perché mira a trovare i risultati “incongruenti”.
<a id="hevea_default896"></a>
<a id="hevea_default897"></a><p>Un altro tipo di controllo confronta i risultati di due calcoli per vedere se collimano. Questo è chiamato “controllo di coerenza”.</p></dd><dt class="dt-description"><span class="c009">Stampare gli output in bella copia:</span></dt><dd class="dd-description"> Una buona presentazione dei risultati di debug rende più facile trovare un errore. Abbiamo visto un esempio nel Paragrafo <a href="#factdebug">6.9</a>. Uno strumento utile è il modulo <span class="c003">pprint</span>: esso contiene la funzione <span class="c003">pprint</span> che mostra i tipi predefiniti in un formato più leggibile (pprint infatti sta per “pretty print”).
<a id="hevea_default898"></a>
<a id="hevea_default899"></a>
<a id="hevea_default900"></a></dd></dl><p>Ancora, il tempo che impiegate a scrivere del codice temporaneo può essere ripagato dalla riduzione del tempo di debug.
<a id="hevea_default901"></a></p>
<!--TOC section id="sec141" Glossario-->
<h2 class="section" id="sec141">11.9  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">mappatura:</span></dt><dd class="dd-description"> Relazione per cui a ciascun elemento di un insieme corrisponde un elemento di un altro insieme.
<a id="hevea_default902"></a></dd><dt class="dt-description"><span class="c009">dizionario:</span></dt><dd class="dd-description"> Una mappatura da chiavi nei loro valori corrispondenti.
<a id="hevea_default903"></a></dd><dt class="dt-description"><span class="c009">coppia chiave-valore:</span></dt><dd class="dd-description"> Rappresentazione della mappatura da una chiave in un valore.
<a id="hevea_default904"></a></dd><dt class="dt-description"><span class="c009">elemento:</span></dt><dd class="dd-description"> In un dizionario, altro nome della coppia chiave-valore.
<a id="hevea_default905"></a></dd><dt class="dt-description"><span class="c009">chiave:</span></dt><dd class="dd-description"> Oggetto che compare in un dizionario come prima voce di una coppia chiave-valore.
<a id="hevea_default906"></a></dd><dt class="dt-description"><span class="c009">valore:</span></dt><dd class="dd-description"> Oggetto che compare in un dizionario come seconda voce di una coppia chiave-valore. È più specifico dell’utilizzo del termine “valore” fatto sinora.
<a id="hevea_default907"></a></dd><dt class="dt-description"><span class="c009">implementazione:</span></dt><dd class="dd-description"> Un modo per effettuare un’elaborazione.
<a id="hevea_default908"></a></dd><dt class="dt-description"><span class="c009">tabella hash:</span></dt><dd class="dd-description"> Algoritmo usato per implementare i dizionari in Python.
<a id="hevea_default909"></a></dd><dt class="dt-description"><span class="c009">funzione hash:</span></dt><dd class="dd-description"> Funzione usata da una tabella hash per calcolare la collocazione di una chiave.
<a id="hevea_default910"></a></dd><dt class="dt-description"><span class="c009">hash-abile:</span></dt><dd class="dd-description"> Un tipo a cui si può applicare la funzione hash. I tipi immutabili come interi, float e stringhe lo sono; i tipi mutabili come liste e dizionari no.
<a id="hevea_default911"></a></dd><dt class="dt-description"><span class="c009">lookup:</span></dt><dd class="dd-description"> Operazione su un dizionario che trova il valore corrispondente a una data chiave.
<a id="hevea_default912"></a></dd><dt class="dt-description"><span class="c009">lookup inverso:</span></dt><dd class="dd-description"> Operazione su un dizionario che trova una o più chiavi alle quali è associato un dato valore.
<a id="hevea_default913"></a></dd><dt class="dt-description"><span class="c009">singleton:</span></dt><dd class="dd-description"> Lista (o altra sequenza) con un singolo elemento.
<a id="hevea_default914"></a></dd><dt class="dt-description"><span class="c009">grafico di chiamata:</span></dt><dd class="dd-description"> Diagramma che mostra tutti i frame creati durante l’esecuzione di un programma, con frecce che collegano ciascun chiamante ad ogni chiamata.
<a id="hevea_default915"></a>
<a id="hevea_default916"></a></dd><dt class="dt-description"><span class="c009">memoizzazione:</span></dt><dd class="dd-description"> Conservare un valore calcolato per evitarne il successivo ricalcolo.
<a id="hevea_default917"></a></dd><dt class="dt-description"><span class="c009">variabile globale:</span></dt><dd class="dd-description"> Variabile definita al di fuori di una funzione, alla quale ogni funzione può accedere.
<a id="hevea_default918"></a></dd><dt class="dt-description"><span class="c009">istruzione global:</span></dt><dd class="dd-description"> Istruzione che dichiara globale il nome di una variabile.
<a id="hevea_default919"></a>
<a id="hevea_default920"></a></dd><dt class="dt-description"><span class="c009">controllo o flag:</span></dt><dd class="dd-description"> Variabile booleana usata per indicare se una condizione è soddisfatta.
<a id="hevea_default921"></a></dd><dt class="dt-description"><span class="c009">dichiarazione:</span></dt><dd class="dd-description"> Istruzione come <span class="c003">global</span>, che comunica all’interprete un’informazione su una variabile.
<a id="hevea_default922"></a></dd></dl>
<!--TOC section id="sec142" Esercizi-->
<h2 class="section" id="sec142">11.10  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  
<a id="wordlist2"></a>
<a id="hevea_default923"></a>
<a id="hevea_default924"></a><p><em>Scrivete una funzione che legga le parole in <span class="c003">words.txt</span> e le inserisca come chiavi in un dizionario. I valori non hanno importanza. Usate poi l’operatore <span class="c003">in</span> come modo rapido per controllare se una stringa è contenuta nel dizionario.</em></p><p><em>Se avete svolto l’Esercizio </em><a href="#wordlist1"><em>10</em></a><em>, potete confrontare la velocità di questa implementazione con l’operatore <span class="c003">in</span> applicato alla lista e la ricerca binaria.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="setdefault"></a><p><em>Leggete la documentazione del metodo dei dizionari <span class="c003">setdefault</span>
e usatelo per scrivere una versione più concisa di <code>inverti_diz</code>.
Soluzione: </em><a href="http://thinkpython2.com/code/invert_dict.py"><span class="c003"><em>http://thinkpython2.com/code/invert_dict.py</em></span></a><em>.
</em><a id="hevea_default925"></a>
<a id="hevea_default926"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  <p><em>Applicate la memoizzazione alla funzione di Ackermann dell’Esercizio </em><a href="#ackermann"><em>2</em></a><em> e provate a vedere se questa tecnica rende possibile il calcolo della funzione con argomenti più grandi. Suggerimento: no.
Soluzione: </em><a href="http://thinkpython2.com/code/ackermann_memo.py"><span class="c003"><em>http://thinkpython2.com/code/ackermann_memo.py</em></span></a><em>.
</em><a id="hevea_default927"></a>
<a id="hevea_default928"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  
<a id="hevea_default929"></a><p><em>Se avete svolto l’Esercizio </em><a href="#duplicate"><em>7</em></a><em>, avete già una funzione di nome <code>ha_duplicati</code> che richiede come parametro una lista e restituisce <span class="c003">True</span> se ci sono oggetti ripetuti all’interno della lista.</em></p><p><em>Usate un dizionario per scrivere una versione più rapida e semplice di
<code>ha_duplicati</code>. 
Soluzione: </em><a href="http://thinkpython2.com/code/has_duplicates.py"><span class="c003"><em>http://thinkpython2.com/code/has_duplicates.py</em></span></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  
<a id="exrotatepairs"></a>
<a id="hevea_default930"></a>
<a id="hevea_default931"></a><p><em>Due parole sono “ruotabili” se potete far ruotare le lettere dell’una per ottenere l’altra (vedere <code>ruota_parola</code> nell’Esercizio </em><a href="#exrotate"><em>5</em></a><em>).</em></p><p><em>Scrivete un programma che legga un elenco di parole e trovi tutte le coppie di parole ruotabili. Soluzione: </em><a href="http://thinkpython2.com/code/rotate_pairs.py"><em><span class="c003">http://thinkpython2.com/code/rotate_pairs.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  
<a id="hevea_default932"></a>
<a id="hevea_default933"></a><p><em>Ecco un altro quesito tratto da </em>Car Talk<em> (</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c003">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
“Questo ci è stato mandato da un amico di nome Dan O’Leary. Si è recentemente imbattuto in una parola inglese di una sillaba e cinque lettere che ha questa singolare proprietà: se togliete la prima lettera, le lettere restanti formano un omofono della prima parola, cioè un’altra parola che pronunciata suona allo stesso modo. Se poi rimettete la prima lettera e togliete la seconda, ottenete ancora un altro omofono della parola di origine. Qual è questa parola?”</em><p><em>“Facciamo un esempio che non funziona del tutto. Prendiamo la parola ’wrack’; togliendo la prima lettera resta ’rack’, che è un’altra parola ma è un perfetto omofono. Se però rimettete la prima lettera e togliete la seconda, ottenete ’wack’ che pure esiste ma non è un omofono delle altre due parole.”</em></p><p><em>“Esiste comunque almeno una parola, che Dan e noi conosciamo, che dà due parole omofone di quattro lettere, sia che togliate la prima oppure la seconda lettera.”
</em></p></blockquote><p>
<a id="hevea_default934"></a>
<a id="hevea_default935"></a>
<a id="hevea_default936"></a></p><p><em>Potete usare il dizionario dell’Esercizio </em><a href="#wordlist2"><em>1</em></a><em> per controllare se esiste una tale stringa nell’elenco di parole.</em></p><p><em>Per controllare se due parole sono omofone, potete usare il CMU Pronouncing Dictionary, scaricabile da
</em><a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict"><span class="c003"><em>http://www.speech.cs.cmu.edu/cgi-bin/cmudict</em></span></a><em> oppure da
</em><a href="http://thinkpython2.com/code/c06d"><span class="c003"><em>http://thinkpython2.com/code/c06d</em></span></a><em> e potete anche procurarvi
</em><a href="http://thinkpython2.com/code/pronounce.py"><span class="c003"><em>http://thinkpython2.com/code/pronounce.py</em></span></a><em>, che fornisce una funzione di nome <code>read_dictionary</code> che legge il dizionario delle pronunce e restituisce un dizionario Python in cui a ciascuna parola corrisponde la stringa che ne descrive la pronuncia.</em></p><p><em>Scrivete un programma che elenchi tutte le parole che risolvono il quesito. Soluzione: </em><a href="http://thinkpython2.com/code/homophone.py"><em><span class="c003">http://thinkpython2.com/code/homophone.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec143" Tuple-->
<h1 class="chapter" id="sec143">Chapter 12  Tuple</h1><!--SEC END --><p>
<a id="tuplechap"></a></p><p>Questo capitolo illustra un altro tipo di dati predefinito, le tuple, per poi mostrare come liste, tuple e dizionari possono lavorare insieme. Viene inoltre presentata una utile caratteristica per le liste di argomenti a lunghezza variabile: gli operatori di raccolta e spacchettamento.</p>
<!--TOC section id="sec144" Le tuple sono immutabili-->
<h2 class="section" id="sec144">12.1  Le tuple sono immutabili</h2><!--SEC END --><p>
<a id="hevea_default937"></a>
<a id="hevea_default938"></a>
<a id="hevea_default939"></a></p><p>Una tupla è una sequenza di valori. I valori possono essere di qualsiasi tipo, sono indicizzati tramite numeri interi, e in questo somigliano moltissimo alle liste. La differenza fondamentale è che le tuple sono immutabili.
<a id="hevea_default940"></a>
<a id="hevea_default941"></a></p><p>Sintatticamente, la tupla è un elenco di valori separati da virgole:</p><pre class="verbatim">&gt;&gt;&gt; t = 'a', 'b', 'c', 'd', 'e'
</pre><p>
Sebbene non sia necessario, è convenzione racchiudere le tuple tra
parentesi tonde:
<a id="hevea_default942"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
</pre><p>
Per creare una tupla con un singolo elemento, occorre aggiungere una
virgola dopo l’elemento:
<a id="hevea_default943"></a>
<a id="hevea_default944"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = 'a',
&gt;&gt;&gt; type(t1)
&lt;class 'tuple'&gt;
</pre><p>
Senza la virgola, infatti, un unico valore tra parentesi non è una tupla ma una stringa:</p><pre class="verbatim">&gt;&gt;&gt; t2 = ('a')
&gt;&gt;&gt; type(t2)
&lt;class 'str'&gt;
</pre><p>
Un altro modo di creare una tupla è usare la funzione predefinita <span class="c003">tuple</span>.
Se priva di argomento, crea una tupla vuota:
<a id="hevea_default945"></a>
<a id="hevea_default946"></a></p><pre class="verbatim">&gt;&gt;&gt; t = tuple()
&gt;&gt;&gt; t
()
</pre><p>
Se l’argomento è una sequenza (stringa, lista o tupla), il risultato è una tupla con gli elementi della sequenza:</p><pre class="verbatim">&gt;&gt;&gt; t = tuple('lupini')
&gt;&gt;&gt; t
('l', 'u', 'p', 'i', 'n', 'i')
</pre><p>
Siccome <span class="c003">tuple</span> è il nome di una funzione predefinita, bisogna evitare di usarlo come nome di variabile.</p><p>La maggior parte degli operatori delle liste funzionano anche con le tuple. L’operatore parentesi quadre indicizza un elemento della tupla:
<a id="hevea_default947"></a>
<a id="hevea_default948"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; t[0]
'a'
</pre><p>
E l’operatore di slicing seleziona una serie di elementi consecutivi:
<a id="hevea_default949"></a>
<a id="hevea_default950"></a>
<a id="hevea_default951"></a>
<a id="hevea_default952"></a></p><pre class="verbatim">&gt;&gt;&gt; t[1:3]
('b', 'c')
</pre><p>
Ma a differenza delle liste, se cercate di modificare gli elementi di una tupla ottenete un messaggio d’errore:
<a id="hevea_default953"></a>
<a id="hevea_default954"></a>
<a id="hevea_default955"></a>
<a id="hevea_default956"></a></p><pre class="verbatim">&gt;&gt;&gt; t[0] = 'A'
TypeError: object doesn't support item assignment
</pre><p>
Dato che le tuple sono immutabili, non si può modificarne gli elementi. Ma potete sostituire una tupla con un’altra:</p><pre class="verbatim">&gt;&gt;&gt; t = ('A',) + t[1:]
&gt;&gt;&gt; t
('A', 'b', 'c', 'd', 'e')
</pre><p>Questa istruzione crea una nuova tupla e poi fa in modo che <span class="c003">t</span> si riferisca ad essa.</p><p>Gli operatori di confronto funzionano con le tuple e le altre sequenze; Python inizia a confrontare il primo elemento di ciascuna sequenza. Se sono uguali, passa all’elemento successivo e così via, finché non trova due elementi diversi. Gli eventuali elementi che seguono vengono trascurati (anche se sono molto grandi).</p><pre class="verbatim">&gt;&gt;&gt; (0, 1, 2) &lt; (0, 3, 4)
True
&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)
True
</pre>
<!--TOC section id="sec145" Assegnazione di tupla-->
<h2 class="section" id="sec145">12.2  Assegnazione di tupla</h2><!--SEC END --><p>
<a id="tuple.assignment"></a>
<a id="hevea_default957"></a>
<a id="hevea_default958"></a>
<a id="hevea_default959"></a>
<a id="hevea_default960"></a></p><p>Spesso è utile scambiare i valori di due variabili tra loro. Con le istruzioni di assegnazione convenzionali, dobbiamo usare una variabile temporanea. Per esempio per scambiare <span class="c003">a</span> e <span class="c003">b</span>:</p><pre class="verbatim">&gt;&gt;&gt; temp = a
&gt;&gt;&gt; a = b
&gt;&gt;&gt; b = temp
</pre><p>
Questo metodo è farraginoso; l’utilizzo dell’<span class="c009">assegnazione di tupla</span> è più elegante:</p><pre class="verbatim">&gt;&gt;&gt; a, b = b, a
</pre><p>
Sul lato sinistro abbiamo una tupla di variabili; su quello destro, una tupla di espressioni. Ciascun valore viene assegnato alla rispettiva variabile. Tutte le espressioni sul lato destro vengono valutate prima di ogni assegnazione.</p><p>Il numero di variabili sulla sinistra deve essere uguale al numero di valori sulla destra:
<a id="hevea_default961"></a>
<a id="hevea_default962"></a></p><pre class="verbatim">&gt;&gt;&gt; a, b = 1, 2, 3
ValueError: too many values to unpack
</pre><p>
Più in generale, sul lato destro può esserci qualsiasi tipo di sequenza (stringhe, liste o tuple). Per esempio, per separare un indirizzo email tra nome utente e dominio, potete scrivere:
<a id="hevea_default963"></a>
<a id="hevea_default964"></a>
<a id="hevea_default965"></a></p><pre class="verbatim">&gt;&gt;&gt; indirizzo = 'monty@python.org'
&gt;&gt;&gt; nome, dominio = indirizzo.split('@')
</pre><p>
Il valore di ritorno del metodo <span class="c003">split</span> è una lista con due elementi; il primo è assegnato alla variabile <span class="c003">nome</span>, il secondo a <span class="c003">dominio</span>.</p><pre class="verbatim">&gt;&gt;&gt; nome
'monty'
&gt;&gt;&gt; dominio
'python.org'
</pre>
<!--TOC section id="sec146" Tuple come valori di ritorno-->
<h2 class="section" id="sec146">12.3  Tuple come valori di ritorno</h2><!--SEC END --><p>
<a id="hevea_default966"></a>
<a id="hevea_default967"></a>
<a id="hevea_default968"></a>
<a id="hevea_default969"></a></p><p>In senso stretto, una funzione può restituire un solo valore di ritorno, ma se il valore è una tupla, l’effetto pratico è quello di restituire valori molteplici. Per esempio, se volete dividere due interi e calcolare quoziente e resto, è poco efficiente calcolare <span class="c003">x/y</span> e poi <span class="c003">x%y</span>. Meglio calcolarli entrambi in una volta sola.
<a id="hevea_default970"></a></p><p>La funzione predefinita <span class="c003">divmod</span> riceve due argomenti e restituisce una tupla di due valori, il quoziente e il resto. E potete memorizzare il risultato con una tupla:</p><pre class="verbatim">&gt;&gt;&gt; t = divmod(7, 3)
&gt;&gt;&gt; t
(2, 1)
</pre><p>
Oppure, usate l’assegnazione di tupla per conservare gli elementi separatamente:
<a id="hevea_default971"></a>
<a id="hevea_default972"></a></p><pre class="verbatim">&gt;&gt;&gt; quoziente, resto = divmod(7, 3)
&gt;&gt;&gt; quoziente
2
&gt;&gt;&gt; resto
1
</pre><p>
Ecco un esempio di funzione che restituisce una tupla:</p><pre class="verbatim">def min_max(t):
    return min(t), max(t)
</pre><p>
<span class="c003">max</span> e <span class="c003">min</span> sono funzioni predefinite che estraggono da una sequenza il valore massimo e quello minimo. <code>min_max</code> li estrae entrambi e restituisce una tupla di due valori.
<a id="hevea_default973"></a>
<a id="hevea_default974"></a>
<a id="hevea_default975"></a>
<a id="hevea_default976"></a></p>
<!--TOC section id="sec147" Tuple di argomenti a lunghezza variabile-->
<h2 class="section" id="sec147">12.4  Tuple di argomenti a lunghezza variabile</h2><!--SEC END --><p>
<a id="gather"></a>
<a id="hevea_default977"></a>
<a id="hevea_default978"></a>
<a id="hevea_default979"></a>
<a id="hevea_default980"></a>
<a id="hevea_default981"></a></p><p>Le funzioni possono ricevere un numero variabile di argomenti. Un nome di parametro che comincia con <span class="c003">*</span>, <span class="c009">raccoglie</span> gli argomenti in una tupla. Per esempio, <span class="c003">stampatutti</span> riceve un qualsiasi numero di argomenti e li visualizza:</p><pre class="verbatim">def stampatutti(*args):
    print(args)
</pre><p>
Il parametro di raccolta può avere qualunque nome, ma per convenzione si usa <span class="c003">args</span>. Ecco come funziona:</p><pre class="verbatim">&gt;&gt;&gt; stampatutti(1, 2.0, '3')
(1, 2.0, '3')
</pre><p>
Il contrario della raccolta è lo <span class="c009">spacchettamento</span>. Se avete una sequenza di valori e volete passarla a una funzione come argomenti multipli, usate ancora
l’operatore <span class="c003">*</span>. Per esempio, <span class="c003">divmod</span> richiede esattamente due argomenti; passare una tupla non funziona:
<a id="hevea_default982"></a>
<a id="hevea_default983"></a>
<a id="hevea_default984"></a>
<a id="hevea_default985"></a></p><pre class="verbatim">&gt;&gt;&gt; t = (7, 3)
&gt;&gt;&gt; divmod(t)
TypeError: divmod expected 2 arguments, got 1
</pre><p>
Ma se spacchettate la tupla, funziona:</p><pre class="verbatim">&gt;&gt;&gt; divmod(*t)
(2, 1)
</pre><p>Molte funzioni predefinite possono usare le tuple di argomenti a lunghezza variabile. Ad esempio, <span class="c003">max</span> e <span class="c003">min</span> ricevono un numero qualunque di argomenti:
<a id="hevea_default986"></a>
<a id="hevea_default987"></a>
<a id="hevea_default988"></a>
<a id="hevea_default989"></a></p><pre class="verbatim">&gt;&gt;&gt; max(1,2,3)
3
</pre><p>
Ma con <span class="c003">sum</span> non funziona.
<a id="hevea_default990"></a>
<a id="hevea_default991"></a></p><pre class="verbatim">&gt;&gt;&gt; sum(1,2,3)
TypeError: sum expected at most 2 arguments, got 3
</pre><p>
Per esercizio, scrivete una funzione di nome <span class="c003">sommatutto</span> che riceva un numero di argomenti a piacere e ne restituisca la somma.</p>
<!--TOC section id="sec148" Liste e tuple-->
<h2 class="section" id="sec148">12.5  Liste e tuple</h2><!--SEC END --><p>
<a id="hevea_default992"></a>
<a id="hevea_default993"></a></p><p><span class="c003">zip</span> è una funzione predefinita che riceve due o più sequenze e restituisce una lista di tuple, dove ciascuna tupla contiene un elemento di ciascuna sequenza. Il nome si riferisce alla cerniera-lampo (<em>zipper</em>), che unisce due file di dentelli, alternandoli.</p><p>Questo esempio abbina una stringa e una lista:</p><pre class="verbatim">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; t = [0, 1, 2]
&gt;&gt;&gt; zip(s, t)
&lt;zip object at 0x7f7d0a9e7c48&gt;
</pre><p>Il risultato è un <span class="c009">oggetto zip</span> capace di iterare attraverso le coppie. L’uso più frequente di <span class="c003">zip</span> è in un ciclo <span class="c003">for</span>:</p><pre class="verbatim">&gt;&gt;&gt; for coppia in zip(s, t):
...     print(coppia)
...
('a', 0)
('b', 1)
('c', 2)
</pre><p>
Un oggetto zip è un tipo di <span class="c009">iteratore</span>, che è un qualsiasi oggetto in grado di iterare attraverso una sequenza. Gli iteratori sono per certi versi simili alle liste, ma a differenza di queste ultime, non si può usare un indice per scegliere un elemento da un iteratore.
<a id="hevea_default994"></a></p><p>Se desiderate usare operatori e metodi delle liste, potete crearne una utilizzando un oggetto zip:</p><pre class="verbatim">&gt;&gt;&gt; list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]
</pre><p>
Il risultato è una lista di tuple, e in questo esempio ciascuna tupla contiene un carattere della stringa e il corrispondente elemento della lista.
<a id="hevea_default995"></a></p><p>Se le sequenze non sono della stessa lunghezza, il risultato ha la lunghezza di quella più corta:</p><pre class="verbatim">&gt;&gt;&gt; list(zip('Anna', 'Edo'))
[('A', 'E'), ('n', 'd'), ('n', 'o')]
</pre><p>
Potete usare l’assegnazione di tupla in un ciclo <span class="c003">for</span> per attraversare una lista di tuple:
<a id="hevea_default996"></a>
<a id="hevea_default997"></a>
<a id="hevea_default998"></a></p><pre class="verbatim">t = [('a', 0), ('b', 1), ('c', 2)]
for lettera, numero in t:
    print(numero, lettera)
</pre><p>
Ad ogni ciclo, Python seleziona la tupla successiva all’interno della lista e ne assegna gli elementi a <span class="c003">lettera</span> e <span class="c003">numero</span>, quindi li stampa. Il risultato di questo ciclo è:
<a id="hevea_default999"></a></p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
Se combinate <span class="c003">zip</span>, <span class="c003">for</span> e assegnazione di tupla, ottenete un utile costrutto per attraversare due o più sequenze contemporaneamente. Per esempio, <code>corrispondenza</code> prende due sequenze, <span class="c003">t1</span> e
<span class="c003">t2</span>, e restituisce <span class="c003">True</span> se esiste almeno un indice <span class="c003">i</span>
tale che <span class="c003">t1[i] == t2[i]</span>:
<a id="hevea_default1000"></a></p><pre class="verbatim">def corrispondenza(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
</pre><p>
Se volete attraversare gli elementi di una sequenza e i loro indici, potete usare la funzione predefinita <span class="c003">enumerate</span>:
<a id="hevea_default1001"></a>
<a id="hevea_default1002"></a>
<a id="hevea_default1003"></a></p><pre class="verbatim">for indice, elemento in enumerate('abc'):
    print(indice, elemento)
</pre><p>
Il risultato di <span class="c003">enumerate</span> è un oggetto enumerate, che itera una sequenza di coppie; ogni coppia contiene un indice (a partire da 0) e un elemento della sequenza data.
In questo esempio l’output è di nuovo:</p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
<a id="hevea_default1004"></a>
<a id="hevea_default1005"></a>
<a id="hevea_default1006"></a>
</p>
<!--TOC section id="sec149" Dizionari e tuple-->
<h2 class="section" id="sec149">12.6  Dizionari e tuple</h2><!--SEC END --><p>
<a id="dictuple"></a>
<a id="hevea_default1007"></a>
<a id="hevea_default1008"></a>
<a id="hevea_default1009"></a>
<a id="hevea_default1010"></a></p><p>I dizionari supportano un metodo di nome <span class="c003">items</span> che restituisce una sequenza di tuple, dove ogni tupla è una delle coppie chiave-valore.</p><pre class="verbatim">&gt;&gt;&gt; d = {'a':0, 'b':1, 'c':2}
&gt;&gt;&gt; t = d.items()
&gt;&gt;&gt; t
dict_items([('c', 2), ('a', 0), ('b', 1)])
</pre><p>
Il risultato è un oggetto <code>dict_items</code>, un iteratore che itera le coppie chiave-valore. Si può usare in un ciclo <span class="c003">for</span> in questo modo:
<a id="hevea_default1011"></a></p><pre class="verbatim">&gt;&gt;&gt; for chiave, valore in d.items():
...     print(chiave, valore)
...
c 2
a 0
b 1
</pre><p>Come di consueto per i dizionari, gli elementi non sono in un ordine particolare.
Per altro verso, potete usare una lista di tuple per inizializzare un nuovo dizionario: <a id="hevea_default1012"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [('a', 0), ('c', 2), ('b', 1)]
&gt;&gt;&gt; d = dict(t)
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>La combinazione di <span class="c003">dict</span> e <span class="c003">zip</span> produce un modo conciso di creare un dizionario:
<a id="hevea_default1013"></a></p><pre class="verbatim">&gt;&gt;&gt; d = dict(zip('abc', range(3)))
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>
Anche il metodo dei dizionari <span class="c003">update</span> prende una lista di tuple e le aggiunge, come coppie chiave-valore, a un dizionario esistente.
<a id="hevea_default1014"></a>
<a id="hevea_default1015"></a>
<a id="hevea_default1016"></a>
<a id="hevea_default1017"></a></p><p>L’uso delle tuple come chiavi di un dizionario è frequente (soprattutto perché le liste non si possono usare in quanto mutabili). Per esempio, un elenco telefonico può mappare da coppie di nomi e cognomi nei numeri di telefono. Supponendo di aver definito <span class="c003">cognome</span>, <span class="c003">nome</span> e <span class="c003">numero</span>, possiamo scrivere:
<a id="hevea_default1018"></a>
<a id="hevea_default1019"></a></p><pre class="verbatim">elenco[cognome,nome] = numero
</pre><p>
L’espressione tra parentesi quadre è una tupla. Possiamo usare l’assegnazione di tupla per attraversare questo dizionario.
<a id="hevea_default1020"></a></p><pre class="verbatim">for cognome, nome in elenco:
    print(nome, cognome, elenco[cognome,nome])
</pre><p>
Questo ciclo attraversa le chiavi in <span class="c003">elenco</span>, che sono tuple. Assegna gli elementi di ogni tupla a <span class="c003">cognome</span> e <span class="c003">nome</span>, quindi stampa il nome completo e il numero di telefono corrispondente.</p><p>Ci sono due modi per rappresentare le tuple in un diagramma di stato. La versione più dettagliata mostra gli indici e gli elementi così come compaiono in una lista. Per esempio la tupla <code>('Cleese', 'John')</code> comparirebbe come in Figura <a href="#fig.tuple1">12.1</a>.
<a id="hevea_default1021"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian018.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 12.1: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.tuple1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Ma in un diagramma più ampio è meglio tralasciare i dettagli. Per esempio, quello dell’elenco telefonico può essere come in Figura <a href="#fig.dict2">12.2</a>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian019.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 12.2: Diagramma di stato.</td></tr>
</table></div>
<a id="fig.dict2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Qui le tuple sono mostrate usando la sintassi di Python come abbreviazione grafica. Il numero di telefono nel diagramma è quello dei reclami della BBC, per cui vi prego, non chiamatelo.</p>
<!--TOC section id="sec150" Sequenze di sequenze-->
<h2 class="section" id="sec150">12.7  Sequenze di sequenze</h2><!--SEC END --><p>
<a id="hevea_default1022"></a></p><p>Ci siamo concentrati finora sulle liste di tuple, ma quasi tutti gli esempi di questo capitolo funzionano anche con liste di liste, tuple di tuple, e tuple di liste. Per evitare di elencare tutte le possibili combinazioni, è più semplice usare il termine sequenze di sequenze.</p><p>In molti casi, i diversi tipi di sequenze (strighe, liste, tuple) possono essere intercambiabili. E allora, con che criterio usarne una piuttosto di un’altra?
<a id="hevea_default1023"></a>
<a id="hevea_default1024"></a>
<a id="hevea_default1025"></a>
<a id="hevea_default1026"></a>
<a id="hevea_default1027"></a></p><p>Le stringhe sono ovviamente le più limitate, perché gli elementi devono essere dei caratteri. E sono anche immutabili. Se dovete cambiare i caratteri in una stringa, anziché crearne una nuova, utilizzare una lista di caratteri può essere una scelta migliore.</p><p>Le liste sono usate più di frequente delle tuple, soprattutto perché sono mutabili. Ma ci sono alcuni casi in cui le tuple sono preferibili:</p><ol class="enumerate" type=1><li class="li-enumerate">In certi contesti, come un’istruzione <span class="c003">return</span>, è sintatticamente più semplice creare una tupla anziché una lista.</li><li class="li-enumerate">Se vi serve una sequenza da usare come chiave di un dizionario, dovete per forza usare un tipo immutabile come una tupla o una stringa.</li><li class="li-enumerate">Se state passando una sequenza come argomento a una funzione, usare le tuple riduce le possibilità di comportamenti imprevisti dovuti agli alias.</li></ol><p>Siccome le tuple sono immutabili, non possiedono metodi come <span class="c003">sort</span> e <span class="c003">reverse</span>, che modificano delle liste esistenti.
Però Python contiene la funzione <span class="c003">sorted</span>, che richiede una sequenza e restituisce una nuova lista con gli stessi elementi della sequenza, ordinati, e <span class="c003">reversed</span>, che prende una sequenza e restituisce un iteratore che attraversa la lista in ordine inverso.
<a id="hevea_default1028"></a>
<a id="hevea_default1029"></a>
<a id="hevea_default1030"></a>
<a id="hevea_default1031"></a>
<a id="hevea_default1032"></a></p>
<!--TOC section id="sec151" Debug-->
<h2 class="section" id="sec151">12.8  Debug</h2><!--SEC END --><p>
<a id="hevea_default1033"></a>
<a id="hevea_default1034"></a>
<a id="hevea_default1035"></a>
<a id="hevea_default1036"></a></p><p>Liste, dizionari e tuple sono esempi di <span class="c009">strutture di dati</span>; in questo capitolo abbiamo iniziato a vedere strutture di dati composte, come liste di tuple, o dizionari che contengono tuple come chiavi e liste come valori. Si tratta di elementi utili, ma soggetti a quelli che io chiamo <span class="c003">errori di formato</span>; cioè errori causati dal fatto che una struttura di dati è di tipo, dimensione o struttura sbagliati. Ad esempio, se un programma si aspetta una lista che contiene un numero intero e invece gli passate un intero puro e semplice (non incluso in una lista), non funzionerà.
<a id="hevea_default1037"></a>
<a id="hevea_default1038"></a></p><p>Per facilitare il debug di questo genere di errori, ho scritto un modulo di nome <span class="c003">structshape</span> che contiene una funzione, anch’essa di nome
<span class="c003">structshape</span>, che riceve come argomento una qualunque struttura di dati e restituisce una stringa che ne riassume il formato. Potete scaricarlo dal sito <a href="http://thinkpython2.com/code/structshape.py"><span class="c003">http://thinkpython2.com/code/structshape.py</span></a></p><p>Questo è il risultato per una lista semplice:</p><pre class="verbatim">&gt;&gt;&gt; from structshape import structshape
&gt;&gt;&gt; t = [1,2,3]
&gt;&gt;&gt; structshape(t)
'list of 3 int'
</pre><p>
Un programma più aggraziato avrebbe scritto “list of 3 int<em>s</em>”, ma è più semplice non avere a che fare con i plurali. Ecco una lista di liste:</p><pre class="verbatim">&gt;&gt;&gt; t2 = [[1,2], [3,4], [5,6]]
&gt;&gt;&gt; structshape(t2)
'list of 3 list of 2 int'
</pre><p>
Se gli elementi della lista non sono dello stesso tipo,
<span class="c003">structshape</span> li raggruppa, in ordine, per tipo:</p><pre class="verbatim">&gt;&gt;&gt; t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
&gt;&gt;&gt; structshape(t3)
'list of (3 int, float, 2 str, 2 list of int, int)'
</pre><p>
Ecco una lista di tuple:</p><pre class="verbatim">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; lt = zip(list(t, s))
&gt;&gt;&gt; structshape(lt)
'list of 3 tuple of (int, str)'
</pre><p>
Ed ecco un dizionario di 3 elementi in cui corrispondono interi a stringhe</p><pre class="verbatim">&gt;&gt;&gt; d = dict(lt) 
&gt;&gt;&gt; structshape(d)
'dict of 3 int-&gt;str'
</pre><p>
Se fate fatica a tenere sotto controllo le vostre strutture di dati,
<span class="c003">structshape</span> può esservi di aiuto.</p>
<!--TOC section id="sec152" Glossario-->
<h2 class="section" id="sec152">12.9  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">tupla:</span></dt><dd class="dd-description"> Una sequenza di elementi immutabile.
<a id="hevea_default1039"></a></dd><dt class="dt-description"><span class="c009">assegnazione di tupla:</span></dt><dd class="dd-description"> Assegnazione costituita da una sequenza sul lato destro e una tupla di variabili su quello sinistro. Il lato destro viene valutato, quindi gli elementi vengono assegnati alle variabili sulla sinistra.
<a id="hevea_default1040"></a>
<a id="hevea_default1041"></a></dd><dt class="dt-description"><span class="c009">raccolta:</span></dt><dd class="dd-description"> L’operazione di assemblare una tupla di argomenti a lunghezza variabile.
<a id="hevea_default1042"></a></dd><dt class="dt-description"><span class="c009">spacchettamento:</span></dt><dd class="dd-description"> L’operazione di trattare una sequenza come una lista di argomenti.
<a id="hevea_default1043"></a></dd><dt class="dt-description"><span class="c009">oggetto zip:</span></dt><dd class="dd-description"> Il risultato della chiamata della funzione predefinita <span class="c003">zip</span>; un oggetto che itera attraverso una sequenza di tuple.
<a id="hevea_default1044"></a>
<a id="hevea_default1045"></a></dd><dt class="dt-description"><span class="c009">iteratore:</span></dt><dd class="dd-description"> Un oggetto in grado di iterare attraverso una sequenza, ma che non fornisce operatori e metodi delle liste.
<a id="hevea_default1046"></a></dd><dt class="dt-description"><span class="c009">struttura di dati:</span></dt><dd class="dd-description"> Una raccolta di valori correlati, spesso organizzati in liste, dizionari, tuple, ecc.
<a id="hevea_default1047"></a></dd><dt class="dt-description"><span class="c009">errore di formato:</span></dt><dd class="dd-description"> Errore dovuto ad un valore che ha un formato sbagliato, ovvero tipo o dimensioni errati.
<a id="hevea_default1048"></a></dd></dl>
<!--TOC section id="sec153" Esercizi-->
<h2 class="section" id="sec153">12.10  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete una funzione di nome <code>piu_frequente</code> che riceva una stringa e stampi le lettere in ordine di frequenza decrescente. Trovate delle frasi di esempio in diverse lingue e osservate come varia la frequenza delle lettere. Confrontate i vostri risultati con le tabelle del sito
</em><a href="http://en.wikipedia.org/wiki/Letter_frequencies"><span class="c003"><em>http://en.wikipedia.org/wiki/Letter_frequencies</em></span></a><em>. Soluzione:
</em><a href="http://thinkpython2.com/code/most_frequent.py"><span class="c003"><em>http://thinkpython2.com/code/most_frequent.py</em></span></a><em>. 
</em><a id="hevea_default1049"></a> 
<a id="hevea_default1050"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="anagrams"></a>
<a id="hevea_default1051"></a>
<a id="hevea_default1052"></a><p><em>Ancora anagrammi!</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete un programma che legga un elenco di parole da un file (vedi Paragrafo </em><a href="#wordlist"><em>9.1</em></a><em>) e stampi tutti gli insiemi di parole che sono tra loro anagrammabili.</em><p><em>Un esempio di come si può presentare il risultato:</em></p><pre class="verbatim"><em>['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
</em></pre><p><em>
Suggerimento: potete costruire un dizionario che faccia corrispondere un gruppo di lettere con una lista di parole che si possono scrivere con quelle lettere. Il problema è: come rappresentare il gruppo di lettere in modo che possano essere usate come chiave?</em></p></li><li class="li-enumerate"><em>Modificate il programma in modo che stampi la lista di anagrammi più lunga per prima, seguita dalla seconda più lunga, e così via.
</em><a id="hevea_default1053"></a></li><li class="li-enumerate"><em>Nel gioco da tavolo </em>Scarabeo<em>, fate un “en-plein” quando giocate tutte le sette lettere sul vostro leggio formando, insieme a una lettera sul tavolo, una parola di otto lettere. Con quale gruppo di 8 lettere si può fare un “en-plein” con maggior probabilità?
Suggerimento: il gruppo dà sette combinazioni.</em><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/anagram_sets.py"><span class="c003"><em>http://thinkpython2.com/code/anagram_sets.py</em></span></a><em>.</em></p></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default1054"></a><p><em>Si ha una metatesi quando una parola si può ottenere scambiando due lettere di un’altra parola, per esempio: “conversa” e “conserva”. Scrivete un programma che trovi tutte le coppie con metatesi nel dizionario. Suggerimento: non provate tutte le possibili coppie di parole e non provate tutti i possibili scambi. Soluzione: </em><a href="http://thinkpython2.com/code/metathesis.py"><em><span class="c003">http://thinkpython2.com/code/metathesis.py</span></em></a><em>.
Fonte: Esercizio suggerito da un esempio nel sito </em><a href="http://puzzlers.org"><em><span class="c003">http://puzzlers.org</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  
<a id="hevea_default1055"></a>
<a id="hevea_default1056"></a><p><em>Ed ecco un altro quesito di Car Talk:
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c003">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
Qual è la più lunga parola inglese che rimane una parola valida se le togliete una lettera alla volta? 
Le lettere possono essere rimosse sia agli estremi o in mezzo, ma senza spostare le lettere rimanenti. Ogni volta che togliete una lettera, ottenete un’altra parola inglese. Se andate avanti, ottenete un’altra parola. Ora, voglio sapere qual è la parola più lunga possibile e quante lettere ha.</em><p><em>Vi faccio un piccolo esempio: Sprite. Partite da sprite, togliete una lettera, una interna, come la r e resta la parola spite, poi togliete la e finale e avete spit, togliamo la s e resta pit, poi it, infine I.
</em></p></blockquote><p>
<a id="hevea_default1057"></a></p><p><em>Scrivete un programma che trovi tutte le parole che sono riducibili in questa maniera, quindi trovate la più lunga.</em></p><p><em>Questo esercizio è un po’ più impegnativo degli altri, quindi eccovi alcuni suggerimenti:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Potete scrivere una funzione che prenda una parola e calcoli una lista di tutte le parole che si possono formare togliendo una lettera. Queste sono le “figlie” della parola.
</em><a id="hevea_default1058"></a></li><li class="li-enumerate"><em>Ricorsivamente, una parola è riducibile se qualcuna delle sue figlie è a sua volta riducibile. Come caso base, potete considerare riducibile la stringa vuota.</em></li><li class="li-enumerate"><em>L’elenco di parole che ho fornito, <span class="c003">words.txt</span>, non contiene parole di una lettera. Potete quindi aggiungere “I”, “a”, e la stringa vuota.</em></li><li class="li-enumerate"><em>Per migliorare le prestazioni del programma, potete memoizzare le parole che sono risultate riducibili.</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/reducible.py"><em><span class="c003">http://thinkpython2.com/code/reducible.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec154" Esercitazione: Scelta della struttura di dati-->
<h1 class="chapter" id="sec154">Chapter 13  Esercitazione: Scelta della struttura di dati</h1><!--SEC END --><p>Giunti a questo punto, avete conosciuto le principali strutture di dati di Python, e avete visto alcuni algoritmi che le utilizzano. Se vi interessa saperne di più sugli algoritmi, potrebbe essere un buon momento per leggere l’Appendice <a href="#algorithms">B</a>.
Non è però necessario per proseguire la lettura: fatelo quando vi pare opportuno.</p><p>L’esercitazione di questo capitolo vi aiutèrà ad impratichirvi nella scelta e nell’uso delle strutture di dati.</p>
<!--TOC section id="sec155" Analisi di frequenza delle parole-->
<h2 class="section" id="sec155">13.1  Analisi di frequenza delle parole</h2><!--SEC END --><p>
<a id="analysis"></a></p><p>Come al solito, tentate almeno di risolvere gli esercizi prima di guardare le mie risoluzioni.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete un programma che legga un file di testo, separi da ogni riga le singole parole, scarti gli spazi bianchi e la punteggiatura dalle parole, e converta tutto in lettere minuscole.
</em><a id="hevea_default1059"></a>
<a id="hevea_default1060"></a></p><p><em>Suggerimento: il modulo <span class="c003">string</span> fornisce una stringa chiamata <span class="c003">whitespace</span>, che contiene i caratteri spaziatori come spazio, tabulazione, a capo ecc., e una di nome <span class="c003">punctuation</span> che contiene i caratteri di punteggiatura. Vediamo se Python ce lo conferma:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; import string
&gt;&gt;&gt; string.punctuation
'!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~'
</em></pre><p><em>
Potete anche fare uso dei metodi delle stringhe <span class="c003">strip</span>,
<span class="c003">replace</span> e <span class="c003">translate</span>.
</em><a id="hevea_default1061"></a>
<a id="hevea_default1062"></a>
<a id="hevea_default1063"></a>
<a id="hevea_default1064"></a>
<a id="hevea_default1065"></a>
<a id="hevea_default1066"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default1067"></a><p><em>Andate sul sito del Progetto Gutenberg (</em><a href="http://gutenberg.org"><em><span class="c003">http://gutenberg.org</span></em></a><em>) e scaricate il libro fuori copyright che preferite, in formato di testo semplice.
</em><a id="hevea_default1068"></a></p><p><em>Modificate il programma dell’esercizio precedente in modo che legga il libro da voi scaricato, salti le informazioni di intestazione all’inizio del file, ed elabori il resto come sopra.</em></p><p><em>Quindi modificate il programma in modo che conti il numero di parole totale del libro, e quante volte è usata ciascuna parola.
</em><a id="hevea_default1069"></a>
<a id="hevea_default1070"></a></p><p><em>Visualizzate il numero di parole diverse usate nel libro. Confrontate libri diversi di diversi autori, scritti in epoche diverse. Quale autore usa il vocabolario più ricco?
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  <p><em>Modificate il programma dell’esercizio precedente in modo da visualizzare le 20 parole più usate nel libro.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Modificate il programma precedente in modo che acquisisca un elenco di parole (vedi Paragrafo </em><a href="#wordlist"><em>9.1</em></a><em>) e quindi stampi l’elenco delle parole contenute nel libro che non sono presenti nell’elenco di parole. Quante di esse sono errori di stampa? Quante sono parole comuni che </em>dovrebbero<em> essere nell’elenco, e quante sono del tutto oscure?</em></p></div>
<!--TOC section id="sec156" Numeri casuali-->
<h2 class="section" id="sec156">13.2  Numeri casuali</h2><!--SEC END --><p>
<a id="hevea_default1071"></a>
<a id="hevea_default1072"></a>
<a id="hevea_default1073"></a></p><p>A parità di dati in ingresso, la maggior parte dei programmi genera gli stessi risultati ad ogni esecuzione, e per questo motivo sono detti deterministici. Di solito il determinismo è una cosa giusta, poiché è ovvio attendersi che gli stessi dati producano gli stessi risultati. Per certe applicazioni, tuttavia, è richiesto che l’elaboratore sia imprevedibile: i videogiochi sono un classico esempio, ma ce ne sono anche altri.</p><p>Creare un programma realmente non-deterministico è una cosa piuttosto difficile, ma ci sono dei sistemi per renderlo almeno apparentemente non-deterministico. Uno di questi è utilizzare degli algoritmi che generano dei numeri <span class="c009">pseudocasuali</span>. Questi numeri non sono veri numeri casuali, dato che sono generati da un elaboratore deterministico, ma a prima vista è praticamente impossibile distinguerli da numeri casuali.
<a id="hevea_default1074"></a>
<a id="hevea_default1075"></a></p><p>Il modulo <span class="c003">random</span> contiene delle funzioni che generano numeri pseudocasuali (d’ora in avanti chiamati “casuali” per semplicità).
<a id="hevea_default1076"></a>
<a id="hevea_default1077"></a></p><p>La funzione <span class="c003">random</span> restituisce un numero casuale in virgola mobile compreso nell’intervallo tra 0.0 e 1.0 (incluso 0.0 ma escluso 1.0). Ad ogni chiamata di <span class="c003">random</span>, si ottiene il numero successivo di una lunga serie di numeri casuali. Per vedere un esempio provate ad eseguire questo ciclo:</p><pre class="verbatim">import random

for i in range(10):
    x = random.random()
    print(x)
</pre><p>
La funzione <span class="c003">randint</span> richiede due parametri interi, uno <span class="c003">inferiore</span> e uno <span class="c003">superiore</span>, e restituisce un intero casuale nell’intervallo tra i due parametri (entrambi compresi)
<a id="hevea_default1078"></a>
<a id="hevea_default1079"></a></p><pre class="verbatim">&gt;&gt;&gt; random.randint(5, 10)
5
&gt;&gt;&gt; random.randint(5, 10)
9
</pre><p>
Per estrarre un elemento a caso da una sequenza, potete usare
<span class="c003">choice</span>:
<a id="hevea_default1080"></a>
<a id="hevea_default1081"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; random.choice(t)
2
&gt;&gt;&gt; random.choice(t)
3
</pre><p>
Il modulo <span class="c003">random</span> contiene anche delle funzioni per generare valori pseudocasuali da distribuzioni continue, incluse gaussiane, esponenziali, gamma, e alcune altre.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  
<a id="hevea_default1082"></a><p><em>Scrivete una funzione di nome <code>estrai_da_isto</code> che prenda un istogramma come definito nel Paragrafo </em><a href="#histogram"><em>11.2</em></a><em> e restituisca un valore casuale dall’istogramma, scelto in modo che la probabilità sia proporzionale alla frequenza. Per esempio, dato questo istogramma:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = ['a', 'a', 'b']
&gt;&gt;&gt; isto = istogramma(t)
&gt;&gt;&gt; isto
{'a': 2, 'b': 1}
</em></pre><p><em>
la vostra funzione dovrebbe restituire <code>'a'</code> con probabilità </em>2/3<em> e <code>'b'</code> con probabilità </em>1/3<em>.
</em></p></div>
<!--TOC section id="sec157" Istogramma di parole-->
<h2 class="section" id="sec157">13.3  Istogramma di parole</h2><!--SEC END --><p>Provate a risolvere gli esercizi precedenti prima di procedere oltre. Le soluzioni sono scaricabili da
<a href="http://thinkpython2.com/code/analyze_book1.py"><span class="c003">http://thinkpython2.com/code/analyze_book1.py</span></a>. Vi servirà anche <a href="http://thinkpython2.com/code/emma.txt"><span class="c003">http://thinkpython2.com/code/emma.txt</span></a>.</p><p>Ecco un programma che legge un file e costruisce un istogramma della parole in esso contenute:
<a id="hevea_default1083"></a></p><pre class="verbatim">import string

def elabora_file(nomefile):
    isto = dict()
    fp = open(nomefile)
    for riga in fp:
        elabora_riga(riga, isto)
    return isto

def elabora_riga(riga, isto):
    riga = riga.replace('-', ' ')
    
    for parola in riga.split():
        parola = parola.strip(string.punctuation + string.whitespace)
        parola = parola.lower()
        isto[parola] = isto.get(parola, 0) + 1

isto = elabora_file('emma.txt')
</pre><p>
Questo programma legge il file <span class="c003">emma.txt</span>, che contiene il testo di <em>Emma</em> di Jane Austen.
<a id="hevea_default1084"></a></p><p><code>elabora_file</code> legge ciclicamente le righe del file, passandole una per volta a <code>elabora_riga</code>. L’istogramma <span class="c003">isto</span> viene usato come un accumulatore.
<a id="hevea_default1085"></a>
<a id="hevea_default1086"></a></p><p><code>elabora_riga</code> usa il metodo delle stringhe <span class="c003">replace</span> per sostituire i trattini con gli spazi, prima di usare <span class="c003">split</span> per suddividere la riga in una lista di stringhe. Attraversa poi la lista di parole e usa <span class="c003">strip</span>
e <span class="c003">lower</span> per togliere la punteggiatura e convertire in lettere minuscole. (Diciamo per semplicità che le stringhe sono “convertite”: essendo queste immutabili, i metodi come <span class="c003">strip</span> e <span class="c003">lower</span> in realtà restituiscono nuove stringhe).</p><p>Infine, <code>elabora_riga</code> aggiorna l’istogramma creando un nuovo elemento o incrementandone uno esistente.
<a id="hevea_default1087"></a></p><p>Per contare il numero di parole totali, possiamo aggiungere le frequenze nell’istogramma:</p><pre class="verbatim">def parole_totali(isto):
    return sum(isto.values())
</pre><p>
Il numero di parole diverse è semplicemente il numero di elementi nel dizionario:</p><pre class="verbatim">def parole_diverse(isto):
    return len(isto)
</pre><p>
Ed ecco del codice per stampare i risultati:</p><pre class="verbatim">print('Numero totale di parole:', parole_totali(isto))
print('Numero di parole diverse:', parole_diverse(isto))
</pre><p>
E i relativi risultati:</p><pre class="verbatim">Numero totale di parole: 161080
Numero di parole diverse: 7214
</pre>
<!--TOC section id="sec158" Parole più comuni-->
<h2 class="section" id="sec158">13.4  Parole più comuni</h2><!--SEC END --><p>Per trovare le parole più comuni, possiamo creare una lista di tuple, in cui ciascuna tupla contiene una parola e la sua frequenza, ed ordinarle:</p><p>La funzione seguente prende un istogramma e restituisce una lista di tuple parola-frequenza:</p><pre class="verbatim">def piu_comuni(isto):
    t = []
    for chiave, valore in isto.items():
        t.append((valore, chiave))

    t.sort(reverse=True)
    return t
</pre><p>
In ogni tupla, la frequenza compare per prima, quindi la lista risultante è ordinata per frequenza. Ecco un ciclo che stampa le dieci parole più comuni:</p><pre class="verbatim">t = piu_comuni(hist)
print('Le parole più comuni sono:')
for freq, parola in t[:10]:
    print(parola, freq, sep='\t')
</pre><p>
Ho usato l’argomento con nome <span class="c003">sep</span> per dire a <span class="c003">print</span> di usare un carattere di tabulazione come “separatore”, anziché uno spazio, in modo che la seconda colonna risulti allineata.
E questi sono i risultati nel caso di <em>Emma</em>:</p><pre class="verbatim">Le parole più comuni sono:
to      5242
the     5205
and     4897
of      4295
i       3191
a       3130
it      2529
her     2483
was     2400
she     2364
</pre><p>
Si potrebbe semplificare il codice utilizzando il parametro <span class="c003">key</span> della funzione <span class="c003">sort</span>. Se vi incuriosisce, leggete
<a href="https://wiki.python.org/moin/HowTo/Sorting"><span class="c003">https://wiki.python.org/moin/HowTo/Sorting</span></a>.</p>
<!--TOC section id="sec159" Parametri opzionali-->
<h2 class="section" id="sec159">13.5  Parametri opzionali</h2><!--SEC END --><p>
<a id="hevea_default1088"></a></p><p>Abbiamo già visto funzioni predefinite e metodi che ricevono argomenti opzionali. È possibile anche scrivere funzioni personalizzate con degli argomenti opzionali. Ad esempio, questa è una funzione che stampa le parole più comuni in un istogramma:
<a id="hevea_default1089"></a></p><pre class="verbatim">def stampa_piu_comuni(isto, num=10):
    t = piu_comuni(isto)
    print('Le parole più comuni sono:')
    for freq, parola in t[:num]:
        print(parola, freq, sep='\t')
</pre><p>Il primo parametro è obbligatorio; il secondo è opzionale. Il <span class="c009">valore di default</span> di <span class="c003">num</span> è 10.
<a id="hevea_default1090"></a></p><p>Se passate un solo argomento:</p><pre class="verbatim">stampa_piu_comuni(isto)
</pre><p><span class="c003">num</span> assume il valore predefinito. Se ne passate due:</p><pre class="verbatim">stampa_piu_comuni(isto, 20)
</pre><p><span class="c003">num</span> assume il valore che avete specificato. In altre parole, l’argomento opzionale <span class="c009">sovrascrive</span> il valore predefinito.
<a id="hevea_default1091"></a></p><p>Se una funzione ha sia parametri obbligatori che opzionali, tutti quelli obbligatori devono essere scritti per primi, seguiti da quelli opzionali.</p>
<!--TOC section id="sec160" Sottrazione di dizionari-->
<h2 class="section" id="sec160">13.6  Sottrazione di dizionari</h2><!--SEC END --><p>
<a id="dictsub"></a>
<a id="hevea_default1092"></a>
<a id="hevea_default1093"></a></p><p>Trovare le parole del libro non comprese nell’elenco <span class="c003">words.txt</span> è un problema che possiamo classificare come sottrazione di insiemi, cioè occorre trovare le parole appartenenti a un insieme (le parole contenute nel libro) che non si trovano nell’altro insieme (l’elenco).</p><p><span class="c003">sottrai</span> prende i dizionari <span class="c003">d1</span> e <span class="c003">d2</span> e ne restituisce uno nuovo che contiene tutte le chiavi di <span class="c003">d1</span> che non si trovano in <span class="c003">d2</span>. Siccome non ci interessano affatto i valori, li impostiamo tutti a None.</p><pre class="verbatim">def sottrai(d1, d2):
    res = dict()
    for chiave in d1:
        if chiave not in d2:
            res[chiave] = None
    return res
</pre><p>
Quindi usiamo <code>elabora_file</code> per costruire un istogramma di
<span class="c003">words.txt</span>, per poi sottrarre:</p><pre class="verbatim">parole = elabora_file('words.txt')
diff = sottrai(isto, parole)

print('Parole del libro che non si trovano nell'elenco:')
for parola in diff:
    print(parola, end=' ')
</pre><p>
Ecco alcuni risultati per <em>Emma</em>:</p><pre class="verbatim">Parole del libro che non si trovano nell'elenco:
 rencontre jane's blanche woodhouses disingenuousness 
friend's venice apartment ...
</pre><p>
Alcune parole sono nomi propri e possessivi. Altre come “rencontre” sono desuete. Ma qualcuna è davvero una parola comune che nell’elenco dovrebbe esserci!</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  
<a id="hevea_default1094"></a>
<a id="hevea_default1095"></a><p><em>Python dispone di una struttura di dati chiamata <span class="c003">set</span>, o insieme, che fornisce molte operazioni comuni sugli insiemi. Al riguardo, potete leggere il Paragrafo </em><a href="#sets"><em>19.5</em></a><em> o la documentazione sul sito 
</em><a href="http://docs.python.org/3/library/stdtypes.html#types-set"><span class="c003"><em>http://docs.python.org/3/library/stdtypes.html#types-set</em></span></a><em>. </em></p><p><em>Scrivete un programma che usi la sottrazione di insiemi per trovare le parole del libro che non sono nell’elenco. Soluzione:
</em><a href="http://thinkpython2.com/code/analyze_book2.py"><em><span class="c003">http://thinkpython2.com/code/analyze_book2.py</span></em></a><em>.</em></p></div>
<!--TOC section id="sec161" Parole a caso-->
<h2 class="section" id="sec161">13.7  Parole a caso</h2><!--SEC END --><p>
<a id="randomwords"></a>
<a id="hevea_default1096"></a></p><p>Per scegliere una parola a caso dall’istogramma, l’algoritmo più semplice è costruire una lista che contiene più copie di ciascuna parola, secondo la frequenza osservata, e poi estrarre a caso da questa lista:</p><pre class="verbatim">def parola_caso(h):
    t = []
    for parola, freq in h.items():
        t.extend([parola] * freq)

    return random.choice(t)
</pre><p>
L’espressione <span class="c003">[parola] * freq</span> crea una lista con <span class="c003">freq</span>
copie della stringa <span class="c003">parola</span>. Il metodo <span class="c003">extend</span>
è simile a <span class="c003">append</span>, con la differenza che l’argomento è una sequenza.</p><p>Questo algoritmo funziona, ma non è molto efficiente: ogni volta che estraete una parola, ricostruisce la lista, che è grande come il libro originale. Un ovvio miglioramento è di costruire la lista una sola volta e poi fare estrazioni multiple, ma la lista è ancora grande.</p><p>Un’alternativa è:</p><ol class="enumerate" type=1><li class="li-enumerate">Usare <span class="c003">keys</span> per ottenere una lista delle parole del libro.</li><li class="li-enumerate">Costruire una lista che contiene la somma cumulativa delle frequenze delle parole (vedere l’Esercizio <a href="#cumulative">2</a>). L’ultimo elemento della lista è il numero totale delle parole nel libro, <span class="c008">n</span>.</li><li class="li-enumerate">Scegliere un numero a caso da 1 a <span class="c008">n</span>. Usare una ricerca binaria
(vedere l’Esercizio <a href="#bisection">10</a>) per trovare l’indice dove il numero casuale si inserirebbe nella somma cumulativa.</li><li class="li-enumerate">Usare l’indice per trovare la parola corrispondente nella lista di parole.</li></ol><p><br>

</p><div class="theorem"><span class="c009">Esercizio 7</span>  
<a id="randhist"></a>
<a id="hevea_default1097"></a><p><em>Scrivete un programma che usi questo algoritmo per scegliere una parola a caso dal libro. Soluzione: </em><a href="http://thinkpython2.com/code/analyze_book3.py"><em><span class="c003">http://thinkpython2.com/code/analyze_book3.py</span></em></a><em>.</em></p></div>
<!--TOC section id="sec162" Analisi di Markov-->
<h2 class="section" id="sec162">13.8  Analisi di Markov</h2><!--SEC END --><p>
<a id="markov"></a>
<a id="hevea_default1098"></a></p><p>Scegliendo a caso delle parole dal libro, potete avere un’idea del vocabolario usato dall’autore, ma difficilmente otterrete una frase di senso compiuto:</p><pre class="verbatim">this the small regard harriet which knightley's it most things
</pre><p>
Una serie di parole estratte a caso raramente hanno senso, perché non esistono relazioni tra parole successive. In una frase, per esempio, è prevedibile che ad un articolo come “il” segua un aggettivo o un sostantivo, ma non un verbo o un avverbio.</p><p>Un modo per misurare questo tipo di relazioni è l’analisi di Markov che, per una data sequenza di parole, descrive la probabilità della parola che potrebbe seguire. Prendiamo la canzone dei Monty Python <em>Eric, the Half a Bee</em> che comincia così:</p><blockquote class="quote">
Half a bee, philosophically, <br>
Must, ipso facto, half not be. <br>
But half the bee has got to be <br>
Vis a vis, its entity. D’you see? <br>
<br>
But can a bee be said to be <br>
Or not to be an entire bee <br>
When half the bee is not a bee <br>
Due to some ancient injury? <br>
</blockquote><p>
In questo testo, la frase “half the” è sempre seguita dalla parola “bee,”
ma la frase “the bee” può essere seguita sia da
“has” che da “is”.
<a id="hevea_default1099"></a>
<a id="hevea_default1100"></a>
<a id="hevea_default1101"></a></p><p>Il risultato dell’analisi di Markov è una mappatura da ciascun prefisso
(come “half the” e “the bee”) in tutti i possibili suffissi (come “has” e “is”).
<a id="hevea_default1102"></a></p><p>Eseguita questa mappatura, potete generare un testo casuale partendo da qualunque prefisso e scegliendo a caso uno dei possibili suffissi. Poi, potete combinare la fine del prefisso e il nuovo suffisso per formare il successivo prefisso, e ripetere l’operazione.</p><p>Ad esempio, se partite con il prefisso “Half a,” la parola successiva sarà senz’altro “bee,” perché il prefisso compare solo una volta nel testo. Il prefisso successivo sarà “a bee,” quindi il suffisso successivo potrà essere “philosophically”, “be” oppure “due”.</p><p>In questo esempio, la lunghezza del prefisso è sempre di due parole, ma potete fare l’analisi di Markov con prefissi di qualunque lunghezza.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 8</span>  <p><em>Analisi di Markov:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete un programma che legga un testo da un file ed esegua l’analisi di Markov. Il risultato dovrebbe essere un dizionario che fa corrispondere i prefissi a una raccolta di possibili suffissi. La raccolta può essere una lista, tupla o dizionario: a voi valutare la scelta più appropriata. Potete testare il vostro programma con una lunghezza del prefisso di due parole, ma dovreste scrivere il programma in modo da poter provare facilmente anche lunghezze superiori.</em></li><li class="li-enumerate"><em>Aggiungete una funzione al programma precedente per generare un testo casuale basato sull’analisi di Markov. Ecco un esempio tratto da </em>Emma<em> con prefisso di lunghezza 2: </em><blockquote class="quote"><em>
He was very clever, be it sweetness or be angry, ashamed or only
amused, at such a stroke. She had never thought of Hannah till you
were never meant for me?" "I cannot make speeches, Emma:" he soon cut
it all himself.
</em></blockquote><p><em>In questo esempio, ho lasciato la punteggiatura attaccata alle parole. Il risultato sintatticamente è quasi accettabile, ma non del tutto. Semanticamente, è quasi sensato, ma non del tutto.</em></p><p><em>Cosa succede se aumentate la lunghezza del prefisso? Il testo casuale è più sensato?</em></p></li><li class="li-enumerate"><em>Ottenuto un programma funzionante, potete tentare un “minestrone”: se combinate testi presi da due o più libri, il testo generato mescolerà il vocabolario e le frasi dei sorgenti in modi interessanti.
</em><a id="hevea_default1103"></a></li></ol><p><em>Fonte: Questa esercitazione è tratta da un esempio in Kernighan e
Pike, </em>The Practice of Programming<em>, Addison-Wesley, 1999.</em></p></div><p>Cercate di svolgere questo esercizio prima di andare oltre; poi potete scaricare la mia soluzione dal sito <a href="http://thinkpython2.com/code/markov.py"><span class="c003">http://thinkpython2.com/code/markov.py</span></a>. Vi servirà anche <a href="http://thinkpython2.com/code/emma.txt"><span class="c003">http://thinkpython2.com/code/emma.txt</span></a>.</p>
<!--TOC section id="sec163" Strutture di dati-->
<h2 class="section" id="sec163">13.9  Strutture di dati</h2><!--SEC END --><p>
<a id="hevea_default1104"></a></p><p>Utilizzare l’analisi di Markov per generare testi casuali è divertente, ma c’è anche un obiettivo in questo esercizio: la scelta della struttura di dati. Per risolverlo, dovevate infatti scegliere:</p><ul class="itemize"><li class="li-itemize">Come rappresentare i prefissi.</li><li class="li-itemize">Come rappresentare la raccolta di possibili suffissi.</li><li class="li-itemize">Come rappresentare la mappatura da ciascun prefisso nella raccolta di suffissi.</li></ul><p>L’ultima è facile: un dizionario è la scelta scontata per mappare da chiavi nei corrispondenti valori.</p><p>Per i prefissi, le possibili scelte sono: stringa, lista di stringhe o tuple di stringhe. Per i suffissi, un’opzione è una lista, l’altra è un istogramma (cioè un dizionario).
<a id="hevea_default1105"></a></p><p>Quale scegliere? Per prima cosa dovete chiedervi quali tipi di operazione dovete implementare per ciascuna struttura di dati. Per i prefissi, ci serve poter rimuovere le parole all’inizio e aggiungerne in coda. Per esempio, se il prefisso attuale è “Half a,” e la parola successiva è “bee,” dobbiamo essere in grado di formare il prefisso successivo, “a bee”.
<a id="hevea_default1106"></a></p><p>La prima ipotesi allora potrebbe essere una lista, dato che permette di aggiungere e rimuovere elementi in modo semplice, tuttavia abbiamo anche bisogno di usare i prefissi come chiavi di un dizionario, cosa che esclude le liste. Con le tuple non possiamo aggiungere o rimuovere, ma possiamo sempre usare l’operatore di addizione per formare una nuova tupla:</p><pre class="verbatim">def cambia(prefisso, parola):
    return prefisso[1:] + (parola,)
</pre><p>
<span class="c003">cambia</span> prende una tupla di parole, <span class="c003">prefisso</span>, e una stringa, 
<span class="c003">parola</span>, e forma una nuova tupla che comprende tutte le parole
in <span class="c003">prefisso</span> tranne la prima, e <span class="c003">parola</span> aggiunta alla fine.</p><p>Per la raccolta di suffissi, le operazioni che dobbiamo eseguire comprendono l’aggiunta di un nuovo suffisso (o l’incremento della frequenza di un suffisso esistente) e l’estrazione di un elemento a caso.</p><p>Aggiungere un nuovo suffisso è ugualmente semplice sia nel caso di implementazione di una lista sia di un istogramma. Estrarre un elemento da una lista è facile, da un istogramma difficile da fare in modo efficiente (vedere Esercizio <a href="#randhist">7</a>).</p><p>Sinora abbiamo considerato soprattutto la facilità di implementazione, ma ci sono altri fattori da tenere in considerazione nella scelta delle strutture di dati. Una è il tempo di esecuzione. A volte ci sono ragioni teoriche per attendersi che una struttura sia più veloce di un’altra; per esempio ho già accennato che l’operatore <span class="c003">in</span> è più rapido nei dizionari che non nelle liste, almeno in presenza di un gran numero di elementi.</p><p>Ma spesso non è possibile sapere <em>a priori</em> quale implementazione sarà più veloce. Una scelta possibile è implementarle entrambe e provare quale si comporta meglio. Questo approccio è detto <span class="c009">benchmarking</span>. Un’alternativa pratica è quella di scegliere la struttura di dati più facile da implementare e vedere se è abbastanza veloce per quell’applicazione. Se è così, non c’è bisogno di andare oltre. Altrimenti, ci sono strumenti, come il modulo <span class="c003">profile</span> che è in grado di segnalare i punti in cui il programma impiega la maggior parte del tempo.
<a id="hevea_default1107"></a>
<a id="hevea_default1108"></a>
<a id="hevea_default1109"></a></p><p>Altro fattore da considerare è lo spazio di archiviazione. Ad esempio, usare un istogramma per la raccolta di suffissi può richiedere meno spazio, perché è necessario memorizzare ogni parola solo una volta, indipendentemente da quante volte compaia nel testo. In qualche caso, risparmiare spazio significa avere un programma più veloce; in casi estremi, il programma può non funzionare affatto se provoca l’esaurimento della memoria. Ma per molte applicazioni, lo spazio è di secondaria importanza rispetto al tempo di esecuzione.</p><p>Un’ultima considerazione: in questa discussione, era sottointeso che avremmo dovuto usare una stessa struttura di dati sia per l’analisi che per la generazione. Ma siccome sono fasi separate, nulla vieta di usare un tipo di struttura per l’analisi e poi convertirlo in un’altra struttura per la generazione. Sarebbe un guadagno, se il tempo risparmiato durante la generazione superasse quello impiegato nella conversione.</p>
<!--TOC section id="sec164" Debug-->
<h2 class="section" id="sec164">13.10  Debug</h2><!--SEC END --><p>
<a id="hevea_default1110"></a></p><p>Quando fate il debug di un programma, e specialmente se state affrontando un bug ostico, ci sono cinque cose da provare:</p><dl class="description"><dt class="dt-description"><span class="c009">Leggere:</span></dt><dd class="dd-description"> Esaminate il vostro codice, rileggetelo e controllate che esprima esattamente quello che voi intendete dire.</dd><dt class="dt-description"><span class="c009">Eseguire:</span></dt><dd class="dd-description"> Sperimentate facendo modifiche ed eseguendo le diverse versioni. Spesso, se visualizzate la cosa giusta al posto giusto all’interno del programma, il problema diventa evidente; magari occorre spendere un po’ di tempo per inserire qualche “impalcatura”.</dd><dt class="dt-description"><span class="c009">Rimuginare:</span></dt><dd class="dd-description"> Prendetevi il tempo per pensarci su! Che tipo di errore è: di sintassi, di runtime o di semantica? Che informazioni si traggono dal messaggio di errore o dall’output del programma? Che tipo di errore potrebbe causare il problema che vedete? Quali modifiche avete fatto prima che si verificasse il problema?</dd><dt class="dt-description"><span class="c009">Parlare a una papera di gomma:</span></dt><dd class="dd-description"> Spiegando il problema a qualcun altro, talvolta si trova la risposta ancor prima di finire di formulare la domanda. Ma spesso non serve nemmeno un’altra persona: potete semplicemente parlare ad una papera di gomma. E da qui nasce la nota tecnica chiamata <span class="c009">debug con la papera di gomma</span>. Non me lo sono inventato: date un’occhiata a 
<a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging"><span class="c003">https://en.wikipedia.org/wiki/Rubber_duck_debugging</span></a>.</dd><dt class="dt-description"><span class="c009">Tornare indietro:</span></dt><dd class="dd-description"> A un certo punto, la cosa migliore da fare è tornare sui vostri passi, annullare le ultime modifiche, fino a riottenere un programma funzionante e comprensibile. Poi rifate da capo.</dd></dl><p>I programmatori principianti a volte si fissano su uno di questi punti e tralasciano gli altri. Ciascuno di essi ha dei punti deboli.
<a id="hevea_default1111"></a></p><p>Per esempio, leggere il codice va bene se il problema è un errore di battitura, ma non se c’è un fraintendimento concettuale. Se non capite cosa fa il vostro programma, potete leggerlo 100 volte senza riuscire a trovare l’errore, perché l’errore sta nella vostra testa.
<a id="hevea_default1112"></a></p><p>Fare esperimenti va bene, specie se si tratta di piccoli, semplici test. Ma se fate esperimenti senza pensare o leggere il codice, potete cascare in uno schema che io chiamo “programmare a tentoni”, che significa fare tentativi a casaccio finché il programma non fa la cosa giusta. Inutile dirlo, questo può richiedere un sacco di tempo.
<a id="hevea_default1113"></a></p><p>Dovete prendervi il tempo di riflettere. Il debug è come una scienza sperimentale. Dovete avere almeno un’ipotesi di quale sia il problema. Se ci sono due o più possibilità, provate a elaborare un test che ne elimini una.</p><p>Ma anche le migliori tecniche di debug falliranno se ci sono troppi errori o se il codice che state cercando di sistemare è troppo grande e complesso. Allora l’opzione migliore è di tornare indietro e semplificare il programma, fino ad ottenere qualcosa di funzionante e che riuscite a capire.</p><p>I principianti spesso sono riluttanti a tornare sui loro passi e si spaventano all’idea di cancellare anche una singola riga di codice (anche se è sbagliata). Se vi fa sentire meglio, copiate il programma in un altro file prima di sfrondarlo, potrete così ripristinare i pezzi di codice uno alla volta.</p><p>Trovare un bug difficile richiede lettura, esecuzione, rimuginazione e a volte ritornare sui propri passi. Se rimanete bloccati su una di queste attività, provate le altre.</p>
<!--TOC section id="sec165" Glossario-->
<h2 class="section" id="sec165">13.11  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">deterministico:</span></dt><dd class="dd-description"> Qualità di un programma di fare le stesse cose ogni volte che viene eseguito, a parità di dati di input.
<a id="hevea_default1114"></a></dd><dt class="dt-description"><span class="c009">pseudocasuale:</span></dt><dd class="dd-description"> Detto di una sequenza di numeri che sembrano casuali, ma sono generati da un programma deterministico.
<a id="hevea_default1115"></a></dd><dt class="dt-description"><span class="c009">valore di default:</span></dt><dd class="dd-description"> Il valore predefinito di un parametro opzionale quando non viene specificato altrimenti.
<a id="hevea_default1116"></a></dd><dt class="dt-description"><span class="c009">sovrascrivere:</span></dt><dd class="dd-description"> Sostituire un valore di default con un argomento.
<a id="hevea_default1117"></a></dd><dt class="dt-description"><span class="c009">benchmarking:</span></dt><dd class="dd-description"> Procedura di scelta tra strutture di dati di vario tipo, implementando le alternative e provandole su un campione di possibili input.
<a id="hevea_default1118"></a></dd><dt class="dt-description"><span class="c009">debug con la papera di gomma:</span></dt><dd class="dd-description"> Fare il debug spiegando il problema ad un oggetto inanimato, come una papera di gomma. Articolare un problema può aiutare a risolverlo, nonostante la papera di gomma non sappia nulla di Python. 
<a id="hevea_default1119"></a></dd></dl>
<!--TOC section id="sec166" Esercizi-->
<h2 class="section" id="sec166">13.12  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 9</span>  
<a id="hevea_default1120"></a>
<a id="hevea_default1121"></a><p><em>Il “rango” di una parola è la sua posizione in un elenco di parole ordinate in base alla frequenza: la parola più comune ha rango 1, la seconda più comune rango 2, ecc.</em></p><p><em>La legge di Zipf descrive una relazione tra rango e frequenza delle parole nei linguaggi naturali
(</em><a href="http://it.wikipedia.org/wiki/Legge_di_Zipf"><em><span class="c003">http://it.wikipedia.org/wiki/Legge_di_Zipf</span></em></a><em>), in particolare predice che la frequenza, </em><span class="c008">f</span><em>, della parola di rango </em><span class="c008">r</span><em> è:</em></p><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008">f</span> = <span class="c008">c</span> <span class="c008">r</span><sup>−<span class="c008">s</span></sup> </td></tr>
</table><p><em>
dove </em><span class="c008">s</span><em> e </em><span class="c008">c</span><em> sono parametri che dipendono dal linguaggio e dal testo. Logaritmizzando ambo i lati dell’equazione, si ottiene:
</em><a id="hevea_default1122"></a></p><table class="display dcenter"><tr class="c016"><td class="dcell">log<span class="c008">f</span> = log<span class="c008">c</span> − <span class="c008">s</span> log<span class="c008">r</span> </td></tr>
</table><p><em>
che rappresentata su un grafico con log </em><span class="c008">r</span><em> in ascissa e log </em><span class="c008">f</span><em> in ordinata, è una retta di coefficiente angolare </em>−<span class="c008">s</span><em> e termine noto log </em><span class="c008">c</span><em>.</em></p><p><em>Scrivete un programma che legga un testo da un file, conti le frequenza delle parole e stampi una riga per ogni parola, in ordine decrescente di frequenza, con i valori di log </em><span class="c008">f</span><em> e log </em><span class="c008">r</span><em>. Usate un programma a vostra scelta per costruire il grafico dei risultati e controllare se formano una retta. Riuscite a stimare il valore di </em><span class="c008">s</span><em>?</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/zipf.py"><span class="c003"><em>http://thinkpython2.com/code/zipf.py</em></span></a><em>. Per avviare la mia risoluzione serve il modulo di plotting <span class="c003">matplotlib</span>.
Se avete installato Anaconda, avete già <span class="c003">matplotlib</span>; altrimenti potrebbe essere necessario installarlo.
</em><a id="hevea_default1123"></a></p></div>
<!--TOC chapter id="sec167" File-->
<h1 class="chapter" id="sec167">Chapter 14  File</h1><!--SEC END --><p>Questo capitolo spiega il concetto di programma “persistente”, che mantiene i propri dati in archivi permanenti, e mostra come usare diversi tipi di archivi, come file e database.</p>
<!--TOC section id="sec168" Persistenza-->
<h2 class="section" id="sec168">14.1  Persistenza</h2><!--SEC END --><p>
<a id="hevea_default1124"></a>
<a id="hevea_default1125"></a>
<a id="hevea_default1126"></a></p><p>La maggior parte dei programmi che abbiamo visto finora sono transitori, nel senso che vengono eseguiti per breve tempo e producono un risultato, ma quando vengono chiusi i loro dati svaniscono. Se rieseguite il programma, questo ricomincia da zero.</p><p>Altri programmi sono <span class="c009">persistenti</span>: sono eseguiti per un lungo tempo (o di continuo); mantengono almeno una parte dei loro dati archiviati in modo permanente, come su un disco fisso; e se vengono arrestati e riavviati, riprendono il loro lavoro da dove lo avevano lasciato.</p><p>Esempi di programmi persistenti sono i sistemi operativi, eseguiti praticamente ogni volta che un computer viene acceso, e i web server, che lavorano di continuo in attesa di richieste provenienti dalla rete.</p><p>Per i programmi, uno dei modi più semplici di mantenere i loro dati è di leggerli e scriverli su file di testo. Abbiamo già visto qualche programma che legge dei file di testo; in questo capitolo ne vedremo alcuni che li scrivono.</p><p>Un’alternativa è conservare la situazione del programma in un database. In questo capitolo mostrerò un semplice database e un modulo, <span class="c003">pickle</span>, che rende agevole l’archiviazione dei dati.
<a id="hevea_default1127"></a>
<a id="hevea_default1128"></a></p>
<!--TOC section id="sec169" Lettura e scrittura-->
<h2 class="section" id="sec169">14.2  Lettura e scrittura</h2><!--SEC END --><p>
<a id="hevea_default1129"></a></p><p>Un file di testo è un una sequenza di caratteri salvata su un dispositivo permanente come un disco fisso, una memoria flash o un CD-ROM. Abbiamo già visto come aprire e leggere un file nel Paragrafo <a href="#wordlist">9.1</a>.
<a id="hevea_default1130"></a>
<a id="hevea_default1131"></a></p><p>Per scrivere un file, lo dovete aprire indicando la modalità <code>'w'</code> come secondo parametro:</p><pre class="verbatim">&gt;&gt;&gt; fout = open('output.txt', 'w')
</pre><p>
Se il file esiste già, l’apertura in modalità scrittura lo ripulisce dai vecchi dati e riparte da zero, quindi fate attenzione! Se non esiste, ne viene creato uno nuovo.</p><p><span class="c003">open</span> restituisce un oggetto file che fornisce i metodi per lavorare con il file.</p><p>Il metodo <span class="c003">write</span> inserisce i dati nel file.</p><pre class="verbatim">&gt;&gt;&gt; riga1 = "E questa qui è l'acacia,\n"
&gt;&gt;&gt; fout.write(riga1)
25
</pre><p>
Il valore di ritorno è il numero di caratteri che sono stati scritti. L’oggetto file tiene traccia di dove si trova, e se invocate ancora il metodo <span class="c003">write</span>, aggiunge i nuovi dati in coda al file.</p><pre class="verbatim">&gt;&gt;&gt; riga2 = "l'emblema della nostra terra.\n"
&gt;&gt;&gt; fout.write(riga2)
30
</pre><p>
Quando avete finito di scrivere, è opportuno chiudere il file.</p><pre class="verbatim">&gt;&gt;&gt; fout.close()
</pre><p>
<a id="hevea_default1132"></a>
<a id="hevea_default1133"></a></p><p>Se non chiudete il file, viene comunque chiuso automaticamente al termine del programma.</p>
<!--TOC section id="sec170" L’operatore di formato-->
<h2 class="section" id="sec170">14.3  L’operatore di formato</h2><!--SEC END --><p>
<a id="hevea_default1134"></a>
<a id="hevea_default1135"></a></p><p>L’argomento di <span class="c003">write</span> deve essere una stringa, e se volessimo inserire valori di tipo diverso in un file dovremmo prima convertirli in stringhe. Il metodo più semplice per farlo è usare <span class="c003">str</span>:</p><pre class="verbatim">&gt;&gt;&gt; x = 52
&gt;&gt;&gt; fout.write(str(x))
</pre><p>
Un’alternativa è utilizzare l’<span class="c009">operatore di formato</span>, <span class="c003">%</span>. Quando viene applicato agli interi, <span class="c003">%</span> rappresenta l’operatore modulo. Ma se il primo operando è una stringa, <span class="c003">%</span> diventa l’operatore di formato.
<a id="hevea_default1136"></a>
<a id="hevea_default1137"></a></p><p>Il primo operando è detto <span class="c009">stringa di formato</span>, che contiene una o più <span class="c009">sequenze di formato</span>, che specificano il formato del secondo operando. Il risultato è una stringa.
<a id="hevea_default1138"></a>
<a id="hevea_default1139"></a></p><p>Per esempio, la sequenza di formato <code>'%d'</code> significa che il secondo operando dovrebbe essere nel formato di numero intero in base decimale:</p><pre class="verbatim">&gt;&gt;&gt; cammelli = 42
&gt;&gt;&gt; '%d' % cammelli
'42'
</pre><p>
Il risultato è la stringa <code>'42'</code>, che non va confusa con il valore intero <span class="c003">42</span>.</p><p>Una sequenza di formato può comparire dovunque all’interno di una
stringa, e così possiamo incorporare un valore in una frase:</p><pre class="verbatim">&gt;&gt;&gt; 'Ho contato %d cammelli.' % cammelli
'Ho contato 42 cammelli.'
</pre><p>
Se nella stringa c’è più di una sequenza di formato, il secondo operando deve essere una tupla. Ciascuna sequenza di formato corrisponde a un elemento della tupla, nell’ordine.</p><p>L’esempio che segue usa <code>'%d'</code> per formattare un intero,
<code>'%g'</code> per formattare un decimale a virgola mobile (floating-point), e <code>'%s'</code> per formattare una stringa:</p><pre class="verbatim">&gt;&gt;&gt; 'In %d anni ho contato %g %s.' % (3, 0.1, 'cammelli')
'In 3 anni ho contato 0.1 cammelli.'
</pre><p>
Naturalmente, il numero degli elementi nella tupla deve essere pari a quello delle sequenze di formato nella stringa, ed i tipi degli elementi devono corrispondere a quelli delle sequenze di formato:
<a id="hevea_default1140"></a>
<a id="hevea_default1141"></a></p><pre class="verbatim">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollari'
TypeError: %d format: a number is required, not str
</pre><p>
Nel primo esempio, non ci sono abbastanza elementi; nel secondo, l’elemento è del tipo sbagliato.</p><p>Per saperne di più sull’operatore di formato: 
<a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"><span class="c003">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</span></a>. Un’alternativa più potente è il metodo di formato delle stringhe, potete leggerne la documentazione sul sito 
<a href="https://docs.python.org/3/library/stdtypes.html#str.format"><span class="c003">https://docs.python.org/3/library/stdtypes.html#str.format</span></a>.</p>
<!--TOC section id="sec171" Nomi di file e percorsi-->
<h2 class="section" id="sec171">14.4  Nomi di file e percorsi</h2><!--SEC END --><p>
<a id="paths"></a>
<a id="hevea_default1142"></a>
<a id="hevea_default1143"></a>
<a id="hevea_default1144"></a>
<a id="hevea_default1145"></a></p><p>Il file sono organizzati in <span class="c009">directory</span> (chiamate anche “cartelle”).
Ogni programma in esecuzione ha una “directory corrente”, che è la directory predefinita per la maggior parte delle operazioni che compie.
Ad esempio, quando aprite un file in lettura, Python lo cerca nella sua directory corrente.
<a id="hevea_default1146"></a>
<a id="hevea_default1147"></a></p><p>Il modulo <span class="c003">os</span> fornisce delle funzioni per lavorare con file e directory (“os” sta per “sistema operativo”). <span class="c003">os.getcwd</span> restituisce il nome della directory corrente:
<a id="hevea_default1148"></a>
<a id="hevea_default1149"></a></p><pre class="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; cwd = os.getcwd()
&gt;&gt;&gt; cwd
'/home/dinsdale'
</pre><p>
<span class="c003">cwd</span> sta per “<em>current working directory</em>” (directory di lavoro corrente). 
Il risultato di questo esempio è <span class="c003">/home/dinsdale</span>, che è la directory home di un utente di nome <span class="c003">dinsdale</span>.
<a id="hevea_default1150"></a>
<a id="hevea_default1151"></a></p><p>Una stringa come <code>'/home/dinsdale'</code>, che individua la collocazione di un file o una directory, è chiamata <span class="c009">percorso</span>.</p><p>Un semplice nome di file, come <span class="c003">memo.txt</span> è pure considerato un percorso,
ma è un <span class="c009">percorso relativo</span> perché si riferisce alla directory corrente. Se la directory corrente è <span class="c003">/home/dinsdale</span>, il nome di file <span class="c003">memo.txt</span> starebbe per <span class="c003">/home/dinsdale/memo.txt</span>.
<a id="hevea_default1152"></a></p><p>Un percorso che comincia per <span class="c003">/</span> non dipende dalla directory corrente;
viene chiamato <span class="c009">percorso assoluto</span>. Per trovare il percorso assoluto del file, si può usare <span class="c003">os.path.abspath</span>:
<a id="hevea_default1153"></a></p><p>I percorsi visti finora sono semplici nomi di file, quindi sono percorsi relativi alla directory corrente. Per avere invece il percorso assoluto, potete usare <span class="c003">os.path.abspath</span>:</p><pre class="verbatim">&gt;&gt;&gt; os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
</pre><p>
<span class="c003">os.path</span> fornisce altre funzioni per lavorare con nomi di file e percorsi. Per esempio, <span class="c003">os.path.exists</span> controlla se un file o una cartella esistono:
<a id="hevea_default1154"></a>
<a id="hevea_default1155"></a></p><pre class="verbatim">&gt;&gt;&gt; os.path.exists('memo.txt')
True
</pre><p>
Se esiste, <span class="c003">os.path.isdir</span> controlla se è una directory:</p><pre class="verbatim">&gt;&gt;&gt; os.path.isdir('memo.txt')
False
&gt;&gt;&gt; os.path.isdir('/home/dinsdale')
True
</pre><p>
Similmente, <span class="c003">os.path.isfile</span> controlla se è un file.</p><p><span class="c003">os.listdir</span> restituisce una lista dei file e delle altre directory nella cartella indicata:</p><pre class="verbatim">&gt;&gt;&gt; os.listdir(cwd)
['musica', 'immagini', 'memo.txt']
</pre><p>
Per dimostrare l’uso di queste funzioni, l’esempio seguente
“esplora” il contenuto di una directory, stampa il nome di tutti i file e si chiama ricorsivamente su tutte le sottodirectory.
<a id="hevea_default1156"></a></p><pre class="verbatim">def esplora(dirnome):
    for nome in os.listdir(dirnome):
        percorso = os.path.join(dirnome, nome)

        if os.path.isfile(percorso):
            print(percorso)
        else:
            esplora(percorso)
</pre><p>
<span class="c003">os.path.join</span> prende il nome di una directory e il nome di un file e li unisce a formare un percorso completo. </p><p>Il modulo <span class="c003">os</span> contiene una funzione di nome <span class="c003">walk</span>
che è simile a questa ma più versatile. Come esercizio, leggetene la documentazione e usatela per stampare i nomi dei file di una data directory e delle sue sottodirectory. Soluzione: <a href="http://thinkpython2.com/code/walk.py"><span class="c003">http://thinkpython2.com/code/walk.py</span></a>.</p>
<!--TOC section id="sec172" Gestire le eccezioni-->
<h2 class="section" id="sec172">14.5  Gestire le eccezioni</h2><!--SEC END --><p>
<a id="catch"></a></p><p>Parecchie cose possono andare storte quando si cerca di leggere e scrivere file. Se tentate di aprire un file che non esiste, si verifica un
<span class="c003">IOError</span>:
<a id="hevea_default1157"></a>
<a id="hevea_default1158"></a>
<a id="hevea_default1159"></a>
<a id="hevea_default1160"></a></p><pre class="verbatim">&gt;&gt;&gt; fin = open('file_corrotto')
IOError: [Errno 2] No such file or directory: 'file_corrotto'
</pre><p>
Se non avete il permesso di accedere al file:
<a id="hevea_default1161"></a>
<a id="hevea_default1162"></a></p><pre class="verbatim">&gt;&gt;&gt; fout = open('/etc/passwd', 'w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
</pre><p>
E se cercate di aprire una directory in lettura, ottenete:</p><pre class="verbatim">&gt;&gt;&gt; fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
</pre><p>
Per evitare questi errori, potete usare funzioni come <span class="c003">os.path.exists</span>
e <span class="c003">os.path.isfile</span>, ma ci vorrebbe molto tempo e molto codice per controllare tutte le possibilità (se “<span class="c003">Errno 21</span>” significa qualcosa, ci sono almeno 21 cose che possono andare male).
<a id="hevea_default1163"></a>
<a id="hevea_default1164"></a>
<a id="hevea_default1165"></a></p><p>È meglio allora andare avanti e provare—e affrontare i problemi quando si presentano—che è proprio quello che fa l’istruzione <span class="c003">try</span>. La sintassi è simile a un’istruzione <span class="c003">if...else</span>:</p><pre class="verbatim">try:    
    fin = open('file_corrotto')
except:
    print('Qualcosa non funziona.')
</pre><p>
Python comincia con l’eseguire la clausola <span class="c003">try</span>. Se tutto va bene, tralascia la clausola <span class="c003">except</span> e procede. Se si verifica un’eccezione, salta fuori dalla clausola <span class="c003">try</span> e va ad eseguire la clausola <span class="c003">except</span>.</p><p>Utilizzare in questo modo l’istruzione <span class="c003">try</span> viene detto <span class="c009">gestire</span> un’eccezione. Nell’esempio precedente, la clausola <span class="c003">except</span> stampa un messaggio di errore che non è di grande aiuto. In genere, gestire un’eccezione vi dà la possibilità di sistemare il problema, o riprovare, o per lo meno arrestare il programma in maniera morbida.</p>
<!--TOC section id="sec173" Database-->
<h2 class="section" id="sec173">14.6  Database</h2><!--SEC END --><p>
<a id="hevea_default1166"></a></p><p>Un <span class="c009">database</span> è un file che è progettato per archiviare dati. Molti database sono organizzati come un dizionario, nel senso che fanno una mappatura da chiavi in valori. La grande differenza tra database e dizionari è che i primi risiedono su disco (o altro dispositivo permanente), e persistono quando il programma viene chiuso.
<a id="hevea_default1167"></a>
<a id="hevea_default1168"></a></p><p>Il modulo <span class="c003">dbm</span> fornisce un’interfaccia per creare e aggiornare file di database. Come esempio, creerò un database che contiene le didascalie di alcuni file di immagini.
<a id="hevea_default1169"></a>
<a id="hevea_default1170"></a></p><p>Un database si apre in modo simile agli altri file:</p><pre class="verbatim">&gt;&gt;&gt; import dbm
&gt;&gt;&gt; db = dbm.open('didascalie', 'c')
</pre><p>
La modalità <code>'c'</code> significa che il database deve essere creato se non esiste già. Il risultato è un oggetto database che può essere utilizzato (per la maggior parte delle operazioni) come un dizionario. 
<a id="hevea_default1171"></a>
<a id="hevea_default1172"></a></p><p>Se create un nuovo elemento, <span class="c003">dbm</span> aggiorna il file di database.
<a id="hevea_default1173"></a></p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png'] = 'Foto di John Cleese.'
</pre><p>
Quando accedete a uno degli elementi, <span class="c003">dbm</span> legge il file:</p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png']
b'Foto di John Cleese.'
</pre><p>
Il risultato è un <span class="c009">oggetto bytes</span>, ed è per questo che comincia per <span class="c003">b</span>. Un oggetto bytes è per molti aspetti simile ad una stringa. Quando approfondirete Python la differenza diverrà importante, ma per ora possiamo soprassedere.
<a id="hevea_default1174"></a>
<a id="hevea_default1175"></a></p><p>Se fate una nuova assegnazione a una chiave esistente, <span class="c003">dbm</span> sostituisce il vecchio valore:</p><pre class="verbatim">&gt;&gt;&gt; db['cleese.png'] = 'Foto di John Cleese che cammina in modo ridicolo.'
&gt;&gt;&gt; db['cleese.png']
b'Foto di John Cleese che cammina in modo ridicolo.'
</pre><p>
Certi metodi dei dizionari, come <span class="c003">keys</span> e <span class="c003">items</span>, non funzionano con gli oggetti database, ma funziona l’iterazione con un ciclo <span class="c003">for</span>.
<a id="hevea_default1176"></a></p><pre class="verbatim">for chiave in db:
    print(chiave, db[chiave])
</pre><p>
Come con gli altri file, dovete chiudere il database quando avete finito:</p><pre class="verbatim">&gt;&gt;&gt; db.close()
</pre><p>
<a id="hevea_default1177"></a>
<a id="hevea_default1178"></a></p>
<!--TOC section id="sec174" Pickling-->
<h2 class="section" id="sec174">14.7  Pickling</h2><!--SEC END --><p>
<a id="hevea_default1179"></a></p><p>Un limite di <span class="c003">dbm</span> è che le chiavi e i valori devono essere delle stringhe, oppure bytes. Se cercate di utilizzare qualsiasi altro tipo, si verifica un errore.
<a id="hevea_default1180"></a>
<a id="hevea_default1181"></a></p><p>Il modulo <span class="c003">pickle</span> può essere di aiuto: trasforma quasi ogni tipo di oggetto in una stringa, adatta per essere inserita in un database, e quindi ritrasforma la stringa in oggetto.</p><p><span class="c003">pickle.dumps</span> accetta un oggetto come parametro e ne restituisce una serializzazione, ovvero una rappresentazione sotto forma di una stringa (<span class="c003">dumps</span> è l’abbreviazione di “dump string”, scarica stringa):</p><pre class="verbatim">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
</pre><p>
Il formato non è immediatamente leggibile: è progettato per essere facile da interpretare da parte di <span class="c003">pickle</span>. In seguito, <span class="c003">pickle.loads</span>
(“carica stringa”) ricostruisce l’oggetto:</p><pre class="verbatim">&gt;&gt;&gt; t1 = [1, 2, 3]
&gt;&gt;&gt; s = pickle.dumps(t1)
&gt;&gt;&gt; t2 = pickle.loads(s)
&gt;&gt;&gt; t2
[1, 2, 3]
</pre><p>
Sebbene il nuovo oggetto abbia lo stesso valore di quello vecchio, non è in genere lo stesso oggetto:</p><pre class="verbatim">&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; t1 is t2
False
</pre><p>
In altre parole, fare una serializzazione con <span class="c003">pickle</span> e poi l’operazione inversa, ha lo stesso effetto di copiare l’oggetto.</p><p>Potete usare <span class="c003">pickle</span> per archiviare in un database tutto ciò che non è una stringa. In effetti, questa combinazione è tanto frequente da essere stata incapsulata in un modulo chiamato <span class="c003">shelve</span>. 
<a id="hevea_default1182"></a>
<a id="hevea_default1183"></a></p>
<!--TOC section id="sec175" Pipe-->
<h2 class="section" id="sec175">14.8  Pipe</h2><!--SEC END --><p>
<a id="hevea_default1184"></a>
<a id="hevea_default1185"></a></p><p>Molti sistemi operativi forniscono un’interfaccia a riga di comando, nota anche come <span class="c009">shell</span>. Le shell sono dotate di comandi per spostarsi nel file system e per lanciare le applicazioni. Per esempio, in UNIX potete cambiare directory con il comando <span class="c003">cd</span>,
visualizzarne il contenuto con <span class="c003">ls</span>, e lanciare un web browser scrivendone il nome, per esempio <span class="c003">firefox</span>.
<a id="hevea_default1186"></a>
<a id="hevea_default1187"></a></p><p>Qualsiasi programma lanciabile dalla shell può essere lanciato anche da Python usando un <span class="c009">oggetto pipe</span>, che rappresenta un programma in esecuzione.</p><p>Ad esempio, il comando Unix <span class="c003">ls -l</span> di norma mostra il contenuto della cartella attuale (in formato esteso). Potete lanciare <span class="c003">ls</span> anche con <span class="c003">os.popen</span><sup><a id="text1" href="#note1">1</a></sup>:
<a id="hevea_default1188"></a>
<a id="hevea_default1189"></a></p><pre class="verbatim">&gt;&gt;&gt; cmd = 'ls -l'
&gt;&gt;&gt; fp = os.popen(cmd)
</pre><p>
L’argomento è una stringa che contiene un comando shell. Il valore di ritorno è un oggetto che si comporta come un file aperto. Potete leggere l’output del processo <span class="c003">ls</span> una riga per volta con <span class="c003">readline</span>, oppure ottenere tutto in una volta con <span class="c003">read</span>:
<a id="hevea_default1190"></a>
<a id="hevea_default1191"></a>
<a id="hevea_default1192"></a>
<a id="hevea_default1193"></a></p><pre class="verbatim">&gt;&gt;&gt; res = fp.read()
</pre><p>
Quando avete finito, chiudete la pipe come se fosse un file:
<a id="hevea_default1194"></a>
<a id="hevea_default1195"></a></p><pre class="verbatim">&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(stat)
None
</pre><p>
Il valore di ritorno è lo stato finale del processo <span class="c003">ls</span>;
<span class="c003">None</span> significa che si è chiuso normalmente (senza errori).</p><p>Altro esempio, in molti sistemi Unix il comando <span class="c003">md5sum</span>
legge il contenuto di un file e ne calcola una checksum . Per saperne di più: <a href="http://it.wikipedia.org/wiki/MD5"><span class="c003">http://it.wikipedia.org/wiki/MD5</span></a>. Questo comando è un mezzo efficiente per controllare se due file hanno lo stesso contenuto. La probabilità che due diversi contenuti diano la stessa checksum è piccolissima (per intenderci, è improbabile che succeda prima che l’universo collassi).
<a id="hevea_default1196"></a>
<a id="hevea_default1197"></a></p><p>Potete allora usare una pipe per eseguire <span class="c003">md5sum</span> da Python e ottenere il risultato:</p><pre class="verbatim">&gt;&gt;&gt; nomefile = 'book.tex'
&gt;&gt;&gt; cmd = 'md5sum ' + nomefile
&gt;&gt;&gt; fp = os.popen(cmd)
&gt;&gt;&gt; res = fp.read()
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(res)
1e0033f0ed0656636de0d75144ba32e0  book.tex
&gt;&gt;&gt; print(stat)
None
</pre>
<!--TOC section id="sec176" Scrivere moduli-->
<h2 class="section" id="sec176">14.9  Scrivere moduli</h2><!--SEC END --><p>
<a id="modules"></a>
<a id="hevea_default1198"></a>
<a id="hevea_default1199"></a></p><p>Qualunque file che contenga codice Python può essere importato come modulo. Per esempio, supponiamo di avere un file di nome <span class="c003">wc.py</span> che contiene il codice che segue:</p><pre class="verbatim">def contarighe(nomefile):
    conta = 0
    for riga in open(nomefile):
        conta += 1
    return conta

print(contarighe('wc.py'))
</pre><p>
Se eseguite questo programma, legge se stesso e stampa il numero delle righe nel file, che è 7. Potete anche importare il file in questo modo:</p><pre class="verbatim">&gt;&gt;&gt; import wc
7
</pre><p>
Ora avete un oggetto modulo <span class="c003">wc</span>:
<a id="hevea_default1200"></a></p><pre class="verbatim">&gt;&gt;&gt; wc
&lt;module 'wc' from 'wc.py'&gt;
</pre><p>
L’oggetto modulo fornisce <code>contarighe</code>:</p><pre class="verbatim">&gt;&gt;&gt; wc.contarighe('wc.py')
7
</pre><p>
Ecco come scrivere moduli in Python.</p><p>L’unico difetto di questo esempio è che quando importate il modulo, esegue anche il codice di prova in fondo. Di solito, invece, un modulo definisce solo delle nuove funzioni ma non le esegue.
<a id="hevea_default1201"></a>
<a id="hevea_default1202"></a></p><p>I programmi che verranno importati come moduli usano spesso questo costrutto:</p><pre class="verbatim">if __name__ == '__main__':
    print(contarighe('wc.py'))
</pre><p>
<code>__name__</code> è una variabile predefinita che viene impostata all’avvio del programma. Se questo viene avviato come script,
<code>__name__</code> ha il valore <code>'__main__'</code>; in quel caso, il codice viene eseguito. Altrimenti, se viene importato come modulo, il codice di prova viene saltato.
<a id="hevea_default1203"></a>
<a id="hevea_default1204"></a></p><p>Come esercizio, scrivete questo esempio in un file di nome <span class="c003">wc.py</span> ed eseguitelo come script. Poi avviate l’interprete e scrivete
<span class="c003">import wc</span>. Che valore ha <code>__name__</code>
quando il modulo viene importato?</p><p>Attenzione: Se importate un modulo già importato, Python non fa nulla. Non rilegge il file, anche se è cambiato.
<a id="hevea_default1205"></a>
<a id="hevea_default1206"></a>
<a id="hevea_default1207"></a></p><p>Se volete ricaricare un modulo potete usare la funzione <span class="c003">reload</span>, ma potrebbe dare delle noie, quindi la cosa più sicura è riavviare l’interprete e importare nuovamente il modulo.</p>
<!--TOC section id="sec177" Debug-->
<h2 class="section" id="sec177">14.10  Debug</h2><!--SEC END --><p>
<a id="hevea_default1208"></a>
<a id="hevea_default1209"></a></p><p>Quando leggete e scrivete file, è possibile incontrare dei problemi con gli spaziatori. Questi errori sono difficili da correggere perché spazi, tabulazioni e ritorni a capo di solito non sono visibili.</p><pre class="verbatim">&gt;&gt;&gt; s = '1 2\t 3\n 4'
&gt;&gt;&gt; print(s)
1 2  3
 4
</pre><p>
<a id="hevea_default1210"></a>
<a id="hevea_default1211"></a>
<a id="hevea_default1212"></a></p><p>La funzione predefinita <span class="c003">repr</span> può essere utile: riceve come argomento qualsiasi oggetto e restituisce una rappresentazione dell’oggetto in forma di stringa. Per le stringhe, essa rappresenta gli spaziatori con delle sequenze con barra inversa:</p><pre class="verbatim">&gt;&gt;&gt; print(repr(s))
'1 2\t 3\n 4'
</pre><p>Questa funzione può quindi aiutare nel debug.</p><p>Un altro problema in cui potreste imbattervi è che sistemi diversi usano caratteri diversi per indicare la fine della riga. Alcuni usano il carattere di ritorno a capo, rappresentato da <code>\n</code>. Altri usano quello di ritorno carrello, rappresentato da <code>\r</code>. Alcuni usano entrambi. Se spostate i file da un sistema all’altro, queste incongruenze possono causare errori.
<a id="hevea_default1213"></a></p><p>Comunque, esistono per ogni sistema delle applicazioni che convertono da un formato a un altro. Potete trovarne (e leggere altro sull’argomento) sul sito <a href="http://it.wikipedia.org/wiki/Ritorno_a_capo"><span class="c003">http://it.wikipedia.org/wiki/Ritorno_a_capo</span></a>. Oppure, naturalmente, potete scriverne una voi.</p>
<!--TOC section id="sec178" Glossario-->
<h2 class="section" id="sec178">14.11  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">persistente:</span></dt><dd class="dd-description"> Di un programma eseguito per un tempo indefinito e che memorizza almeno parte dei suoi dati in dispositivi permanenti.
<a id="hevea_default1214"></a></dd><dt class="dt-description"><span class="c009">operatore di formato:</span></dt><dd class="dd-description"> Operatore indicato da <span class="c003">%</span>, che a partire da una stringa di formato e una tupla produce una stringa che include gli elementi della tupla, ciascuno nel formato specificato dalla stringa di formato.
<a id="hevea_default1215"></a></dd><dt class="dt-description"><span class="c009">stringa di formato:</span></dt><dd class="dd-description"> Stringa usata con l’operatore di formato e che contiene le sequenze di formato. 
<a id="hevea_default1216"></a></dd><dt class="dt-description"><span class="c009">sequenza di formato:</span></dt><dd class="dd-description"> Sequenza di caratteri in una stringa di formato, come <span class="c003">%d</span>, che specifica in quale formato deve essere un valore.
<a id="hevea_default1217"></a></dd><dt class="dt-description"><span class="c009">file di testo:</span></dt><dd class="dd-description"> Sequenza di caratteri salvata in un dispositivo di archiviazione permanente come un disco fisso.
<a id="hevea_default1218"></a></dd><dt class="dt-description"><span class="c009">directory:</span></dt><dd class="dd-description"> Raccolta di file; è dotata di un nome ed è chiamata anche cartella.
<a id="hevea_default1219"></a></dd><dt class="dt-description"><span class="c009">percorso:</span></dt><dd class="dd-description"> Stringa che localizza un file.
<a id="hevea_default1220"></a></dd><dt class="dt-description"><span class="c009">percorso relativo:</span></dt><dd class="dd-description"> Un percorso che parte dalla cartella di lavoro attuale.
<a id="hevea_default1221"></a></dd><dt class="dt-description"><span class="c009">percorso assoluto:</span></dt><dd class="dd-description"> Un percorso che parte dalla cartella principale del file system.
<a id="hevea_default1222"></a></dd><dt class="dt-description"><span class="c009">gestire:</span></dt><dd class="dd-description"> Prevenire l’arresto di un programma causato da un errore, mediante le istruzioni <span class="c003">try</span>
e <span class="c003">except</span>.
<a id="hevea_default1223"></a></dd><dt class="dt-description"><span class="c009">database:</span></dt><dd class="dd-description"> Un file i cui contenuti sono organizzati come un dizionario, con chiavi che corrispondono a valori.
<a id="hevea_default1224"></a></dd><dt class="dt-description"><span class="c009">oggetto bytes:</span></dt><dd class="dd-description"> Un oggetto simile ad una stringa.
<a id="hevea_default1225"></a>
<a id="hevea_default1226"></a></dd><dt class="dt-description"><span class="c009">shell:</span></dt><dd class="dd-description"> Un programma che permette all’utente di inserire comandi e di eseguirli, avviando altri programmi.
<a id="hevea_default1227"></a></dd><dt class="dt-description"><span class="c009">oggetto pipe:</span></dt><dd class="dd-description"> Un oggetto che rappresenta un programma in esecuzione e che consente ad un programma Python di eseguire comandi e leggere i risultati.
<a id="hevea_default1228"></a>
<a id="hevea_default1229"></a></dd></dl>
<!--TOC section id="sec179" Esercizi-->
<h2 class="section" id="sec179">14.12  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete una funzione di nome <span class="c003">sed</span> che richieda come argomenti una stringa modello, una stringa di sostituzione, e due nomi di file. La funzione deve leggere il primo file e scriverne il contenuto nel secondo file (creandolo se necessario). Se la stringa modello compare da qualche parte nel testo del file, la funzione deve sostituirla con la seconda stringa.</em></p><p><em>Se si verifica un errore in apertura, lettura, scrittura, chiusura del file, il vostro programma deve gestire l’eccezione, stampare un messaggio di errore e terminare. Soluzione: </em><a href="http://thinkpython2.com/code/sed.py"><em><span class="c003">http://thinkpython2.com/code/sed.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default1230"></a>
<a id="hevea_default1231"></a><p><em>Se avete scaricato la mia soluzione dell’Esercizio </em><a href="#anagrams"><em>2</em></a><em> dal sito
</em><a href="http://thinkpython2.com/code/anagram_sets.py"><span class="c003"><em>http://thinkpython2.com/code/anagram_sets.py</em></span></a><em>, avrete visto che crea un dizionario che fa corrispondere una stringa ordinata di lettere alla lista di parole che possono essere scritte con quelle lettere. Per esempio, <code>'opst'</code> corrisponde alla lista <code>['opts', 'post', 'pots', 'spot', 'stop', 'tops']</code>.</em></p><p><em>Scrivete un modulo che importi <code>anagram_sets</code> e fornisca due nuove funzioni: <code>arch_anagrammi</code> deve archiviare il dizionario di anagrammi in uno “shelf”; <code>leggi_anagrammi</code> deve cercare una parola e restituire una lista dei suoi anagrammi. Soluzione: </em><a href="http://thinkpython2.com/code/anagram_db.py"><span class="c003"><em>http://thinkpython2.com/code/anagram_db.py</em></span></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="checksum"></a>
<a id="hevea_default1232"></a><p><em>In una grande raccolta di file MP3 possono esserci più copie della stessa canzone, messe in cartelle diverse o con nomi di file differenti. Scopo di questo esercizio è di ricercare i duplicati.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete un programma che cerchi in una cartella e, ricorsivamente, nelle sue sottocartelle, e restituisca un elenco dei percorsi completi di tutti i file con una stessa estensione (come <span class="c003">.mp3</span>).
Suggerimento: <span class="c003">os.path</span> contiene alcune funzioni utili per trattare nomi di file e percorsi.
</em><a id="hevea_default1233"></a>
<a id="hevea_default1234"></a>
<a id="hevea_default1235"></a>
<a id="hevea_default1236"></a></li><li class="li-enumerate"><em>Per riconoscere i duplicati, potete usare <span class="c003">md5sum</span>
per calcolare la “checksum” di ogni file. Se due file hanno la stessa checksum, significa che con ogni probabilità hanno lo stesso contenuto.
</em><a id="hevea_default1237"></a></li><li class="li-enumerate"><em>Per effettuare un doppio controllo, usate il comando Unix <span class="c003">diff</span>.
</em><a id="hevea_default1238"></a></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/find_duplicates.py"><em><span class="c003">http://thinkpython2.com/code/find_duplicates.py</span></em></a><em>.</em></p></div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span class="c003">popen</span> ora è deprecato, cioè siamo invitati a smettere di usarlo e ad iniziare ad usare invece il modulo <span class="c003">subprocess</span>. Ma per i casi semplici, trovo che
<span class="c003">subprocess</span> sia più complicato del necessario. Pertanto continuerò ad usare <span class="c003">popen</span> finché non verrà rimosso definitivamente.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec180" Classi e oggetti-->
<h1 class="chapter" id="sec180">Chapter 15  Classi e oggetti</h1><!--SEC END --><p>
<a id="clobjects"></a></p><p>A questo punto, sapete come usare le funzioni per organizzare il codice, e i tipi predefiniti per organizzare i dati. Il passo successivo è imparare la programmazione orientata agli oggetti, che usa tipi personalizzati in modo da organizzare sia il codice che i dati. La programmazione orientata agli oggetti è un argomento vasto, per addentrarsi nel quale occorrono alcuni capitoli.
<a id="hevea_default1239"></a></p><p>Il codice degli esempi di questo capitolo è scaricabile dal sito
<a href="http://thinkpython2.com/code/Point1.py"><span class="c003">http://thinkpython2.com/code/Point1.py</span></a>; le soluzioni degli esercizi da
<a href="http://thinkpython2.com/code/Point1_soln.py"><span class="c003">http://thinkpython2.com/code/Point1_soln.py</span></a>.</p>
<!--TOC section id="sec181" Tipi personalizzati-->
<h2 class="section" id="sec181">15.1  Tipi personalizzati</h2><!--SEC END --><p>
<a id="point"></a>
<a id="hevea_default1240"></a></p><p>Abbiamo usato molti dei tipi predefiniti in Python, e ora siamo pronti
per crearne uno nuovo: come esempio, creeremo un tipo che chiameremo <span class="c003">Punto</span>, che rappresenta un punto in un piano cartesiano bidimensionale.
<a id="hevea_default1241"></a></p><p>Nella notazione matematica, il punto è denotato da una coppia ordinata di numeri, dette coordinate; le coordinate dei punti sono spesso scritte tra parentesi con una virgola che separa i due valori. Per esempio, (0,0) rappresenta l’origine e (<span class="c008">x</span>,<span class="c008">y</span>) il punto che si trova a <span class="c008">x</span> unità a destra e <span class="c008">y</span> unità in alto rispetto all’origine.</p><p>Ci sono alcuni modi per rappresentare i punti in Python:</p><ul class="itemize"><li class="li-itemize">Memorizzare le coordinate in due variabili separate, <span class="c003">x</span> e <span class="c003">y</span>.</li><li class="li-itemize">Memorizzare le coordinate come elementi di una lista o di una tupla.</li><li class="li-itemize">Creare un nuovo tipo che rappresenti i punti come degli oggetti.</li></ul><p>
<a id="hevea_default1242"></a></p><p>L’ultima opzione è più complessa delle altre, ma ha dei vantaggi che saranno presto chiariti.</p><p>Un tipo personalizzato, definito dal programmatore, è chiamato anche <span class="c009">classe</span>.
Una definizione di classe ha questa sintassi:
<a id="hevea_default1243"></a>
<a id="hevea_default1244"></a>
<a id="hevea_default1245"></a>
<a id="hevea_default1246"></a></p><pre class="verbatim">class Punto:
    """Rappresenta un punto in un piano."""
</pre><p>
L’intestazione indica che la nuova classe si chiama <span class="c003">Punto</span>.
Il corpo è una stringa di documentazione che spiega cosa fa la classe. Al suo interno si possono poi definire metodi e variabili, ma ci arriveremo tra poco.
<a id="hevea_default1247"></a>
<a id="hevea_default1248"></a>
<a id="hevea_default1249"></a></p><p>La definizione di una classe di nome <span class="c003">Punto</span> crea un <span class="c009">oggetto classe</span>.</p><pre class="verbatim">&gt;&gt;&gt; Punto
&lt;class '__main__.Punto'&gt;
</pre><p>
Poiché la classe <span class="c003">Punto</span> è stata definita al livello principale, il suo “cognome e nome” è <code>__main__.Punto</code>.
<a id="hevea_default1250"></a></p><p>L’oggetto classe è simile ad uno stampo che ci permette di fabbricare degli oggetti. Per creare un nuovo oggetto Punto, basta chiamare <span class="c003">Punto</span> come se fosse una funzione.</p><pre class="verbatim">&gt;&gt;&gt; nuovo = Punto()
&gt;&gt;&gt; nuovo
&lt;__main__.Punto object at 0xb7e9d3ac&gt;
</pre><p>
Il valore di ritorno è un riferimento ad un oggetto Punto, che qui abbiamo assegnato alla variabile <span class="c003">nuovo</span>. 
La creazione di un nuovo oggetto è detta
<span class="c009">istanziazione</span>, e l’oggetto è un’<span class="c009">istanza</span> della classe.
<a id="hevea_default1251"></a>
<a id="hevea_default1252"></a></p><p>Quando stampate un’istanza, Python informa a quale classe appartiene e in quale posizione di memoria è collocata (il prefisso <span class="c003">0x</span> significa che il numero che segue è in formato esadecimale).
<a id="hevea_default1253"></a></p><p>Ogni oggetto è un’istanza di una qualche classe, per cui i termini “oggetto” ed
“istanza” sono equivalenti. In questa sede, utilizzerò “istanza” per indicare che sto parlando di un tipo personalizzato.</p>
<!--TOC section id="sec182" Attributi-->
<h2 class="section" id="sec182">15.2  Attributi</h2><!--SEC END --><p>
<a id="attributes"></a>
<a id="hevea_default1254"></a>
<a id="hevea_default1255"></a>
<a id="hevea_default1256"></a></p><p>Potete assegnare dei valori ad un’istanza usando la notazione a punto:</p><pre class="verbatim">&gt;&gt;&gt; nuovo.x = 3.0
&gt;&gt;&gt; nuovo.y = 4.0
</pre><p>
Questa sintassi è simile a quella usata per la selezione di una variabile appartenente ad un modulo, tipo <span class="c003">math.pi</span> o <span class="c003">string.whitespace</span>. In questo caso però, stiamo assegnando dei valori a degli elementi di un oggetto, ai quali è stato attribuito un nome (x e y). Questi elementi sono detti <span class="c009">attributi</span>.</p><p>Il diagramma di stato in Figura <a href="#fig.point">15.1</a> mostra il risultato delle assegnazioni. Un diagramma di stato che illustra un oggetto e i suoi attributi è detto <span class="c009">diagramma di oggetto</span> .
<a id="hevea_default1257"></a>
<a id="hevea_default1258"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian020.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 15.1: Diagramma di oggetto</td></tr>
</table></div>
<a id="fig.point"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La variabile <span class="c003">nuovo</span> fa riferimento ad un oggetto Punto che contiene due
attributi, ed ogni attributo fa riferimento ad un numero in virgola mobile.</p><p>Potete leggere il valore di un attributo usando la stessa sintassi:</p><pre class="verbatim">&gt;&gt;&gt; nuovo.y
4.0
&gt;&gt;&gt; x = nuovo.x
&gt;&gt;&gt; x
3.0
</pre><p>
L’espressione <span class="c003">nuovo.x</span> significa: “Vai all’oggetto a cui <span class="c003">nuovo</span>
fa riferimento e prendi il valore di <span class="c003">x</span>”. In questo esempio, assegniamo il valore ad una variabile di nome <span class="c003">x</span>. Non c’è conflitto tra la variabile locale <span class="c003">x</span> e l’attributo <span class="c003">x</span>.</p><p>Potete usare la notazione a punto all’interno di qualunque espressione, per esempio:</p><pre class="verbatim">&gt;&gt;&gt; print('(%g, %g)' % (nuovo.x, nuovo.y))
(3.0, 4.0)
&gt;&gt;&gt; distanza = math.sqrt(nuovo.x**2 + nuovo.y**2)
&gt;&gt;&gt; distanza
5.0
</pre><p>
Potete anche passare un’istanza come argomento, nel modo consueto:
<a id="hevea_default1259"></a></p><pre class="verbatim">def stampa_punto(p):
    print('(%g, %g)' % (p.x, p.y))
</pre><p>
La funzione <code>stampa_punto</code> riceve come argomento un Punto e lo visualizza in notazione matematica. Per invocarla, passate <span class="c003">nuovo</span> come argomento:</p><pre class="verbatim">&gt;&gt;&gt; stampa_punto(nuovo)
(3.0, 4.0)
</pre><p>
Dentro alla funzione, il parametro <span class="c003">p</span> è un alias di <span class="c003">nuovo</span>, quindi se la funzione modifica <span class="c003">p</span>, anche <span class="c003">nuovo</span> viene modificato di conseguenza.
<a id="hevea_default1260"></a></p><p>Per esercizio, scrivete una funzione di nome <code>distanza_tra_punti</code> che riceva due Punti come argomenti e ne restituisca la distanza.</p>
<!--TOC section id="sec183" Rettangoli-->
<h2 class="section" id="sec183">15.3  Rettangoli</h2><!--SEC END --><p>
<a id="rectangles"></a></p><p>A volte è abbastanza ovvio stabilire gli attributi necessari ad un oggetto, ma in altre occasioni occorre fare delle scelte. Immaginate di progettare una classe che rappresenti un rettangolo: quali attributi dovete usare per specificarne le dimensioni e la collocazione nel piano? Per semplicità, ignorate l’inclinazione e supponete che il rettangolo sia allineato in orizzontale o verticale.
<a id="hevea_default1261"></a></p><p>Ci sono almeno due possibili scelte: </p><ul class="itemize"><li class="li-itemize">Definire il centro del rettangolo oppure un angolo, e le sue dimensioni (altezza e larghezza);</li><li class="li-itemize">Definire due angoli opposti.</li></ul><p>È difficile stabilire quale delle due opzioni sia la migliore, ma giusto per fare un esempio implementeremo la prima.
<a id="hevea_default1262"></a>
<a id="hevea_default1263"></a></p><p>Definiamo la nuova classe:</p><pre class="verbatim">class Rettangolo:
    """Rappresenta un rettangolo. 

    attributi: larghezza, altezza, angolo.
    """
</pre><p>
La docstring elenca gli attributi: <span class="c003">larghezza</span> e
<span class="c003">altezza</span> sono numeri; <span class="c003">angolo</span> è un oggetto Punto che identifica l’angolo in basso a sinistra.</p><p>Per ottenere una rappresentazione di un rettangolo, dovete istanziare un oggetto Rettangolo e assegnare dei valori ai suoi attributi:</p><pre class="verbatim">box = Rettangolo()
box.larghezza = 100.0
box.altezza = 200.0
box.angolo = Punto()
box.angolo.x = 0.0
box.angolo.y = 0.0
</pre><p>
L’espressione <span class="c003">box.angolo.x</span> significa:
“Vai all’oggetto a cui <span class="c003">box</span> fa riferimento e seleziona l’attributo chiamato
<span class="c003">angolo</span>; poi vai a quell’oggetto e seleziona l’attributo chiamato <span class="c003">x</span>.”</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian021.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 15.2: Diagramma di oggetto.</td></tr>
</table></div>
<a id="fig.rectangle"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La Figura <a href="#fig.rectangle">15.2</a> mostra lo stato di questo oggetto.
Un oggetto che è un attributo di un altro oggetto è detto <span class="c009">oggetto contenuto</span> (embedded).
<a id="hevea_default1264"></a>
<a id="hevea_default1265"></a>
<a id="hevea_default1266"></a></p>
<!--TOC section id="sec184" Istanze come valori di ritorno-->
<h2 class="section" id="sec184">15.4  Istanze come valori di ritorno</h2><!--SEC END --><p>
<a id="hevea_default1267"></a>
<a id="hevea_default1268"></a></p><p>Le funzioni possono restituire istanze. Per esempio, <code>trova_centro</code>
prende un oggetto <span class="c003">Rettangolo</span> come argomento e restituisce un oggetto <span class="c003">Punto</span> che contiene le coordinate del centro di <span class="c003">Rettangolo</span>:</p><pre class="verbatim">def trova_centro(rett):
    p = Punto()
    p.x = rett.angolo.x + rett.larghezza/2
    p.y = rett.angolo.y + rett.altezza/2
    return p
</pre><p>
Ecco un esempio che passa <span class="c003">box</span> come argomento e assegna il Punto risultante a <span class="c003">centro</span>:</p><pre class="verbatim">&gt;&gt;&gt; centro = trova_centro(box)
&gt;&gt;&gt; stampa_punto(centro)
(50, 100)
</pre>
<!--TOC section id="sec185" Gli oggetti sono mutabili-->
<h2 class="section" id="sec185">15.5  Gli oggetti sono mutabili</h2><!--SEC END --><p>
<a id="hevea_default1269"></a>
<a id="hevea_default1270"></a></p><p>Potete cambiare lo stato di un oggetto con un’assegnazione ad uno dei suoi attributi. Per esempio, per cambiare le dimensioni di un rettangolo senza cambiarne la posizione, potete modificare i valori di <span class="c003">larghezza</span> e <span class="c003">altezza</span>:</p><pre class="verbatim">box.larghezza = box.larghezza + 50
box.altezza = box.altezza + 100
</pre><p>
Potete anche scrivere delle funzioni che modificano oggetti. Per esempio,
<code>accresci_rettangolo</code> prende un oggetto Rettangolo e due numeri,
<span class="c003">dlargh</span> e <span class="c003">dalt</span>, e li aggiunge alla larghezza e all’altezza del rettangolo:</p><pre class="verbatim">def accresci_rettangolo(rett, dlargh, dalt):
    rett.larghezza += dlargh
    rett.altezza += dalt
</pre><p>
Ecco un esempio dell’effetto della funzione:</p><pre class="verbatim">&gt;&gt;&gt; box.larghezza, box.altezza
(150.0, 300.0)
&gt;&gt;&gt; accresci_rettangolo(box, 50, 100)
&gt;&gt;&gt; box.larghezza, box.altezza
(200.0, 400.0)
</pre><p>
Dentro la funzione, <span class="c003">rett</span> è un alias di <span class="c003">box</span>, pertanto quando la funzione modifica <span class="c003">rett</span>, anche <span class="c003">box</span> cambia.</p><p>Come esercizio, scrivete una funzione di nome <code>sposta_rettangolo</code> che prenda come parametri un Rettangolo e due valori <span class="c003">dx</span> e <span class="c003">dy</span>. La funzione deve spostare il rettangolo nel piano, aggiungendo <span class="c003">dx</span> alla coordinata <span class="c003">x</span> di <span class="c003">angolo</span>, e aggiungendo <span class="c003">dy</span> alla coordinata <span class="c003">y</span> di <span class="c003">angolo</span>.</p>
<!--TOC section id="sec186" Copia-->
<h2 class="section" id="sec186">15.6  Copia</h2><!--SEC END --><p>
<a id="copying"></a>
<a id="hevea_default1271"></a></p><p>Abbiamo già visto che gli alias possono rendere il programma difficile
da leggere, perché una modifica in un punto del programma può dare degli effetti inattesi in un altro punto. Non è semplice tenere traccia di tutte le variabili che potrebbero fare riferimento ad un dato oggetto.
<a id="hevea_default1272"></a>
<a id="hevea_default1273"></a>
<a id="hevea_default1274"></a>
<a id="hevea_default1275"></a></p><p>La copia di un oggetto è spesso una comoda alternativa all’alias.
Il modulo <span class="c003">copy</span> contiene una funzione, anch’essa di nome <span class="c003">copy</span>, che permette di duplicare qualsiasi oggetto:</p><pre class="verbatim">&gt;&gt;&gt; p1 = Punto()
&gt;&gt;&gt; p1.x = 3.0
&gt;&gt;&gt; p1.y = 4.0

&gt;&gt;&gt; import copy
&gt;&gt;&gt; p2 = copy.copy(p1)
</pre><p>
<span class="c003">p1</span> e <span class="c003">p2</span> contengono gli stessi dati, ma non sono lo stesso Punto.</p><pre class="verbatim">&gt;&gt;&gt; stampa_punto(p1)
(3, 4)
&gt;&gt;&gt; stampa_punto(p2)
(3, 4)
&gt;&gt;&gt; p1 is p2
False
&gt;&gt;&gt; p1 == p2
False
</pre><p>
L’operatore <span class="c003">is</span> indica che <span class="c003">p1</span> e <span class="c003">p2</span> non sono lo stesso oggetto, come volevasi dimostrare. Ma forse vi aspettavate che l’operatore <span class="c003">==</span> desse <span class="c003">True</span>, perché i due punti contengono gli stessi dati. Invece, dovete sapere che, nel caso di istanze, il comportamento predefinito dell’operatore <span class="c003">==</span> è lo stesso dell’operatore <span class="c003">is</span>: controlla l’identità dell’oggetto e non l’equivalenza. Questo perché, per i tipi personalizzati, Python non sa cosa debba essere considerato equivalente. O almeno, non lo sa ancora.
<a id="hevea_default1276"></a>
<a id="hevea_default1277"></a>
<a id="hevea_default1278"></a>
<a id="hevea_default1279"></a></p><p>Nell’usare <span class="c003">copy.copy</span> per duplicare un Rettangolo, noterete che copia l’oggetto Rettangolo ma non l’oggetto Punto contenuto.
<a id="hevea_default1280"></a></p><pre class="verbatim">&gt;&gt;&gt; box2 = copy.copy(box)
&gt;&gt;&gt; box2 is box
False
&gt;&gt;&gt; box2.angolo is box.angolo
True
</pre><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian022.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 15.3: Diagramma di oggetto.</td></tr>
</table></div>
<a id="fig.rectangle2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La Figura <a href="#fig.rectangle2">15.3</a> mostra la situazione del diagramma di oggetto.
<a id="hevea_default1281"></a>
<a id="hevea_default1282"></a></p><p>Questa operazione è chiamata <span class="c009">copia shallow</span> (o copia superficiale) perché copia l’oggetto ed ogni riferimento che contiene, ma non gli oggetti contenuti.
<a id="hevea_default1283"></a>
<a id="hevea_default1284"></a></p><p>Nella maggior parte dei casi, questo non è il comportamento ideale. Nel nostro esempio, invocare <code>accresci_rettangolo</code> su uno dei Rettangoli non influenzerebbe l’altro, ma invocare <code>sposta_rettangolo</code> su uno dei due, influenzerebbe entrambi! Tutto ciò genera confusione ed è foriero di errori.
<a id="hevea_default1285"></a>
<a id="hevea_default1286"></a></p><p>Fortunatamente, il modulo <span class="c003">copy</span> è dotato anche di un altro metodo chiamato <span class="c003">deepcopy</span> che non solo copia l’oggetto, ma anche gli oggetti a cui si riferisce, e gli oggetti a cui questi ultimi a loro volta si riferiscono, e così via. Non vi sorprenderà che questa si chiami <span class="c009">copia profonda</span>.
<a id="hevea_default1287"></a>
<a id="hevea_default1288"></a></p><pre class="verbatim">&gt;&gt;&gt; box3 = copy.deepcopy(box)
&gt;&gt;&gt; box3 is box
False
&gt;&gt;&gt; box3.angolo is box.angolo
False
</pre><p>
<span class="c003">box3</span> e <span class="c003">box</span> sono oggetti completamente diversi.</p><p>Come esercizio, scrivete una versione di <code>sposta_rettangolo</code> che crei e restituisca un nuovo Rettangolo anziché modificare quello di origine.</p>
<!--TOC section id="sec187" Debug-->
<h2 class="section" id="sec187">15.7  Debug</h2><!--SEC END --><p>
<a id="hasattr"></a>
<a id="hevea_default1289"></a></p><p>Iniziando a lavorare con gli oggetti, è facile imbattersi in alcuni nuovi tipi di eccezioni. Se cercate di accedere ad un attributo che non esiste, si verifica un <span class="c003">AttributeError</span>:
<a id="hevea_default1290"></a>
<a id="hevea_default1291"></a></p><pre class="verbatim">&gt;&gt;&gt; p = Punto()
&gt;&gt;&gt; p.x = 3
&gt;&gt;&gt; p.y = 4
&gt;&gt;&gt; p.z
AttributeError: Punto instance has no attribute 'z'
</pre><p>
Se non siete sicuri di che tipo sia un oggetto, potete chiederlo:
<a id="hevea_default1292"></a>
<a id="hevea_default1293"></a></p><pre class="verbatim">&gt;&gt;&gt; type(p)
&lt;class '__main__.Punto'&gt;
</pre><p>
Si può usare anche <span class="c003">isinstance</span> per controllare se un oggetto è un’istanza di una classe:
<a id="hevea_default1294"></a>
<a id="hevea_default1295"></a></p><pre class="verbatim">&gt;&gt;&gt; isinstance(p, Punto)
True
</pre><p>
Se volete sapere se un oggetto ha un certo attributo, usate la funzione predefinita <span class="c003">hasattr</span>:
<a id="hevea_default1296"></a>
<a id="hevea_default1297"></a></p><pre class="verbatim">&gt;&gt;&gt; hasattr(p, 'x')
True
&gt;&gt;&gt; hasattr(p, 'z')
False
</pre><p>
Il primo argomento può essere un qualunque oggetto, il secondo è una <em>stringa</em> che contiene il nome dell’attributo.
<a id="hevea_default1298"></a></p><p>Si può anche usare un’istruzione <span class="c003">try</span> per controllare che l’oggetto contenga gli attributi che servono:
<a id="hevea_default1299"></a>
<a id="hevea_default1300"></a></p><pre class="verbatim">try:
    x = p.x
except AttributeError:
    x = 0
</pre><p>Questa tecnica può facilitare la scrittura di funzioni che trattano tipi di dati differenti; vedremo altro su questo tema nel Paragrafo <a href="#polymorphism">17.9</a>.</p>
<!--TOC section id="sec188" Glossario-->
<h2 class="section" id="sec188">15.8  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">classe:</span></dt><dd class="dd-description"> Tipo di dato personalizzato definito dal programmatore. Una definizione di classe crea un nuovo oggetto classe.
<a id="hevea_default1301"></a>
<a id="hevea_default1302"></a></dd><dt class="dt-description"><span class="c009">oggetto classe:</span></dt><dd class="dd-description"> Oggetto che contiene le informazioni su un tipo personalizzato e che può essere usato per creare istanze del tipo.
<a id="hevea_default1303"></a></dd><dt class="dt-description"><span class="c009">istanza:</span></dt><dd class="dd-description"> Oggetto che appartiene ad una classe.
<a id="hevea_default1304"></a></dd><dt class="dt-description"><span class="c009">istanziare:</span></dt><dd class="dd-description"> Creare un nuovo oggetto.
<a id="hevea_default1305"></a></dd><dt class="dt-description"><span class="c009">attributo:</span></dt><dd class="dd-description"> Uno dei valori associati ad un oggetto, dotato di un nome.
<a id="hevea_default1306"></a>
<a id="hevea_default1307"></a></dd><dt class="dt-description"><span class="c009">oggetto contenuto (embedded):</span></dt><dd class="dd-description"> Oggetto che è contenuto come attributo di un altro oggetto (detto contenitore).
<a id="hevea_default1308"></a></dd><dt class="dt-description"><span class="c009">copia shallow:</span></dt><dd class="dd-description"> copia “superficiale” dei contenuti di un oggetto, senza includere alcun riferimento ad eventuali oggetti contenuti; è implementata grazie alla funzione <span class="c003">copy</span> del modulo <span class="c003">copy</span>.
<a id="hevea_default1309"></a></dd><dt class="dt-description"><span class="c009">copia profonda:</span></dt><dd class="dd-description"> Copia del contenuto di un oggetto e anche degli eventuali
oggetti interni e degli oggetti a loro volta contenuti in essi; è implementata grazie alla funzione <span class="c003">deepcopy</span> del modulo <span class="c003">copy</span>.
<a id="hevea_default1310"></a></dd><dt class="dt-description"><span class="c009">diagramma di oggetto:</span></dt><dd class="dd-description"> Diagramma che mostra gli oggetti, i loro attributi e i valori di questi ultimi.
<a id="hevea_default1311"></a></dd></dl>
<!--TOC section id="sec189" Esercizi-->
<h2 class="section" id="sec189">15.9  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete una definizione di classe di nome <span class="c003">Cerchio</span>, avente gli attributi
<span class="c003">centro</span> e <span class="c003">raggio</span>, dove <span class="c003">centro</span> è un oggetto Punto e <span class="c003">raggio</span> è un numero.</em></p><p><em>Istanziate un oggetto Cerchio che rappresenti un cerchio con il centro nel punto </em>(150, 100)<em> e di raggio 75.</em></p><p><em>Scrivete una funzione di nome <code>punto_nel_cerchio</code>, che prenda un Cerchio e un Punto e restituisca True se il punto giace dentro il cerchio, circonferenza compresa.</em></p><p><em>Scrivete una funzione di nome <code>rett_nel_cerchio</code>, che prenda un Cerchio e un Rettangolo e restituisca True se il rettangolo giace interamente all’interno del cerchio, circonferenza compresa.</em></p><p><em>Scrivete una funzione di nome <code>rett_cerchio_sovrapp</code>, che prenda un Cerchio e un Rettangolo e restituisca True se almeno uno degli angoli del Rettangolo ricade all’interno del cerchio. Oppure, più difficile, se una qualunque porzione del Rettangolo ricade all’interno del cerchio.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/Circle.py"><em><span class="c003">http://thinkpython2.com/code/Circle.py</span></em></a><em>.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Scrivete una funzione di nome <code>disegna_rett</code> che prenda un oggetto Turtle e
un Rettangolo e usi la Tartaruga per disegnare il Rettangolo. Vedere il
Capitolo </em><a href="#turtlechap"><em>4</em></a><em> per esempi di uso degli oggetti Turtle.</em></p><p><em>Scrivete una funzione di nome <code>disegna_cerchio</code> che prenda un oggetto Turtle e un Cerchio, e disegni il Cerchio.</em></p><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/draw.py"><em><span class="c003">http://thinkpython2.com/code/draw.py</span></em></a><em>.</em></p></div>
<!--TOC chapter id="sec190" Classi e funzioni-->
<h1 class="chapter" id="sec190">Chapter 16  Classi e funzioni</h1><!--SEC END --><p>
<a id="time"></a></p><p>Ora che sappiamo come creare dei nuovi tipi, il passo successivo è scrivere delle funzioni che prendano i tipi personalizzati come parametri e restituiscano dei risultati. In questo capitolo presenterò anche lo “stile di programmazione funzionale” e due nuove tecniche di sviluppo.</p><p>Il codice degli esempi di questo capitolo è scaricabile dal sito
<a href="http://thinkpython2.com/code/Time1.py"><span class="c003">http://thinkpython2.com/code/Time1.py</span></a>.
Le soluzioni degli esercizi si trovano qui:
<a href="http://thinkpython2.com/code/Time1_soln.py"><span class="c003">http://thinkpython2.com/code/Time1_soln.py</span></a>.</p>
<!--TOC section id="sec191" Tempo-->
<h2 class="section" id="sec191">16.1  Tempo</h2><!--SEC END --><p>
<a id="isafter"></a></p><p>Facciamo un altro esempio di tipo personalizzato, creato dal programmatore, e definiamo una classe chiamata <span class="c003">Tempo</span> che permette di rappresentare un’ora del giorno:
<a id="hevea_default1312"></a>
<a id="hevea_default1313"></a>
<a id="hevea_default1314"></a></p><pre class="verbatim">class Tempo:
    """Rappresenta un'ora del giorno.
       
    attributi: ora, minuto, secondo
    """
</pre><p>
Possiamo creare un nuovo oggetto <span class="c003">Tempo</span>, assegnandogli tre attributi per le
ore, i minuti e i secondi:</p><pre class="verbatim">tempo = Tempo()
tempo.ora = 11
tempo.minuto = 59
tempo.secondo = 30
</pre><p>
Il diagramma di stato dell’oggetto <span class="c003">Tempo</span> è riportato in Figura <a href="#fig.time">16.1</a>.
<a id="hevea_default1315"></a>
<a id="hevea_default1316"></a></p><p>Provate ora a scrivete una funzione di nome <code>stampa_tempo</code> che accetti un oggetto Tempo come argomento e ne stampi il risultato nel formato <span class="c003">ore:minuti:secondi</span>.
Suggerimento: la sequenza di formato <code>'%.2d'</code> stampa un intero usando almeno due cifre, compreso uno zero iniziale dove necessario.</p><p>Scrivete poi una funzione booleana <code>viene_dopo</code> che riceva come argomenti due oggetti Tempo, <span class="c003">t1</span> e <span class="c003">t2</span>, e restituisca <span class="c003">True</span> se <span class="c003">t1</span> è temporalmente successivo a <span class="c003">t2</span> e <span class="c003">False</span> in caso contrario. Opzione più difficile: non usate un’istruzione <span class="c003">if</span>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian023.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 16.1: Diagramma di oggetto.</td></tr>
</table></div>
<a id="fig.time"></a>
<div class="center"><hr class="c019"></div></blockquote>
<!--TOC section id="sec192" Funzioni pure-->
<h2 class="section" id="sec192">16.2  Funzioni pure</h2><!--SEC END --><p>
<a id="hevea_default1317"></a>
<a id="hevea_default1318"></a></p><p>Nei prossimi paragrafi scriveremo due funzioni che sommano dei valori, espressi in termini temporali. Illustreremo così due tipi di funzioni: le funzioni pure e i modificatori. Dimostreremo anche una tecnica di sviluppo che chiameremo <span class="c009">prototipo ed evoluzioni</span>, che è un modo di affrontare un problema complesso partendo da un prototipo semplice e trattando poi in maniera incrementale gli aspetti di maggior complessità.</p><p>Ecco un semplice prototipo della funzione <code>somma_tempo</code>:</p><pre class="verbatim">def somma_tempo(t1, t2):
    somma = Tempo()
    somma.ora = t1.ora + t2.ora
    somma.minuto = t1.minuto + t2.minuto
    somma.secondo = t1.secondo + t2.secondo
    return somma
</pre><p>
La funzione crea un nuovo oggetto <span class="c003">Tempo</span>, ne inizializza gli attributi, e restituisce un riferimento al nuovo oggetto. Questa è detta <span class="c009">funzione pura</span>, perché non modifica alcuno degli oggetti che le vengono passati come argomento e, oltre a restituire un valore, non ha effetti visibili come visualizzare valori o chiedere input all’utente.
<a id="hevea_default1319"></a></p><p>Per provare questa funzione, creiamo due oggetti Tempo: <span class="c003">inizio</span>
che contiene l’ora di inizio di un film, come <em>I Monty Python e il Sacro Graal</em>, e <span class="c003">durata</span> che contiene la durata del film, che è un’ora e 35 minuti.
<a id="hevea_default1320"></a></p><p><code>somma_tempo</code> ci dirà a che ora finisce il film.</p><pre class="verbatim">&gt;&gt;&gt; inizio = Tempo()
&gt;&gt;&gt; inizio.ora = 9
&gt;&gt;&gt; inizio.minuto = 45
&gt;&gt;&gt; inizio.secondo =  0

&gt;&gt;&gt; durata = Tempo()
&gt;&gt;&gt; durata.ora = 1
&gt;&gt;&gt; durata.minuto = 35
&gt;&gt;&gt; durata.secondo = 0

&gt;&gt;&gt; fine = somma_tempo(inizio, durata)
&gt;&gt;&gt; stampa_tempo(fine)
10:80:00
</pre><p>
Il risultato, <span class="c003">10:80:00</span> non è soddisfacente. Il problema è che questa funzione non gestisce correttamente i casi in cui la somma dei minuti e dei secondi equivale o supera sessanta. Quando questo accade, dobbiamo “riportare” i 60 secondi come minuto ulteriore, o i 60 minuti come ora ulteriore.
<a id="hevea_default1321"></a></p><p>Ecco allora una versione migliorata della funzione:</p><pre class="verbatim">def somma_tempo(t1, t2):
    somma = Tempo()
    somma.ora = t1.ora + t2.ora
    somma.minuto = t1.minuto + t2.minuto
    somma.secondo = t1.secondo + t2.secondo

    if somma.secondo &gt;= 60:
        somma.secondo -= 60
        somma.minuto += 1

    if somma.minuto &gt;= 60:
        somma.minuto -= 60
        somma.ora += 1

    return somma
</pre><p>
Sebbene questa funzione sia corretta, comincia ad essere lunga. Tra poco vedremo un’alternativa più concisa.</p>
<!--TOC section id="sec193" Modificatori-->
<h2 class="section" id="sec193">16.3  Modificatori</h2><!--SEC END --><p>
<a id="increment"></a>
<a id="hevea_default1322"></a>
<a id="hevea_default1323"></a></p><p>Ci sono casi in cui è utile che una funzione possa modificare gli oggetti che assume come parametri. I cambiamenti risulteranno visibili anche al chiamante. Funzioni che si comportano in questo modo sono dette <span class="c009">modificatori</span>.
<a id="hevea_default1324"></a></p><p><span class="c003">incremento</span>, che aggiunge un dato numero di secondi ad un oggetto <span class="c003">Tempo</span>, può essere scritta intuitivamente come modificatore. Ecco un primo abbozzo della funzione:</p><pre class="verbatim">def incremento(tempo, secondi):
    tempo.secondo += secondi

    if tempo.secondo &gt;= 60:
        tempo.secondo -= 60
        tempo.minuto += 1

    if tempo.minuto &gt;= 60:
        tempo.minuto -= 60
        tempo.ora += 1
</pre><p>
La prima riga esegue l’operazione di addizione fondamentale, mentre le successive controllano i casi particolari che abbiamo già visto prima.
<a id="hevea_default1325"></a></p><p>Questa funzione è corretta? Cosa succede se <span class="c003">secondi</span>
è molto più grande di 60? </p><p>In questo caso non è più sufficiente un unico riporto tra secondi e minuti: dobbiamo fare in modo di ripetere il controllo più volte, finché <span class="c003">tempo.secondo</span> diventa minore di 60. Allora, una possibile soluzione è quella di sostituire le istruzioni <span class="c003">if</span> con delle istruzioni <span class="c003">while</span>.
Questo renderebbe la funzione corretta, ma non molto efficiente.</p><p>Come esercizio, scrivete una versione corretta di <span class="c003">incremento</span> che non contenga alcun ciclo.</p><p>Tutto quello che può essere fatto con i modificatori può anche essere fatto con le funzioni pure. Tanto è vero che alcuni linguaggi di programmazione prevedono unicamente l’uso di funzioni pure. Si può affermare che i programmi che utilizzano funzioni pure sono più veloci da sviluppare e meno soggetti ad errori rispetto a quelli che fanno uso dei modificatori. Ma in qualche caso i modificatori convengono, perché i programmi funzionali risultano meno efficienti.</p><p>In linea generale, raccomando di usare funzioni pure quando possibile e usare i modificatori solo se c’è un evidente vantaggio nel farlo. Questo tipo di approccio può essere definito <span class="c009">stile di programmazione funzionale</span>.
<a id="hevea_default1326"></a></p><p>Per esercizio, scrivete una versione “pura” di <span class="c003">incremento</span> che crei e restituisca un nuovo oggetto Tempo anziché modificare il parametro.</p>
<!--TOC section id="sec194" Sviluppo prototipale e Sviluppo pianificato-->
<h2 class="section" id="sec194">16.4  Sviluppo prototipale e Sviluppo pianificato</h2><!--SEC END --><p>
<a id="prototype"></a>
<a id="hevea_default1327"></a>
<a id="hevea_default1328"></a>
<a id="hevea_default1329"></a>
<a id="hevea_default1330"></a></p><p>La tecnica di sviluppo del programma che sto illustrando in questo Capitolo è detta “prototipo ed evoluzioni”: per ogni funzione, si inizia scrivendo una versione grezza (prototipo) che effettui solo i calcoli fondamentali, provandola e via via migliorandola e correggendo gli errori.</p><p>Sebbene questo approccio possa essere abbastanza efficace, specie se non avete una adeguata conoscenza del problema, può condurre a scrivere del codice inutilmente complesso (perché deve affrontare molti casi particolari) e poco affidabile (dato che è difficile essere certi che tutti gli errori siano stati rimossi).</p><p>Un’alternativa è lo <span class="c009">sviluppo pianificato</span>, nel quale una conoscenza approfondita degli aspetti del problema da affrontare rende la programmazione molto più semplice. Nel nostro caso, questa conoscenza sta nel fatto che l’oggetto Tempo è rappresentabile da un numero a tre cifre in base numerica 60! (vedere <a href="http://it.wikipedia.org/wiki/Sistema_sessagesimale"><span class="c003">http://it.wikipedia.org/wiki/Sistema_sessagesimale</span></a>.) L’attributo
<span class="c003">secondo</span> è la “colonna delle unità”, l’attributo <span class="c003">minuto</span>
è la “colonna delle sessantine”, e l’attributo <span class="c003">ora</span> quella della “trecentosessantine”.
<a id="hevea_default1331"></a></p><p>Quando abbiamo scritto <code>somma_tempo</code> e <span class="c003">incremento</span>, stavamo a tutti gli effetti calcolando una addizione in base 60, e questo è il motivo per cui dovevamo gestire i riporti tra secondi e minuti e tra minuti e ore.
<a id="hevea_default1332"></a></p><p>Questa osservazione ci suggerisce un altro tipo di approccio al problema: possiamo convertire l’oggetto Tempo in un numero intero e approfittare della capacità del computer di effettuare operazioni sui numeri interi.</p><p>Questa funzione converte Tempo in un intero:</p><pre class="verbatim">def tempo_in_int(tempo):
    minuti = tempo.ora * 60 + tempo.minuto
    secondi = minuti * 60 + tempo.secondo
    return secondi
</pre><p>
E questa è la funzione inversa, che converte un intero in un Tempo (ricordate che <span class="c003">divmod</span> divide il primo argomento per il secondo e restituisce una tupla che contiene il quoziente e il resto).
<a id="hevea_default1333"></a></p><pre class="verbatim">def int_in_tempo(secondi):
    tempo = Tempo()
    minuti, tempo.secondo = divmod(secondi, 60)
    tempo.ora, tempo.minuto = divmod(minuti, 60)
    return tempo
</pre><p>
Per convincervi della esattezza di queste funzioni, pensateci un po’ su e fate qualche prova. Una maniera di collaudarle è controllare che <code>tempo_in_int(int_in_tempo(x)) == x</code> per vari valori di <span class="c003">x</span>. Questo è un esempio di controllo di coerenza.
<a id="hevea_default1334"></a></p><p>Quando vi siete convinti, potete usarle per riscrivere <code>somma_tempo</code>:</p><pre class="verbatim">def somma_tempo(t1, t2):
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
</pre><p>
Questa versione è più concisa dell’originale e più facile da verificare.</p><p>Come esercizio, riscrivete <span class="c003">incremento</span> usando <code>tempo_in_int</code> e <code>int_in_tempo</code>.</p><p>Sicuramente, la conversione numerica da base 60 a base 10 e viceversa è più astratta e meno immediata rispetto al lavoro diretto con i tempi, che è istintivamente migliore.</p><p>Ma avendo l’intuizione di trattare i tempi come numeri in base 60, e investendo il tempo necessario per scrivere le funzioni di conversione (<code>tempo_in_int</code> e <code>int_in_tempo</code>), abbiamo ottenuto un programma molto più corto, facile da leggere e correggere, e più affidabile.</p><p>Risulta anche più semplice aggiungere nuove caratteristiche, in un secondo tempo. Ad esempio, immaginate di dover sottrarre due Tempi per determinare l’intervallo trascorso. L’approccio iniziale avrebbe reso necessaria l’implementazione di una sottrazione con il prestito. Invece, con le funzioni di conversione, è molto più facile e rapido avere un programma corretto.
<a id="hevea_default1335"></a>
<a id="hevea_default1336"></a></p><p>Paradossalmente, qualche volta rendere un problema più difficile (o più generale) lo rende più semplice, perché ci sono meno casi particolari da gestire e minori possibilità di errore.</p>
<!--TOC section id="sec195" Debug-->
<h2 class="section" id="sec195">16.5  Debug</h2><!--SEC END --><p>
<a id="hevea_default1337"></a></p><p>Un oggetto Tempo è ben impostato se i valori di <span class="c003">minuto</span> e <span class="c003">secondo</span> sono compresi tra 0 e 60 (zero incluso ma 60 escluso) e se 
<span class="c003">ora</span> è positiva. <span class="c003">ora</span> e <span class="c003">minuto</span> devono essere interi, ma potremmo anche permettere a <span class="c003">secondo</span> di avere una parte decimale.
<a id="hevea_default1338"></a></p><p>Requisiti come questi sono detti <span class="c009">invarianti</span> perché devono essere sempre soddisfatti. In altre parole, se non sono soddisfatti significa che qualcosa non è andato per il verso giusto.</p><p>Scrivere del codice per controllare le invarianti può servire a trovare errori e a identificarne le cause. Per esempio, potete scrivere una funzione
<code>tempo_valido</code> che prende un oggetto Tempo e restituisce
<span class="c003">False</span> se viola un’invariante:</p><pre class="verbatim">def tempo_valido(tempo):
    if tempo.ora &lt; 0 or tempo.minuto &lt; 0 or tempo.secondo &lt; 0:
        return False
    if tempo.minuto &gt;= 60 or tempo.secondo &gt;= 60:
        return False
    return True
</pre><p>
All’inizio di ogni funzione, potete controllare l’argomento per assicurarvi della sua validità:
<a id="hevea_default1339"></a>
<a id="hevea_default1340"></a></p><pre class="verbatim">def somma_tempo(t1, t2):
    if not tempo_valido(t1) or not tempo_valido(t2):
        raise ValueError, 'oggetto Tempo non valido in somma_tempo'
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
</pre><p>
Oppure potete usare un’istruzione <span class="c003">assert</span>, che controlla una data invariante e solleva un’eccezione in caso di difetti:
<a id="hevea_default1341"></a>
<a id="hevea_default1342"></a></p><pre class="verbatim">def somma_tempo(t1, t2):
    assert tempo_valido(t1) and tempo_valido(t2)
    secondi = tempo_in_int(t1) + tempo_in_int(t2)
    return int_in_tempo(secondi)
</pre><p>
Le istruzioni <span class="c003">assert</span> sono utili perché permettono di distinguere il codice che tratta le condizioni normali da quello che controlla gli errori.</p>
<!--TOC section id="sec196" Glossario-->
<h2 class="section" id="sec196">16.6  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">prototipo ed evoluzioni:</span></dt><dd class="dd-description"> Tecnica di sviluppo del programma a partire da un prototipo che viene gradualmente provato, esteso e migliorato.
<a id="hevea_default1343"></a></dd><dt class="dt-description"><span class="c009">sviluppo pianificato:</span></dt><dd class="dd-description"> Tecnica di sviluppo che comporta profonde conoscenze del problema e maggiore pianificazione rispetto allo sviluppo incrementale o per prototipo.
<a id="hevea_default1344"></a></dd><dt class="dt-description"><span class="c009">funzione pura:</span></dt><dd class="dd-description"> Funzione che non modifica gli oggetti ricevuti come argomenti. La maggior parte delle funzioni pure sono produttive.
<a id="hevea_default1345"></a></dd><dt class="dt-description"><span class="c009">modificatore:</span></dt><dd class="dd-description"> Funzione che cambia uno o più oggetti ricevuti come argomenti. La maggior parte dei modificatori sono vuoti, ovvero restituiscono <span class="c003">None</span>.
<a id="hevea_default1346"></a></dd><dt class="dt-description"><span class="c009">stile di programmazione funzionale:</span></dt><dd class="dd-description"> Stile di programmazione in cui la maggior parte delle funzioni è pura.
<a id="hevea_default1347"></a></dd><dt class="dt-description"><span class="c009">invariante:</span></dt><dd class="dd-description"> Condizione che deve sempre essere vera durante l’esecuzione del programma.
<a id="hevea_default1348"></a></dd><dt class="dt-description"><span class="c009">istruzione assert:</span></dt><dd class="dd-description"> Istruzione che controlla una condizione e solleva un’eccezione se fallisce.
<a id="hevea_default1349"></a>
<a id="hevea_default1350"></a></dd></dl>
<!--TOC section id="sec197" Esercizi-->
<h2 class="section" id="sec197">16.7  Esercizi</h2><!--SEC END --><p>Il codice degli esempi di questo capitolo è scaricabile dal sito
<a href="http://thinkpython2.com/code/Time1.py"><span class="c003">http://thinkpython2.com/code/Time1.py</span></a>; le soluzioni degli esercizi si trovano in <a href="http://thinkpython2.com/code/Time1_soln.py"><span class="c003">http://thinkpython2.com/code/Time1_soln.py</span></a>.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scrivete una funzione di nome <code>moltiplica_tempo</code> che accetti un oggetto Tempo e un numero, e restituisca un nuovo oggetto Tempo che contiene il prodotto del Tempo iniziale per il numero.</em></p><p><em>Usate poi <code>moltiplica_tempo</code> per scrivere una funzione che prenda un oggetto Tempo che rappresenta il tempo finale di una gara, e un numero che rappresenta la distanza percorsa, e restituisca un oggetto Tempo che rappresenta la media di gara (tempo al chilometro).
</em><a id="hevea_default1351"></a></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default1352"></a>
<a id="hevea_default1353"></a><p><em>Il modulo <span class="c003">datetime</span> fornisce l’oggetto <span class="c003">time</span>, simile all’oggetto Tempo di questo capitolo, ma che contiene un ricco insieme di metodi e operatori. Leggetene la documentazione sul sito </em><a href="http://docs.python.org/3/library/datetime.html"><span class="c003"><em>http://docs.python.org/3/library/datetime.html</em></span></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Usate il modulo <span class="c003">datetime</span> per scrivere un programma che ricavi la data odierna e visualizzi il giorno della settimana.</em></li><li class="li-enumerate"><em>Scrivete un programma che riceva una data di nascita come input e visualizzi l’età dell’utente e il numero di giorni, ore, minuti e secondi che mancano al prossimo compleanno.
</em><a id="hevea_default1354"></a></li><li class="li-enumerate"><em>Date due persone nate in giorni diversi, esiste un giorno in cui uno ha un’età doppia dell’altro. Questo è il loro “Giorno del Doppio”. Scrivete un programma che prenda due date di nascita e calcoli quando si verifica il “Giorno del Doppio”.</em></li><li class="li-enumerate"><em>Un po’ più difficile: scrivetene una versione più generale che calcoli il giorno in cui una persona ha </em><span class="c008">n</span><em> volte l’età di un’altra.
</em><a id="hevea_default1355"></a></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/double.py"><em><span class="c003">http://thinkpython2.com/code/double.py</span></em></a></p></div>
<!--TOC chapter id="sec198" Classi e metodi-->
<h1 class="chapter" id="sec198">Chapter 17  Classi e metodi</h1><!--SEC END --><p>Anche se abbiamo usato alcune delle caratteristiche <em>object-oriented</em> di Python, i programmi degli ultimi due capitoli non sono del tutto orientati agli oggetti, perché non mettono in evidenza le relazioni che esistono tra i tipi personalizzati e le funzioni che operano su di essi. Il passo successivo è di trasformare queste funzioni in metodi, in modo da rendere esplicite queste relazioni.</p><p>Il codice degli esempi di questo capitolo è scaricabile dal sito
<a href="http://thinkpython2.com/code/Time2.py"><span class="c003">http://thinkpython2.com/code/Time2.py</span></a>, e le soluzioni degli esercizi da <a href="http://thinkpython2.com/code/Point2_soln.py"><span class="c003">http://thinkpython2.com/code/Point2_soln.py</span></a>.</p>
<!--TOC section id="sec199" Funzionalità orientate agli oggetti-->
<h2 class="section" id="sec199">17.1  Funzionalità orientate agli oggetti</h2><!--SEC END --><p>
<a id="hevea_default1356"></a></p><p>Python è un <span class="c009">linguaggio di programmazione orientato agli oggetti</span>, in altre parole contiene delle funzionalità a supporto della programmazione orientata agli oggetti, che ha le seguenti caratteristiche distintive:</p><ul class="itemize"><li class="li-itemize">I programmi includono definizioni di classi e metodi. </li><li class="li-itemize">Buona parte dell’elaborazione è espressa in termini di operazioni sugli oggetti.</li><li class="li-itemize">Gli oggetti corrispondono spesso ad un oggetto o concetto del mondo reale, mentre i metodi che operano sugli oggetti corrispondono spesso al modo in cui gli oggetti interagiscono tra loro nella realtà quotidiana.</li></ul><p>Per esempio, la classe <span class="c003">Tempo</span> definita nel Capitolo <a href="#time">16</a>
corrisponde al modo in cui le persone pensano alle ore del giorno, e le funzioni che abbiamo definite corrispondono al tipo di operazioni che le persone fanno con il tempo. Allo stesso modo, le classi <span class="c003">Punto</span> e <span class="c003">Rettangolo</span> nel Capitolo <a href="#clobjects">15</a> corrispondono ai rispettivi concetti matematici.</p><p>Finora, non abbiamo tratto vantaggio dalle capacità di supporto della programmazione orientata agli oggetti fornite da Python. A dire il vero, queste funzionalità non sono indispensabili; piuttosto, forniscono una sintassi alternativa per fare le cose che abbiamo già fatto. Ma in molti casi questa alternativa è più concisa e si adatta in modo più accurato alla struttura del programma.</p><p>Ad esempio, nel programma <span class="c003">Time1.py</span> non c’è una chiara connessione tra la definizione della classe e le definizioni di funzione che seguono. A un esame più attento, è però evidente che tutte queste funzioni ricevono almeno un oggetto <span class="c003">Tempo</span> come argomento.
<a id="hevea_default1357"></a>
<a id="hevea_default1358"></a></p><p>Questa osservazione giustifica l’esistenza dei <span class="c009">metodi</span>; un metodo è una funzione associata ad una particolare classe. Abbiamo già visto qualche metodo per le stringhe, le liste, i dizionari e le tuple. In questo capitolo, definiremo dei metodi per i tipi personalizzati.
<a id="hevea_default1359"></a>
<a id="hevea_default1360"></a>
<a id="hevea_default1361"></a></p><p>Da un punto di vista logico, i metodi sono la stessa cosa delle funzioni, ma con due differenze sintattiche:</p><ul class="itemize"><li class="li-itemize">I metodi sono definiti all’interno di una definizione di classe, per rendere esplicita la relazione tra la classe stessa ed il metodo.</li><li class="li-itemize">La sintassi per invocare un metodo è diversa da quella usata per chiamare una funzione.</li></ul><p>Nei prossimi paragrafi prenderemo le funzioni scritte nei due capitoli precedenti e le trasformeremo in metodi. Questa trasformazione è puramente meccanica e si fa seguendo una serie di passi: se siete in grado di convertire da funzione a metodo e viceversa, riuscirete anche a scegliere la forma migliore, qualsiasi cosa dobbiate fare.</p>
<!--TOC section id="sec200" Stampa di oggetti-->
<h2 class="section" id="sec200">17.2  Stampa di oggetti</h2><!--SEC END --><p>
<a id="hevea_default1362"></a></p><p>Nel Capitolo <a href="#time">16</a>, abbiamo definito una classe chiamata
<span class="c003">Tempo</span>, e nel Paragrafo <a href="#isafter">16.1</a>, avete scritto una funzione di nome <code>stampa_tempo</code>:</p><pre class="verbatim">class Tempo:
    """Rappresenta un'ora del giorno."""

def stampa_tempo(tempo):
    print('%.2d:%.2d:%.2d' % (tempo.ora, tempo.minuto, tempo.secondo))
</pre><p>
Per chiamare questa funzione occorre passare un oggetto <span class="c003">Tempo</span> come argomento:</p><pre class="verbatim">&gt;&gt;&gt; inizio = Tempo()
&gt;&gt;&gt; inizio.ora = 9
&gt;&gt;&gt; inizio.minuto = 45
&gt;&gt;&gt; inizio.secondo = 00
&gt;&gt;&gt; stampa_tempo(inizio)
09:45:00
</pre><p>
Per trasformare <code>stampa_tempo</code> in un metodo, tutto quello che dobbiamo fare è spostare la definizione della funzione all’interno della definizione della classe. Notate bene la modifica nell’indentazione.
<a id="hevea_default1363"></a></p><pre class="verbatim">class Tempo:
    def stampa_tempo(tempo):
        print('%.2d:%.2d:%.2d' % (tempo.ora, tempo.minuto, tempo.secondo))
</pre><p>
Ora ci sono due modi di chiamare <code>stampa_tempo</code>. Il primo (e meno usato) è utilizzare la sintassi delle funzioni:
<a id="hevea_default1364"></a>
<a id="hevea_default1365"></a></p><pre class="verbatim">&gt;&gt;&gt; Tempo.stampa_tempo(inizio)
09:45:00
</pre><p>
In questo uso della notazione a punto, <span class="c003">Tempo</span> è il nome della classe e
<code>stampa_tempo</code> è il nome del metodo. <span class="c003">inizio</span> è passato come parametro.</p><p>Il secondo modo, più conciso, è usare la sintassi dei metodi:
<a id="hevea_default1366"></a></p><pre class="verbatim">&gt;&gt;&gt; inizio.stampa_tempo()
09:45:00
</pre><p>
Sempre usando la <em>dot notation</em>, <code>stampa_tempo</code> è ancora il nome del metodo, mentre <span class="c003">inizio</span> è l’oggetto sul quale il metodo è invocato, che è chiamato il <span class="c009">soggetto</span>. Come il soggetto di una frase è ciò a cui si riferisce la frase, il soggetto del metodo è ciò a cui si applica l’invocazione del metodo.
<a id="hevea_default1367"></a></p><p>All’interno del metodo, il soggetto viene assegnato al primo dei parametri: in questo caso, <span class="c003">inizio</span> viene assegnato a <span class="c003">tempo</span>.
<a id="hevea_default1368"></a>
<a id="hevea_default1369"></a></p><p>Per convenzione, il primo parametro di un metodo viene chiamato <span class="c003">self</span>, di conseguenza è bene riscrivere <code>stampa_tempo</code> così:</p><pre class="verbatim">class Tempo:
    def stampa_tempo(self):
        print('%.2d:%.2d:%.2d' % (self.ora, self.minuto, self.secondo))
</pre><p>
La ragione di questa convenzione è una metafora implicita:
<a id="hevea_default1370"></a></p><ul class="itemize"><li class="li-itemize">La sintassi di una chiamata di funzione, <code>stampa_tempo(inizio)</code>,
suggerisce che la funzione è la parte attiva, che dice qualcosa del tipo: “Ehi, <code>stampa_tempo</code>! Ti passo un oggetto da stampare!”</li><li class="li-itemize">Nella programmazione orientata agli oggetti, la parte attiva sono gli oggetti. L’invocazione di un metodo come <code>inizio.stampa_tempo()</code> dice:
“Ehi, <span class="c003">inizio</span>! Stampa te stesso!”</li></ul><p>Questo cambio di prospettiva sarà anche più elegante, ma cogliere la sua utilità non è immediato. Nei semplici esempi che abbiamo visto finora, può non esserlo. Ma in altri casi, spostare la responsabilità dalle funzioni agli oggetti rende possibile scrivere funzioni (o metodi) più versatili e rende più facile mantenere e riusare il codice.</p><p>Come esercizio, riscrivete <code>tempo_in_int</code> (vedere Paragrafo <a href="#prototype">16.4</a>) come metodo.
Potreste pensare di riscrivere anche <code>int_in_tempo</code> come metodo, ma non avrebbe molto senso: non vi sarebbe alcun oggetto sul quale invocarlo.</p>
<!--TOC section id="sec201" Un altro esempio-->
<h2 class="section" id="sec201">17.3  Un altro esempio</h2><!--SEC END --><p>
<a id="hevea_default1371"></a></p><p>Ecco una versione di <span class="c003">incremento</span> (vedere Paragrafo <a href="#increment">16.3</a>),
riscritto come metodo:</p><pre class="verbatim"># all'interno della classe Tempo:

    def incremento(self, secondi):
        secondi += self.tempo_in_int()
        return int_in_tempo(secondi)
</pre><p>
Questa versione presuppone che <code>tempo_in_int</code> sia stato scritto come metodo. Notate anche che si tratta di una funzione pura e non un modificatore.</p><p>Ecco come invocare <span class="c003">incremento</span>:</p><pre class="verbatim">&gt;&gt;&gt; inizio.stampa_tempo()
09:45:00
&gt;&gt;&gt; fine = inizio.incremento(1337)
&gt;&gt;&gt; fine.stampa_tempo()
10:07:17
</pre><p>
Il soggetto, <span class="c003">inizio</span>, viene assegnato quale primo parametro, a
<span class="c003">self</span>. L’argomento, <span class="c003">1337</span>, viene assegnato quale secondo parametro, a <span class="c003">secondi</span>.</p><p>Questo meccanismo può confondere le idee, specie se commettete qualche errore. Per esempio, se invocate <span class="c003">incremento</span> con due argomenti ottenete:
<a id="hevea_default1372"></a>
<a id="hevea_default1373"></a></p><pre class="verbatim">&gt;&gt;&gt; fine = inizio.incremento(1337, 460)
TypeError: incremento() takes 2 positional arguments but 3 were given
</pre><p>
Il messaggio di errore a prima vista non è chiaro, perché ci sono solo due argomenti tra parentesi. Ma bisogna tener conto che anche il soggetto è considerato un argomento, ecco perché in totale fanno tre.</p><p>Tra parentesi, un <span class="c009">argomento posizionale</span> è un argomento privo di nome di un parametro; cioè, non è un argomento con nome. In questa chiamata di funzione:
<a id="hevea_default1374"></a>
<a id="hevea_default1375"></a></p><pre class="verbatim">sketch(pappagallo, gabbia, morto=True)
</pre><p><span class="c003">pappagallo</span> e <span class="c003">gabbia</span> sono argomenti posizionali, e <span class="c003">morto</span> è un argomento con nome.</p>
<!--TOC section id="sec202" Un esempio più complesso-->
<h2 class="section" id="sec202">17.4  Un esempio più complesso</h2><!--SEC END --><p><code>viene_dopo</code> (vedere Paragrafo <a href="#isafter">16.1</a>) è leggermente più complesso da riscrivere come metodo, perché richiede come parametri due oggetti Tempo. In questo caso, la convenzione prevede di denominare il primo parametro <span class="c003">self</span> e il secondo <span class="c003">other</span>:
<a id="hevea_default1376"></a>
<a id="hevea_default1377"></a></p><pre class="verbatim"># all'interno della classe Tempo:

    def viene_dopo(self, other):
        return self.tempo_in_int() &gt; other.tempo_in_int()
</pre><p>
Per usare questo metodo, lo dovete invocare su un oggetto e passare l’altro come argomento:</p><pre class="verbatim">&gt;&gt;&gt; fine.viene_dopo(inizio)
True
</pre><p>
Una particolarità di questa sintassi è che si legge quasi come in italiano:
“fine viene dopo inizio?”</p>
<!--TOC section id="sec203" Il metodo speciale init-->
<h2 class="section" id="sec203">17.5  Il metodo speciale init</h2><!--SEC END --><p>
<a id="hevea_default1378"></a>
<a id="hevea_default1379"></a></p><p>Il metodo init (abbreviazione di <em>initialization</em>, ovvero inizializzazione) è un metodo speciale che viene invocato quando un oggetto viene istanziato. Il suo nome completo è <code>__init__</code> (due caratteri underscore, 
seguiti da <span class="c003">init</span>, e da altri due underscore). Un metodo init per la classe <span class="c003">Tempo</span> può essere il seguente:</p><pre class="verbatim"># all'interno della classe Tempo:

    def __init__(self, ora=0, minuto=0, secondo=0):
        self.ora = ora
        self.minuto = minuto
        self.secondo = secondo
</pre><p>
È prassi che i parametri di <code>__init__</code> abbiano gli stessi nomi degli attributi. L’istruzione</p><pre class="verbatim">        self.ora = ora
</pre><p>
memorizza il valore del parametro <span class="c003">ora</span> come attributo di <span class="c003">self</span>.
<a id="hevea_default1380"></a>
<a id="hevea_default1381"></a>
<a id="hevea_default1382"></a></p><p>I parametri sono opzionali, quindi se chiamate <span class="c003">Tempo</span> senza argomenti, ottenete i valori di default.</p><pre class="verbatim">&gt;&gt;&gt; tempo = Tempo()
&gt;&gt;&gt; tempo.stampa_tempo()
00:00:00
</pre><p>
Se fornite un argomento, esso va a sovrascrivere <span class="c003">ora</span>:</p><pre class="verbatim">&gt;&gt;&gt; tempo = Tempo (9)
&gt;&gt;&gt; tempo.stampa_tempo()
09:00:00
</pre><p>
Se ne fornite due, sovrascrivono <span class="c003">ora</span> e <span class="c003">minuto</span>.</p><pre class="verbatim">&gt;&gt;&gt; tempo = Tempo(9, 45)
&gt;&gt;&gt; tempo.stampa_tempo()
09:45:00
</pre><p>
E se ne fornite tre, sovrascrivono tutti e tre i valori di default.</p><p>Per esercizio, scrivete un metodo init per la classe <span class="c003">Punto</span> che prenda <span class="c003">x</span> e <span class="c003">y</span> come parametri opzionali e li assegni agli attributi corrispondenti.
<a id="hevea_default1383"></a>
<a id="hevea_default1384"></a></p>
<!--TOC section id="sec204" Il metodo speciale <span class="c003">__str__</span>-->
<h2 class="section" id="sec204">17.6  Il metodo speciale <span class="c003">__str__</span></h2><!--SEC END --><p>
<a id="hevea_default1385"></a>
<a id="hevea_default1386"></a></p><p><code>__str__</code> è un altro metodo speciale, come <code>__init__</code>,
che ha lo scopo di restituire una rappresentazione di un oggetto in forma di stringa.
<a id="hevea_default1387"></a></p><p>Ecco ad esempio un metodo <span class="c003">str</span> per un oggetto Tempo:</p><pre class="verbatim"># all'interno della classe Tempo:

    def __str__(self):
        return '%.2d:%.2d:%.2d' % (self.ora, self.minuto, self.secondo)
</pre><p>
Quando stampate un oggetto con l’istruzione di stampa, Python invoca il metodo <span class="c003">str</span>:
<a id="hevea_default1388"></a>
<a id="hevea_default1389"></a></p><pre class="verbatim">&gt;&gt;&gt; tempo = Tempo(9, 45)
&gt;&gt;&gt; print(tempo)
09:45:00
</pre><p>
Personalmente, quando scrivo una nuova classe, quasi sempre inizio con lo scrivere <code>__init__</code>, che rende più facile istanziare un oggetto, e 
<code>__str__</code>, che è utile per il debugging.</p><p>Come esercizio, scrivete un metodo <span class="c003">str</span> per la classe <span class="c003">Punto</span>. Create un oggetto Punto e stampatelo.</p>
<!--TOC section id="sec205" Operator overloading-->
<h2 class="section" id="sec205">17.7  Operator overloading</h2><!--SEC END --><p>
<a id="operator.overloading"></a></p><p>Nei tipi personalizzati, avete la possibilità di adattare il comportamento degli operatori attraverso la definizione di altri appositi metodi speciali. Per esempio se definite il metodo speciale di nome <code>__add__</code> per la classe <span class="c003">Tempo</span>, potete poi usare l’operatore <span class="c003">+</span> sugli oggetti Tempo.
<a id="hevea_default1390"></a></p><p>Ecco come potrebbe essere scritta la definizione:
<a id="hevea_default1391"></a>
<a id="hevea_default1392"></a></p><pre class="verbatim"># all'interno della classe Tempo:

    def __add__(self, other):
        secondi = self.tempo_in_int() + other.tempo_in_int()
        return int_in_tempo(secondi)
</pre><p>
Ed ecco come può essere usata:</p><pre class="verbatim">&gt;&gt;&gt; inizio = Tempo(9, 45)
&gt;&gt;&gt; durata = Tempo(1, 35)
&gt;&gt;&gt; print(inizio + durata)
11:20:00
</pre><p>
Quando applicate l’operatore <span class="c003">+</span> agli oggetti Tempo, Python invoca
<code>__add__</code>. Quando stampate il risultato, Python invoca 
<code>__str__</code>. Accadono parecchie cose, dietro le quinte!
<a id="hevea_default1393"></a></p><p>Cambiare il comportamento degli operatori in modo che funzionino con i tipi personalizzati è chiamato <span class="c009">operator overloading</span> (letteralmente, sovraccarico degli operatori). In Python, per ogni operatore esiste un corrispondente metodo speciale, come
<code>__add__</code>. Per ulteriori dettagli consultate
<a href="http://docs.python.org/2/reference/datamodel.html#specialnames"><span class="c003">http://docs.python.org/2/reference/datamodel.html#specialnames</span></a>.</p><p>Esercitatevi scrivendo un metodo <span class="c003">add</span> per la classe Punto. </p>
<!--TOC section id="sec206" Smistamento in base al tipo-->
<h2 class="section" id="sec206">17.8  Smistamento in base al tipo</h2><!--SEC END --><p>Nel Paragrafo precedente abbiamo sommato due oggetti Tempo, ma potrebbe anche capitare di voler aggiungere un numero intero a un oggetto Tempo. Quella che segue è una versione di <code>__add__</code>
che controlla il tipo di <span class="c003">other</span> e, a seconda dei casi, invoca o
<code>somma_tempo</code> o <span class="c003">incremento</span>:</p><pre class="verbatim"># all'interno della classe Tempo:

    def __add__(self, other):
        if isinstance(other, Tempo):
            return self.somma_tempo(other)
        else:
            return self.incremento(other)

    def somma_tempo(self, other):
        secondi = self.tempo_in_int() + other.tempo_in_int()
        return int_in_tempo(secondi)

    def incremento(self, secondi):
        secondi += self.tempo_in_int()
        return int_in_tempo(secondi)
</pre><p>
La funzione predefinita <span class="c003">isinstance</span> prende un valore e un oggetto classe, e restiutisce <span class="c003">True</span> se il valore è un’istanza della classe.
<a id="hevea_default1394"></a>
<a id="hevea_default1395"></a></p><p>Quindi, se <span class="c003">other</span> è un oggetto Tempo, <code>__add__</code> invoca
<code>somma_tempo</code>. Altrimenti, considera che il parametro sia un numero, e invoca <span class="c003">incremento</span>. Questa operazione è detta <span class="c009">smistamento in base al tipo</span>, perché invia il calcolo a metodi diversi a seconda del tipo di argomento.
<a id="hevea_default1396"></a></p><p>Ecco degli esempi che usano l’operatore <span class="c003">+</span> con tipi diversi:</p><pre class="verbatim">&gt;&gt;&gt; inizio = Tempo(9, 45)
&gt;&gt;&gt; durata = Tempo(1, 35)
&gt;&gt;&gt; print(inizio + durata)
11:20:00
&gt;&gt;&gt; print(inizio + 1337)
10:07:17
</pre><p>
Sfortunatamente, questa implementazione di addizione non è commutativa. Se l’intero è il primo operando vi risulterà infatti:
<a id="hevea_default1397"></a></p><pre class="verbatim">&gt;&gt;&gt; print(1337 + inizio)
TypeError: unsupported operand type(s) for +: 'int' and 'instance'
</pre><p>
Il problema è che, invece di chiedere all’oggetto Tempo di aggiungere un intero, Python chiede all’intero di aggiungere un oggetto Tempo, ma l’intero non ha la minima idea di come farlo. Ma a questo c’è una soluzione intelligente: il metodo speciale <code>__radd__</code>, che sta per <em>right-side add</em> (“addizione lato destro”).
Questo metodo viene invocato quando un oggetto Tempo compare sul lato destro dell’operatore <span class="c003">+</span>. Eccone la definizione:
<a id="hevea_default1398"></a>
<a id="hevea_default1399"></a></p><pre class="verbatim"># all'interno della classe Tempo:

    def __radd__(self, other):
        return self.__add__(other)
</pre><p>
Ed eccolo in azione:</p><pre class="verbatim">&gt;&gt;&gt; print(1337 + inizio)
10:07:17
</pre><p>Come esercizio, scrivete un metodo <span class="c003">add</span> per i Punti che possa funzionare sia con un oggetto Punto che con una tupla: </p><ul class="itemize"><li class="li-itemize">Se il secondo operando è un Punto, il metodo deve restituire un nuovo Punto la cui coordinata <span class="c008">x</span> sia la somma delle coordinate <span class="c008">x</span> degli operandi, e lo stesso per le coordinate <span class="c008">y</span>.</li><li class="li-itemize">Se il secondo operando è una tupla, il metodo deve aggiungere il primo elemento della tupla alla coordinata <span class="c008">x</span> e il secondo elemento alla coordinata <span class="c008">y</span>, e restituire un nuovo Punto con le coordinate risultanti.</li></ul>
<!--TOC section id="sec207" Polimorfismo-->
<h2 class="section" id="sec207">17.9  Polimorfismo</h2><!--SEC END --><p>
<a id="polymorphism"></a></p><p>Lo smistamento in base al tipo è utile all’occorrenza, ma (fortunatamente) non è sempre necessario. Spesso potete evitarlo scrivendo le funzioni in modo che operino correttamente con argomenti di tipo diverso.
<a id="hevea_default1400"></a></p><p>Molte delle funzioni che abbiamo scritto per le stringhe, funzioneranno anche con qualsiasi altro tipo di sequenza.
Per esempio, nel Paragrafo <a href="#histogram">11.2</a>
abbiamo usato <span class="c003">istogramma</span> per contare quante volte ciascuna lettera appare in una parola.</p><pre class="verbatim">def istogramma(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] = d[c]+1
    return d
</pre><p>
Questa funzione è applicabile anche a liste, tuple e perfino dizionari, a condizione che gli elementi di <span class="c003">s</span> siano idonei all’hashing, in modo da poter essere usati come chiavi in <span class="c003">d</span>.</p><pre class="verbatim">&gt;&gt;&gt; t = ['spam', 'uovo', 'spam', 'spam', 'bacon', 'spam']
&gt;&gt;&gt; istogramma(t)
{'bacon': 1, 'uovo': 1, 'spam': 4}
</pre><p>
Le funzioni che sono in grado di operare con tipi diversi sono dette <span class="c009">polimorfiche</span>.
Il polimorfismo facilita il riuso del codice. Ad esempio, la funzione predefinita <span class="c003">sum</span>, che addiziona gli elementi di una sequenza, funziona alla sola condizione che gli elementi della sequenza siano addizionabili.
<a id="hevea_default1401"></a></p><p>Dato che agli oggetti Tempo abbiamo fornito un metodo <span class="c003">add</span>, funzionano con
<span class="c003">sum</span>:</p><pre class="verbatim">&gt;&gt;&gt; t1 = Tempo(7, 43)
&gt;&gt;&gt; t2 = Tempo(7, 41)
&gt;&gt;&gt; t3 = Tempo(7, 37)
&gt;&gt;&gt; totale = sum([t1, t2, t3])
&gt;&gt;&gt; print(totale)
23:01:00
</pre><p>
In linea generale, se tutte le operazioni all’interno di una funzione si possono applicare ad un dato tipo, la funzione può operare con quel tipo.</p><p>Il miglior genere di polimorfismo è quello involontario, quando scoprite che una funzione che avete già scritto può essere applicata anche ad un tipo che non avevate previsto.</p>
<!--TOC section id="sec208" Debug-->
<h2 class="section" id="sec208">17.10  Debug</h2><!--SEC END --><p>
<a id="hevea_default1402"></a></p><p>È consentito aggiungere attributi in qualsiasi momento dell’esecuzione di un programma, ma se avete oggetti dello stesso tipo che non hanno gli stessi attributi, è facile generare errori. Inizializzare tutti gli attributi di un oggetto nel metodo init è considerata una prassi migliore.
<a id="hevea_default1403"></a>
<a id="hevea_default1404"></a></p><p>Se non siete certi che un oggetto abbia un particolare attributo, potete usare la funzione predefinita <span class="c003">hasattr</span> (vedere Paragrafo <a href="#hasattr">15.7</a>).
<a id="hevea_default1405"></a>
<a id="hevea_default1406"></a>
<a id="hevea_default1407"></a>
<a id="hevea_default1408"></a></p><p>Un altro modo di accedere agli attributi è la funzione predefinita <span class="c003">vars</span>, che prende un oggetto e restituisce un dizionario che fa corrispondere nomi degli attributi (come stringhe) e i relativi valori:</p><pre class="verbatim">&gt;&gt;&gt; p = Punto(3, 4)
&gt;&gt;&gt; vars(p)
{'y': 4, 'x': 3}
</pre><p>
Per gli scopi del debug, può essere utile tenere questa funzione a portata di mano:</p><pre class="verbatim">def stampa_attributi(oggetto):
    for attr in vars(oggetto):
        print(attr, getattr(oggetto, attr))
</pre><p>
<code>stampa_attributi</code> attraversa il dizionario e stampa ciascun nome di attributo con il suo valore.
<a id="hevea_default1409"></a>
<a id="hevea_default1410"></a></p><p>La funzione predefinita <span class="c003">getattr</span> prende un oggetto e un nome di attributo (come stringa) e restituisce il valore dell’attributo.
<a id="hevea_default1411"></a>
<a id="hevea_default1412"></a></p>
<!--TOC section id="sec209" Interfaccia e implementazione-->
<h2 class="section" id="sec209">17.11  Interfaccia e implementazione</h2><!--SEC END --><p>Uno degli scopi della progettazione orientata agli oggetti è di rendere più agevole la manutenzione del software, che significa poter mantenere il programma funzionante quando altre parti del sistema vengono cambiate e poter modificare il programma per adeguarlo a dei nuovi requisiti.
<a id="hevea_default1413"></a>
<a id="hevea_default1414"></a>
<a id="hevea_default1415"></a>
<a id="hevea_default1416"></a></p><p>Un principio di progettazione che aiuta a raggiungere questo obiettivo è di tenere le interfacce separate dalle implementazioni.
Per gli oggetti, significa che i metodi esposti da una classe non devono dipendere da come vengono rappresentati gli attributi.
<a id="hevea_default1417"></a></p><p>Per esempio, in questo capitolo abbiamo sviluppato una classe che rappresenta un’ora del giorno. I metodi esposti da questa classe comprendono
<code>tempo_in_int</code>, <code>viene_dopo</code>, e <code>somma_tempo</code>.</p><p>Quei metodi possono essere implementati in diversi modi. I dettagli dell’implementazione dipendono da come rappresentiamo il tempo. In questo capitolo, gli attributi di un oggetto <span class="c003">Tempo</span> sono <span class="c003">ora</span>, <span class="c003">minuto</span>, e <span class="c003">secondo</span>.</p><p>Come alternativa, avremmo potuto sostituire quegli attributi con un singolo numero intero, come secondi trascorsi dalla mezzanotte. Con questa implementazione, alcuni metodi come <code>viene_dopo</code>, sarebbero diventati più facili da scrivere, ma altri più difficili.</p><p>Dopo aver sviluppato una nuova classe, potreste scoprire una implementazione migliore. Se altre parti del programma usano quella classe, cambiare l’interfaccia può essere dispendioso in termini di tempo e fonte di errori. </p><p>Ma se avete progettato l’interfaccia accuratamente, potete cambiare l’implementazione senza cambiare l’interfaccia, che significa che non occorre cambiare altre parti del programma.</p>
<!--TOC section id="sec210" Glossario-->
<h2 class="section" id="sec210">17.12  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">linguaggio orientato agli oggetti:</span></dt><dd class="dd-description"> Linguaggio che possiede delle caratteristiche, come tipi personalizzati e metodi, che facilitano la programmazione orientata agli oggetti. 
<a id="hevea_default1418"></a></dd><dt class="dt-description"><span class="c009">programmazione orientata agli oggetti:</span></dt><dd class="dd-description"> Paradigma di programmazione in cui i dati e le operazioni sui dati vengono organizzati in classi e metodi.
<a id="hevea_default1419"></a></dd><dt class="dt-description"><span class="c009">metodo:</span></dt><dd class="dd-description"> Funzione definita all’interno di una definizione di classe e che viene invocata su istanze di quella classe.
<a id="hevea_default1420"></a></dd><dt class="dt-description"><span class="c009">soggetto:</span></dt><dd class="dd-description"> L’oggetto sul quale viene invocato un metodo.
<a id="hevea_default1421"></a></dd><dt class="dt-description"><span class="c009">argomento posizionale:</span></dt><dd class="dd-description"> Un argomento che non include il nome di un
parametro, ovvero non è un argomento con nome.
<a id="hevea_default1422"></a>
<a id="hevea_default1423"></a></dd><dt class="dt-description"><span class="c009">operator overloading:</span></dt><dd class="dd-description"> Cambiare il comportamento di un operatore come
<span class="c003">+</span> in modo che funzioni con un tipo personalizzato.
<a id="hevea_default1424"></a>
<a id="hevea_default1425"></a></dd><dt class="dt-description"><span class="c009">smistamento in base al tipo:</span></dt><dd class="dd-description"> Schema di programmazione che controlla il tipo di un operando e invoca funzioni diverse in base ai diversi tipi.
<a id="hevea_default1426"></a></dd><dt class="dt-description"><span class="c009">polimorfico:</span></dt><dd class="dd-description"> Di una funzione che può operare con più di un tipo di dati.
<a id="hevea_default1427"></a></dd><dt class="dt-description"><span class="c009">information hiding:</span></dt><dd class="dd-description"> Principio per cui l’interfaccia di un oggetto non deve dipendere dalla sua implementazione, con particolare riferimento alla rappresentazione dei suoi attributi.
<a id="hevea_default1428"></a></dd></dl>
<!--TOC section id="sec211" Esercizi-->
<h2 class="section" id="sec211">17.13  Esercizi</h2><!--SEC END --><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Scaricate il codice degli esempi di questo capitolo
(</em><a href="http://thinkpython2.com/code/Time2.py"><span class="c003"><em>http://thinkpython2.com/code/Time2.py</em></span></a><em>). Cambiate gli attributi di <span class="c003">Tempo</span> con un singolo intero che rappresenta i secondi dalla mezzanotte. Quindi modificate i metodi (e la funzione <code>int_in_tempo</code>) in modo che funzionino con la nuova implementazione. Non dovete cambiare il codice di prova in <span class="c003">main</span>. Quando avete finito, l’output dovrebbe essere lo stesso di prima. Soluzione: </em><a href="http://thinkpython2.com/code/Time2_soln.py"><span class="c003"><em>http://thinkpython2.com/code/Time2_soln.py</em></span></a><em>.
</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="kangaroo"></a>
<a id="hevea_default1429"></a>
<a id="hevea_default1430"></a>
<a id="hevea_default1431"></a>
<a id="hevea_default1432"></a>
<a id="hevea_default1433"></a>
<a id="hevea_default1434"></a><p><em>Questo esercizio è un aneddoto monitorio su uno degli errori più comuni e difficili da trovare in Python. Scrivete una definizione di una classe di nome <span class="c003">Canguro</span> con i metodi seguenti:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Un metodo <code>__init__</code> che inizializza un attributo di nome
<code>contenuto_tasca</code> ad una lista vuota.</em></li><li class="li-enumerate"><em>Un metodo di nome <code>intasca</code> che prende un oggetto di qualsiasi tipo e lo inserisce in <code>contenuto_tasca</code>.</em></li><li class="li-enumerate"><em>Un metodo <code>__str__</code> che restituisce una stringa di rappresentazione dell’oggetto Canguro e dei contenuti della tasca.</em></li></ol><p><em>
Provate il codice creando due oggetti <span class="c003">Canguro</span>, assegnandoli a variabili di nome <span class="c003">can</span> e <span class="c003">guro</span>, e aggiungendo poi <span class="c003">guro</span> al contenuto della tasca di <span class="c003">can</span>.</em></p><p><em>Scaricate </em><a href="http://thinkpython2.com/code/BadKangaroo.py"><em><span class="c003">http://thinkpython2.com/code/BadKangaroo.py</span></em></a><em>. Contiene una soluzione al problema precedente, ma con un grande e serio errore. Trovatelo e sistematelo. </em></p><p><em>Se vi bloccate, potete scaricare
</em><a href="http://thinkpython2.com/code/GoodKangaroo.py"><span class="c003"><em>http://thinkpython2.com/code/GoodKangaroo.py</em></span></a><em>, che spiega il problema e illustra una soluzione.
</em><a id="hevea_default1435"></a>
<a id="hevea_default1436"></a>
<a id="hevea_default1437"></a></p></div>
<!--TOC chapter id="sec212" Ereditarietà-->
<h1 class="chapter" id="sec212">Chapter 18  Ereditarietà</h1><!--SEC END --><p>La caratteristica più frequentemente associata alla programmazione orientata agli oggetti è l’<span class="c009">ereditarietà</span>, che è la capacità di definire una nuova classe come versione modificata di una classe già esistente.
In questo capitolo illustrerò l’ereditarietà usando delle classi che rappresentano carte da gioco, mazzi di carte e mani di poker. </p><p>Se non giocate a poker, potete leggere qualcosa in proposito sul sito <a href="http://it.wikipedia.org/wiki/Poker"><span class="c003">http://it.wikipedia.org/wiki/Poker</span></a>, ma non è un obbligo: vi spiegherò quello che serve.
<a id="hevea_default1438"></a>
<a id="hevea_default1439"></a>
<a id="hevea_default1440"></a></p><p>Il codice degli esempi di questo capitolo è scaricabile da
<a href="http://thinkpython2.com/code/Card.py"><span class="c003">http://thinkpython2.com/code/Card.py</span></a>.</p>
<!--TOC section id="sec213" Oggetti Carta-->
<h2 class="section" id="sec213">18.1  Oggetti Carta</h2><!--SEC END --><p>In un mazzo ci sono 52 carte, e ciascuna appartiene a uno tra quattro semi e a uno tra tredici valori. I semi sono Picche, Cuori, Quadri e Fiori (in ordine decrescente nel gioco del bridge). I valori sono Asso, 2, 3, 4, 5, 6, 7, 8, 9, 10, Fante, Regina e Re. A seconda del gioco, l’Asso può essere superiore al Re o inferiore al 2.
<a id="hevea_default1441"></a>
<a id="hevea_default1442"></a></p><p>Se vogliamo definire un nuovo oggetto che rappresenti una carta da gioco, è evidente quali attributi dovrebbe avere: <span class="c003">valore</span> e
<span class="c003">seme</span>. È meno evidente stabilire di che tipo devono essere questi attributi. Una possibilità è usare stringhe contenenti parole come
<code>'Picche'</code> per i semi e <code>'Regina'</code> per i valori. Ma un problema di questa implementazione è che non è facile confrontare le carte per vedere quale abbia un seme o un valore superiore.
<a id="hevea_default1443"></a>
<a id="hevea_default1444"></a>
<a id="hevea_default1445"></a>
<a id="hevea_default1446"></a></p><p>Un’alternativa è usare degli interi per <span class="c009">codificare</span> valori e semi.
In questo contesto, “codificare” significa determinare una corrispondenza tra numeri e semi o numeri e valori. Non significa che debba essere un segreto (quello è “criptare”).</p><p>Per esempio, questa tabella mostra i semi e i corrispondenti codici interi:</p><table class="c001 cellpading0"><tr><td class="c012">Picche</td><td class="c011">↦</td><td class="c012">3 </td></tr>
<tr><td class="c012">Cuori</td><td class="c011">↦</td><td class="c012">2 </td></tr>
<tr><td class="c012">Quadri</td><td class="c011">↦</td><td class="c012">1 </td></tr>
<tr><td class="c012">Fiori</td><td class="c011">↦</td><td class="c012">0
</td></tr>
</table><p>In questo modo, diventa facile confrontare le carte: siccome ai semi più alti corrispondono numeri più alti, si possono confrontare i semi confrontando i loro codici corrispondenti.</p><p>Nel caso dei valori, la corrispondenza è abbastanza immediata: ogni valore numerico corrisponde al rispettivo intero, mentre per le figure:</p><table class="c001 cellpading0"><tr><td class="c012">Fante</td><td class="c011">↦</td><td class="c012">11 </td></tr>
<tr><td class="c012">Regina</td><td class="c011">↦</td><td class="c012">12 </td></tr>
<tr><td class="c012">Re</td><td class="c011">↦</td><td class="c012">13 </td></tr>
</table><p>Uso il simbolo ↦ per chiarire che queste corrispondenze non fanno parte del programma Python. Fanno parte del progetto del programma, ma non compaiono esplicitamente nel codice.
<a id="hevea_default1447"></a>
<a id="hevea_default1448"></a></p><p>Ecco come si può presentare la definizione di classe per <span class="c003">Carta</span>:</p><pre class="verbatim">class Carta:
    """Rappresenta una carta da gioco standard."""

    def __init__(self, seme=0, valore=2):
        self.seme = seme
        self.valore = valore
</pre><p>
Come al solito, il metodo init prevede un parametro opzionale per ciascun attributo. La carta di default è il 2 di fiori.
<a id="hevea_default1449"></a>
<a id="hevea_default1450"></a></p><p>Per creare una carta, si chiama la classe <span class="c003">Carta</span> con il seme e il valore desiderati.</p><pre class="verbatim">regina_di_quadri = Carta(1, 12)
</pre>
<!--TOC section id="sec214" Attributi di classe-->
<h2 class="section" id="sec214">18.2  Attributi di classe</h2><!--SEC END --><p>
<a id="class.attribute"></a>
<a id="hevea_default1451"></a>
<a id="hevea_default1452"></a></p><p>Per stampare gli oggetti Carta in un modo comprensibile agli utenti, occorre stabilire una corrispondenza dai codici interi ai relativi semi e valori. Un modo naturale per farlo è usare delle liste di stringhe, che assegneremo a degli <span class="c009">attributi di classe</span>:</p><pre class="verbatim"># all'interno della classe Carta:

    nomi_semi = ['Fiori', 'Quadri', 'Cuori', 'Picche']
    nomi_valori = [None, 'Asso', '2', '3', '4', '5', '6', '7', 
              '8', '9', '10', 'Fante', 'Regina', 'Re']

    def __str__(self):
        return '%s di %s' % (Carta.nomi_valori[self.valore],
                             Carta.nomi_semi[self.seme])
</pre><p>
Variabili come <code>nomi_semi</code> e <code>nomi_valori</code>, che sono definite dentro la classe ma esternamente a ogni metodo, sono chiamate attributi di classe perché sono associati all’oggetto classe <span class="c003">Carta</span>.
<a id="hevea_default1453"></a>
<a id="hevea_default1454"></a></p><p>Questo termine li distingue da variabili come <span class="c003">seme</span> e <span class="c003">valore</span>, che sono chiamati <span class="c009">attributi di istanza</span> perché sono associati ad una specifica istanza.
<a id="hevea_default1455"></a></p><p>Ad entrambi i tipi si accede usando la notazione a punto. Per esempio in <code>__str__</code>, <span class="c003">self</span> è un oggetto carta e <span class="c003">self.valore</span> è il suo valore. Allo stesso modo, <span class="c003">Carta</span> è un oggetto classe, e <code>Carta.nomi_valori</code> è una lista di stringhe associata alla classe.</p><p>Ogni carta ha i suoi propri <span class="c003">seme</span> e <span class="c003">valore</span>, ma esiste una sola copia di <code>nomi_semi</code> e <code>nomi_valori</code>.</p><p>Mettendo insieme il tutto, l’espressione
<code>Carta.nomi_valori[self.valore]</code> significa “usa l’attributo <span class="c003">valore</span> dell’oggetto <span class="c003">self</span> come indice nella lista <code>nomi_valori</code>
dalla classe <span class="c003">Carta</span>, e seleziona la stringa corrispondente.”</p><p>Il primo elemento della lista <code>nomi_valori</code> è <span class="c003">None</span> perché non esiste una carta di valore zero. Includendo <span class="c003">None</span> come segnaposto, otteniamo una corrispondenza corretta per cui all’indice 2 corrisponde la stringa <code>'2'</code>, e così via. Per evitare questo trucco, avremmo potuto usare un dizionario al posto di una lista.</p><p>Con i metodi che abbiamo visto fin qui, possiamo creare e stampare i nomi delle carte:</p><pre class="verbatim">&gt;&gt;&gt; carta1 = Carta(2, 11)
&gt;&gt;&gt; print(carta1)
Fante di Cuori
</pre><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian024.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 18.1: Diagramma di oggetto.</td></tr>
</table></div>
<a id="fig.card1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La Figura <a href="#fig.card1">18.1</a> è un diagramma dell’oggetto classe <span class="c003">Carta</span> e di una Carta, sua istanza.
<span class="c003">Carta</span> è un oggetto classe, quindi è di tipo <span class="c003">type</span>. <span class="c003">carta1</span> invece è di tipo <span class="c003">Carta</span>. (Per motivi di spazio ho omesso i contenuti di <code>nomi_semi</code> e <code>nomi_valori</code>).
<a id="hevea_default1456"></a>
<a id="hevea_default1457"></a></p>
<!--TOC section id="sec215" Confrontare le carte-->
<h2 class="section" id="sec215">18.3  Confrontare le carte</h2><!--SEC END --><p>
<a id="comparecard"></a>
<a id="hevea_default1458"></a></p><p>Per i tipi predefiniti, esistono gli operatori relazionali
(<span class="c003">&lt;</span>, <span class="c003">&gt;</span>, <span class="c003">==</span>, etc.)
che permettono di confrontare i valori e determinare quale è maggiore, minore o uguale a un altro. Per i tipi personalizzati, possiamo sovrascrivere il comportamento degli operatori predefiniti grazie a un metodo speciale chiamato
<code>__lt__</code>, che sta per “<em>less than</em>”. 
<a id="hevea_default1459"></a></p><p><code>__lt__</code> richiede due parametri, <span class="c003">self</span> e <span class="c003">other</span>,
e restituisce <span class="c003">True</span> se <span class="c003">self</span> è minore di <span class="c003">other</span>.
<a id="hevea_default1460"></a>
<a id="hevea_default1461"></a></p><p>L’ordinamento corretto delle carte da gioco non è immediato. Per esempio, tra il 3 di Fiori e il 2 di Quadri, quale è più grande? Una carta ha un valore maggiore, ma l’altra ha un seme superiore. Per confrontare le carte, bisogna prima stabilire se è più importante il seme oppure il valore.</p><p>La risposta dipenderà dalle regole del gioco a cui stiamo giocando, ma per semplificare supponiamo che sia più importante il seme, per cui le carte di Picche sovrastano tutte quelle di Quadri, e così via.
<a id="hevea_default1462"></a>
<a id="hevea_default1463"></a></p><p>Deciso questo, possiamo scrivere <code>__lt__</code>:</p><pre class="verbatim"># all'interno della classe Carta:

    def __lt__(self, other):
        # controlla i semi
        if self.seme &lt; other.seme: return True
        if self.seme &gt; other.seme: return False

        # semi uguali... controlla i valori
        return self.valore &lt; other.valore

</pre><p>
Potete scriverlo anche in modo più compatto, usando un confronto di tuple:
<a id="hevea_default1464"></a>
<a id="hevea_default1465"></a></p><pre class="verbatim"># all'interno della classe Carta:

    def __lt__(self, other):
        t1 = self.seme, self.valore
        t2 = other.seme, other.valore
        return t1 &lt; t2
</pre><p>Come esercizio, scrivete un metodo <code>__lt__</code> per gli oggetti Tempo. Potete usare un confronto di tuple, ma anche prendere in considerazione di confrontare degli interi.</p>
<!--TOC section id="sec216" Mazzi di carte-->
<h2 class="section" id="sec216">18.4  Mazzi di carte</h2><!--SEC END --><p>
<a id="hevea_default1466"></a>
<a id="hevea_default1467"></a></p><p>Ora che abbiamo le carte, il prossimo passo è definire i Mazzi. Dato che un mazzo è composto di carte, è ovvio che ogni Mazzo contenga una lista di carte come attributo.
<a id="hevea_default1468"></a>
<a id="hevea_default1469"></a></p><p>Quella che segue è una definizione di classe di <span class="c003">Mazzo</span>. Il metodo init crea l’attributo <span class="c003">carte</span> e genera l’insieme standard di 52 carte:
<a id="hevea_default1470"></a>
<a id="hevea_default1471"></a>
<a id="hevea_default1472"></a>
<a id="hevea_default1473"></a></p><pre class="verbatim">class Mazzo:

    def __init__(self):
        self.carte = []
        for seme in range(4):
            for valore in range(1, 14):
                carta = Carta(seme, valore)
                self.carte.append(carta)
</pre><p>
Il modo più facile di popolare il mazzo è quello di usare un ciclo nidificato. Il ciclo più esterno enumera i semi da 0 a 3; quello interno enumera i valori da 1 a 13. Ogni iterazione crea una nuova carta del seme e valore correnti e la accoda nella lista <span class="c003">self.carte</span>.
<a id="hevea_default1474"></a>
<a id="hevea_default1475"></a></p>
<!--TOC section id="sec217" Stampare il mazzo-->
<h2 class="section" id="sec217">18.5  Stampare il mazzo</h2><!--SEC END --><p>
<a id="printdeck"></a>
<a id="hevea_default1476"></a>
<a id="hevea_default1477"></a></p><p>Ecco un metodo <code>__str__</code> per <span class="c003">Mazzo</span>:</p><pre class="verbatim">#all'interno della classe Mazzo:

    def __str__(self):
        res = []
        for carta in self.carte:
            res.append(str(carta))
        return '\n'.join(res)
</pre><p>
Questo metodo illustra un modo efficiente di accumulare una stringa lunga: costruire una lista di stringhe e poi usare il metodo delle stringhe <span class="c003">join</span>.
La funzione predefinita <span class="c003">str</span> invoca il metodo <code>__str__</code>
su ciascuna carta e restituisce la rappresentazione della stringa.
<a id="hevea_default1478"></a>
<a id="hevea_default1479"></a>
<a id="hevea_default1480"></a>
<a id="hevea_default1481"></a>
<a id="hevea_default1482"></a></p><p>Dato che invochiamo <span class="c003">join</span> su un carattere di ritorno a capo, le carte sono stampate su righe separate. Ed ecco quello che risulta:</p><pre class="verbatim">&gt;&gt;&gt; mazzo = Mazzo()
&gt;&gt;&gt; print(mazzo)
Asso di Fiori
2 di Fiori
3 di Fiori
...
10 di Picche
Fante di Picche
Regina di Picche
Re di Picche
</pre><p>
Anche se il risultato viene visualizzato su 52 righe, si tratta di un’unica lunga stringa che contiene caratteri di ritorno a capo.</p>
<!--TOC section id="sec218" Aggiungere, togliere, mescolare e ordinare-->
<h2 class="section" id="sec218">18.6  Aggiungere, togliere, mescolare e ordinare</h2><!--SEC END --><p>Per distribuire le carte, ci serve un metodo che tolga una carta dal mazzo e la restituisca. Il metodo delle liste <span class="c003">pop</span> è adatto allo scopo:
<a id="hevea_default1483"></a>
<a id="hevea_default1484"></a></p><pre class="verbatim">#all'interno della classe Mazzo:

    def togli_carta(self):
        return self.carte.pop()
</pre><p>
Siccome <span class="c003">pop</span> rimuove <em>l’ultima</em> carta della lista, è come se distribuissimo le carte dal fondo del mazzo.
<a id="hevea_default1485"></a>
<a id="hevea_default1486"></a></p><p>Per aggiungere una carta, usiamo il metodo delle liste <span class="c003">append</span>:</p><pre class="verbatim">#all'interno della classe Mazzo:

    def aggiungi_carta(self, carta):
        self.carte.append(carta)
</pre><p>
Un metodo come questo, che usa in realtà un altro metodo senza fare molto di più, da alcuni viene chiamato <span class="c009">impiallacciatura</span>. Questa metafora deriva dall’industria del legno: l’impiallaciatura consiste nell’incollare un sottile strato di legno di buona qualità sulla superficie di un pannello economico, per migliorarne l’aspetto.
<a id="hevea_default1487"></a></p><p>In questo caso, <code>aggiungi_carta</code> è un metodo “sottile” che esprime un’operazione su una lista, in una forma appropriata per i mazzi di carte. Esso migliora l’aspetto, ovvero l’interfaccia, dell’implementazione.</p><p>Per fare un altro esempio, scriviamo anche un metodo per un Mazzo di nome <span class="c003">mescola</span>, usando la funzione <span class="c003">shuffle</span> contenuta nel modulo <span class="c003">random</span>:
<a id="hevea_default1488"></a>
<a id="hevea_default1489"></a>
<a id="hevea_default1490"></a>
<a id="hevea_default1491"></a></p><pre class="verbatim"># all'interno della classe Mazzo:
            
    def mescola(self):
        random.shuffle(self.carte)
</pre><p>
Non scordate di importare <span class="c003">random</span>.</p><p>Come esercizio, scrivete un metodo per Mazzo di nome <span class="c003">ordina</span> che usi il metodo delle liste <span class="c003">sort</span> per ordinare le carte in un <span class="c003">Mazzo</span>. Per determinare il criterio di ordinamento, <span class="c003">sort</span> utilizza il metodo <code>__lt__</code> che abbiamo definito.
<a id="hevea_default1492"></a> <a id="hevea_default1493"></a></p>
<!--TOC section id="sec219" Ereditarietà-->
<h2 class="section" id="sec219">18.7  Ereditarietà</h2><!--SEC END --><p>
<a id="hevea_default1494"></a>
<a id="hevea_default1495"></a></p><p>L’ereditarietà è la capacità di definire una nuova classe come versione modificata di una classe già esistente.</p><p>Come esempio, supponiamo di voler creare una classe che rappresenti una “mano” di carte, vale a dire un gruppo di carte distribuite a un giocatore. Una mano è simile a un mazzo: entrambi sono fatti di carte, ed entrambi richiedono operazioni come l’aggiunta e la rimozione di carte.</p><p>D’altra parte, ci sono altre operazioni che servono per la mano ma che non hanno senso per il mazzo. Nel poker, ad esempio, dobbiamo confrontare due mani per vedere quale vince. Nel bridge, è utile calcolare il punteggio della mano per decidere la dichiarazione.</p><p>Questo tipo di relazione tra classi—simili, ma non uguali—porta all’ereditarietà.</p><p>Per definire una nuova classe che eredita da una classe esistente, basta scrivere tra parentesi il nome della classe esistente:
<a id="hevea_default1496"></a>
<a id="hevea_default1497"></a>
<a id="hevea_default1498"></a></p><pre class="verbatim">class Mano(Mazzo):
    """Rappresenta una mano di carte da gioco."""
</pre><p>
Questa definizione indica che <span class="c003">Mano</span> eredita da <span class="c003">Mazzo</span>;
ciò comporta che per Mano possiamo utilizzare i metodi di Mazzo come <code>togli_carta</code> e <code>aggiungi_carta</code>.</p><p>Quando un nuova classe eredita da una esistente, quest’ultima è chiamata <span class="c009">madre</span> (o superclasse) e quella nuova è chiamata <span class="c009">figlia</span> (o sottoclasse).
<a id="hevea_default1499"></a>
<a id="hevea_default1500"></a>
<a id="hevea_default1501"></a>
<a id="hevea_default1502"></a></p><p>In questo esempio, <span class="c003">Mano</span> eredita <code>__init__</code> da <span class="c003">Mazzo</span>, ma in questo caso il metodo non fa la cosa giusta: invece di popolare la mano con 52 nuove carte, il metodo init di Mano dovrebbe inizializzare <span class="c003">carte</span> con una lista vuota.
<a id="hevea_default1503"></a>
<a id="hevea_default1504"></a>
<a id="hevea_default1505"></a></p><p>Ma se noi specifichiamo un nuovo metodo init nella classe <span class="c003">Mano</span>, esso andrà a sovrascrivere quello della classe madre <span class="c003">Mazzo</span>:</p><pre class="verbatim"># all'interno della classe Mano:

    def __init__(self, label=''):
        self.carte = []
        self.label = label
</pre><p>
Allora, quando si crea una Mano, Python invoca questo metodo init specifico e non quello di <span class="c003">Mazzo</span>:</p><pre class="verbatim">&gt;&gt;&gt; mano = Mano('nuova mano')
&gt;&gt;&gt; mano.carte
[]
&gt;&gt;&gt; mano.label
'nuova mano'
</pre><p>
Gli altri metodi vengono ereditati da <span class="c003">Mazzo</span>, pertanto possiamo usare <code>togli_carta</code> e <code>aggiungi_carta</code> per distribuire una carta:</p><pre class="verbatim">&gt;&gt;&gt; mazzo = Mazzo()
&gt;&gt;&gt; carta = mazzo.togli_carta()
&gt;&gt;&gt; mano.aggiungi_carta(carta)
&gt;&gt;&gt; print(mano)
Re di Picche
</pre><p>
Viene poi spontaneo incapsulare questo codice in un metodo di nome <code>sposta_carte</code>:
<a id="hevea_default1506"></a></p><pre class="verbatim"># all'interno della classe Mazzo:

    def sposta_carte(self, mano, num):
        for i in range(num):
            mano.aggiungi_carta(self.togli_carta())
</pre><p>
<code>sposta_carte</code> prende come argomenti un oggetto Mano e il numero di carte da distribuire. Modifica sia <span class="c003">self</span> che <span class="c003">mano</span>, e restituisce <span class="c003">None</span>.</p><p>In alcuni giochi, le carte si spostano da una mano all’altra, o da una mano di nuovo al mazzo. Potete usare <code>sposta_carte</code> per qualsiasi di queste operazioni: <span class="c003">self</span> può essere sia un Mazzo che una Mano, e <span class="c003">mano</span>, a dispetto del nome, può anche essere un <span class="c003">Mazzo</span>.</p><p>L’ereditarietà è una caratteristica utile. Certi programmi che sarebbero ripetitivi senza ereditarietà, possono invece essere scritti in modo più elegante. Facilita il riuso del codice, poiché potete personalizzare il comportamento delle superclassi senza doverle modificare. In certi casi, la struttura dell’ereditarietà rispecchia quella del problema, il che rende il programma più facile da capire.</p><p>D’altra parte, l’ereditarietà può rendere il programma difficile da leggere. Quando viene invocato un metodo, a volte non è chiaro dove trovare la sua definizione. Il codice rilevante può essere sparso tra moduli diversi. Inoltre, molte cose che possono essere fatte usando l’ereditarietà si possono fare anche, o talvolta pure meglio, senza di essa. </p>
<!--TOC section id="sec220" Diagrammi di classe-->
<h2 class="section" id="sec220">18.8  Diagrammi di classe</h2><!--SEC END --><p>
<a id="class.diagram"></a></p><p>Sinora abbiamo visto i diagrammi di stack, che illustrano lo stato del programma, e i diagrammi di oggetto, che mostrano gli attributi di un oggetto e i loro valori. Questi diagrammi rappresentano una istantanea nell’esecuzione del programma, e quindi cambiano nel corso del programma.</p><p>Sono anche molto dettagliati, per alcuni scopi anche troppo. Un diagramma di classe è una rappresentazione più astratta della struttura di un programma. Invece di mostrare singoli oggetti, mostra le classi e le relazioni che sussistono tra le classi.</p><p>Ci sono alcuni tipi diversi di relazioni tra classi:</p><ul class="itemize"><li class="li-itemize">Oggetti in una classe possono contenere riferimenti a oggetti in un’altra classe. Per esempio, ogni Rettangolo contiene un riferimento a un Punto, e ogni Mazzo contiene riferimenti a molte Carte. Questo tipo di relazione è chiamata <span class="c009">HAS-A</span> (ha-un), come in: “un Rettangolo ha un Punto”.</li><li class="li-itemize">Una classe può ereditare da un’altra. Questa relazione è detta <span class="c009">IS-A</span> (è-un), come in: “una Mano è un tipo di Mazzo”.</li><li class="li-itemize">Una classe può dipendere da un altra, nel senso che oggetti di una classe possono prendere come parametri oggetti di una seconda classe oppure usarli per svolgere parte delle elaborazioni. Una relazione di questo tipo è detta <span class="c009">dipendenza</span>. </li></ul><p>
<a id="hevea_default1507"></a>
<a id="hevea_default1508"></a>
<a id="hevea_default1509"></a></p><p>Un <span class="c009">diagramma di classe</span> è una rappresentazione grafica di queste relazioni. Per esempio, la Figura <a href="#fig.class1">18.2</a> mostra le relazioni tra <span class="c003">Carta</span>, <span class="c003">Mazzo</span> e <span class="c003">Mano</span>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian025.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 18.2: Diagramma di classe.</td></tr>
</table></div>
<a id="fig.class1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>La freccia con un triangolo vuoto rappresenta la relazione IS-A: in questo caso indica che Mano eredita da Mazzo.</p><p>La freccia standard rappresenta la relazione HAS-A; in questo caso un Mazzo ha riferimenti agli oggetti Carta.
<a id="hevea_default1510"></a></p><p>L’asterisco (<span class="c003">*</span>) vicino alla testa della freccia indica una
<span class="c009">molteplicità</span>, cioè quante Carte ha un Mazzo. Una molteplicità può essere un numero semplice, come <span class="c003">52</span>, un intervallo come <span class="c003">5..7</span>, o un asterisco che indica che un Mazzo può contenere un numero qualsiasi di Carte.</p><p>In questo diagramma non vi sono dipendenze. In genere, verrebbero illustrate con delle frecce tratteggiate. Se vi sono parecchie dipendenze, talvolta vengono omesse.</p><p>Un diagramma più dettagliato dovrebbe evidenziare che un Mazzo contiene in realtà una <em>lista</em> di Carte, ma i tipi predefiniti come liste e dizionari di solito non vengono inclusi in questi diagrammi.</p>
<!--TOC section id="sec221" Debug-->
<h2 class="section" id="sec221">18.9  Debug</h2><!--SEC END --><p>
<a id="hevea_default1511"></a></p><p>L’ereditarietà può rendere il debug difficoltoso, perché quando invocate un metodo su un oggetto, può risultare laborioso capire esattamente quale sia il metodo che viene invocato.
<a id="hevea_default1512"></a></p><p>Supponiamo che stiate scrivendo una funzione che lavori su oggetti Mano. Vorreste che fosse valida per Mani di tutti i tipi come ManiDiPoker, ManiDiBridge ecc. Se invocate un metodo come
<span class="c003">mescola</span>, potrebbe essere quello definito in <span class="c003">Mazzo</span>,
ma se qualcuna delle sottoclassi sovrascrive il metodo, avrete invece quella diversa versione. Questo comportamento è appropriato, ma a volte può confondere.</p><p>Quando siete incerti sul flusso di esecuzione del vostro programma, la soluzione più semplice è aggiungere istruzioni di stampa all’inizio di ogni metodo importante. Se <span class="c003">Mazzo.mescola</span> stampa un messaggio come <span class="c003">Sto eseguendo Mazzo.mescola</span>, allora il programma traccia il flusso di esecuzione mentre viene eseguito.
<a id="hevea_default1513"></a></p><p>In alternativa, potete usare la funzione seguente, che richiede un oggetto e un nome di metodo (come stringa) e restituisce la classe che contiene la definizione del metodo:</p><pre class="verbatim">def trova_classe_def(obj, nome_metodo):
    for ty in type(obj).mro():
        if nome_metodo in ty.__dict__:
            return ty
</pre><p>
Ecco un esempio:</p><pre class="verbatim">&gt;&gt;&gt; mano = Mano()
&gt;&gt;&gt; trova_classe_def(mano, 'mescola')
&lt;class 'Carta.Mazzo'&gt;
</pre><p>
Quindi il metodo <span class="c003">mescola</span> di questa Mano è quello definito in<span class="c003">Mazzo</span>.
<a id="hevea_default1514"></a>
<a id="hevea_default1515"></a>
<a id="hevea_default1516"></a></p><p><code>trova_classe_def</code> usa il metodo <span class="c003">mro</span> per ricavare la lista degli oggetti classe (tipi) in cui verrà effettuata la ricerca dei metodi. “MRO” sta per <em>Method Resolution Order</em> (ordine di risoluzione dei metodi), che è la sequenza di classi che Python ricerca per “risolvere” un nome di metodo.</p><p>Un consiglio per la progettazione di un programma: quando sovrascrivete un metodo, l’interfaccia del nuovo metodo dovrebbe essere la stessa di quello sostituito: deve richiedere gli stessi parametri, restituire lo stesso tipo, rispettare le stesse precondizioni e postcondizioni. Se rispettate questa regola, vedrete che ogni funzione progettata per un’istanza di una superclasse, come Mazzo, funzionerà anche con le istanze delle sottoclassi come Mano e ManoDiPoker.
<a id="hevea_default1517"></a>
<a id="hevea_default1518"></a>
<a id="hevea_default1519"></a>
<a id="hevea_default1520"></a></p><p>Se violate questa regola, conosciuta come “principio di sostituzione di Liskov”, il vostro codice crollerà come (perdonatemi) un castello di carte.
<a id="hevea_default1521"></a></p>
<!--TOC section id="sec222" Incapsulamento dei dati-->
<h2 class="section" id="sec222">18.10  Incapsulamento dei dati</h2><!--SEC END --><p>Il capitolo precedente ha illustrato una tecnica di sviluppo detta
“progettazione orientata agli oggetti”. Abbiamo identificato gli oggetti che ci servivano—come <span class="c003">Tempo</span>, <span class="c003">Punto</span> e <span class="c003">Rettangolo</span>—e definito le classi per rappresentarli. Per ciascuno c’è un’evidente corrispondenza tra l’oggetto e una qualche entità del mondo reale (o per lo meno del mondo della matematica).
<a id="hevea_default1522"></a></p><p>Ma altre volte la scelta degli oggetti e del modo in cui interagiscono è meno ovvia. In questo caso serve una tecnica di sviluppo diversa. Nella stessa maniera in cui abbiamo scoperto le interfacce delle funzioni per mezzo dell’incapsulamento e della generalizzazione, scopriamo ora le interfacce delle classi tramite l’<span class="c009">incapsulamento dei dati</span>.
<a id="hevea_default1523"></a></p><p>L’analisi di Markov, vista nel Paragrafo <a href="#markov">13.8</a>, è un buon esempio. Se scaricate il mio codice dal sito <a href="http://thinkpython2.com/code/markov.py"><span class="c003">http://thinkpython2.com/code/markov.py</span></a>, vi accorgerete che usa due variabili globali—<code>suffix_map</code> e <code>prefix</code>—che vengono lette e scritte da più funzioni.</p><pre class="verbatim">suffix_map = {}        
prefix = ()            
</pre><p>Siccome queste variabili sono globali, possiamo eseguire una sola analisi alla volta. Se leggessimo due testi contemporaneamente, i loro prefissi e suffissi verrebbero aggiunti nella stessa struttura di dati (il che produce comunque alcuni interessanti testi generati).</p><p>Per eseguire analisi multiple mantenendole separate, possiamo incapsulare lo stato di ciascuna analisi in un oggetto. Ecco come si presenta:</p><pre class="verbatim">class Markov:

    def __init__(self):
        self.suffix_map = {}
        self.prefix = ()    
</pre><p>Poi, trasformiamo le funzioni in metodi. Ecco per esempio <code>elabora_parola</code>:</p><pre class="verbatim">    def elabora_parola(self, parola, ordine=2):
        if len(self.prefix) &lt; ordine:
            self.prefix += (parola,)
            return

        try:
            self.suffix_map[self.prefix].append(parola)
        except KeyError:
            # se non c'e' una voce per questo prefisso, creane una
            self.suffix_map[self.prefix] = [parola]

        self.prefix = shift(self.prefix, parola)        
</pre><p>Questa trasformazione di un programma—cambiarne la forma senza cambiarne il comportamento—è un altro esempio di refactoring (vedi Paragrafo <a href="#refactoring">4.7</a>).
<a id="hevea_default1524"></a></p><p>L’esempio suggerisce una tecnica di sviluppo per progettare oggetti e metodi:</p><ol class="enumerate" type=1><li class="li-enumerate">Cominciare scrivendo funzioni che leggono e scrivono variabili globali (dove necessario)</li><li class="li-enumerate">Una volta ottenuto un programma funzionante, cercare le associazioni tra le variabili globali e le funzioni che le usano.</li><li class="li-enumerate">Incapsulare le variabili correlate come attributi di un oggetto.</li><li class="li-enumerate">Trasformare le funzioni associate in metodi della nuova classe.</li></ol><p>Come esercizio, scaricate il mio codice da
(<a href="http://thinkpython2.com/code/markov.py"><span class="c003">http://thinkpython2.com/code/markov.py</span></a>), e seguite i passi appena descritti per incapsulare le varibili globali come attributi di una nuova classe chiamata <span class="c003">Markov</span>. Soluzione: <a href="http://thinkpython2.com/code/Markov.py"><span class="c003">http://thinkpython2.com/code/Markov.py</span></a> (notare la M maiuscola).</p>
<!--TOC section id="sec223" Glossario-->
<h2 class="section" id="sec223">18.11  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">codificare:</span></dt><dd class="dd-description"> Rappresentare un insieme di valori usando un altro insieme di valori e costruendo una mappatura tra di essi.
<a id="hevea_default1525"></a></dd><dt class="dt-description"><span class="c009">attributo di classe:</span></dt><dd class="dd-description"> Attributo associato ad un oggetto classe. Gli attributi di classe sono definiti all’interno di una definizione di classe ma esternamente ad ogni metodo.
<a id="hevea_default1526"></a>
<a id="hevea_default1527"></a></dd><dt class="dt-description"><span class="c009">attributo di istanza:</span></dt><dd class="dd-description"> Attributo associato ad un’istanza di una classe.
<a id="hevea_default1528"></a>
<a id="hevea_default1529"></a></dd><dt class="dt-description"><span class="c009">impiallacciatura:</span></dt><dd class="dd-description"> Metodo o funzione che fornisce un’interfaccia diversa a un’altra funzione, senza effettuare ulteriori calcoli.
<a id="hevea_default1530"></a></dd><dt class="dt-description"><span class="c009">ereditarietà:</span></dt><dd class="dd-description"> Capacità di definire una classe come versione modificata di una classe già definita in precedenza.
<a id="hevea_default1531"></a></dd><dt class="dt-description"><span class="c009">classe madre o superclasse:</span></dt><dd class="dd-description"> Classe dalla quale una classe figlia eredita.
<a id="hevea_default1532"></a></dd><dt class="dt-description"><span class="c009">classe figlia o sottoclasse:</span></dt><dd class="dd-description"> Nuova classe creata ereditando da una classe esistente.
<a id="hevea_default1533"></a></dd><dt class="dt-description"><span class="c009">relazione IS-A:</span></dt><dd class="dd-description"> Relazione tra una classe figlia e la sua classe madre.
<a id="hevea_default1534"></a></dd><dt class="dt-description"><span class="c009">relazione HAS-A:</span></dt><dd class="dd-description"> Relazione tra due classi dove le istanze di una classe contengono riferimenti alle istanze dell’altra classe.
<a id="hevea_default1535"></a></dd><dt class="dt-description"><span class="c009">dipendenza:</span></dt><dd class="dd-description"> Relazione tra due classi dove istanze di una classe utilizzano istanze dell’altra classe, ma senza conservarle sotto forma di attributi.
<a id="hevea_default1536"></a></dd><dt class="dt-description"><span class="c009">diagramma di classe:</span></dt><dd class="dd-description"> Diagramma che illustra le classi di un programma e le relazioni tra di esse.
<a id="hevea_default1537"></a></dd><dt class="dt-description"><span class="c009">molteplicità:</span></dt><dd class="dd-description"> Notazione in un diagramma di classe che mostra, per una relazione HAS-A, quanti riferimenti ad istanze di un’altra classe ci sono.
<a id="hevea_default1538"></a></dd><dt class="dt-description"><span class="c009">incapsulamento dei dati:</span></dt><dd class="dd-description"> Tecnica di sviluppo che prevede un prototipo che usa variabili globali e una versione finale in cui le variabili globali vengono trasformate in attributi di istanza.
<a id="hevea_default1539"></a>
<a id="hevea_default1540"></a></dd></dl>
<!--TOC section id="sec224" Esercizi-->
<h2 class="section" id="sec224">18.12  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <em>
Dato il seguente programma, disegnate un diagramma di classe UML (</em>Unified Modeling Language<em>) che illustri queste classi e le relazioni che intercorrono tra esse.</em><pre class="verbatim"><em>class PingPongMadre:
    pass

class Ping(PingPongMadre):
    def __init__(self, pong):
        self.pong = pong


class Pong(PingPongMadre):
    def __init__(self, pings=None):
        if pings is None:
            self.pings = []
        else:
            self.pings = pings

    def add_ping(self, ping):
        self.pings.append(ping)

pong = Pong()
ping = Ping(pong)
pong.add_ping(ping)
</em></pre></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Scrivete un metodo per Mazzo di nome <code>dai_mani</code> che prenda come parametri il numero di mani e il numero di carte da dare a ciascuna mano, e crei il numero stabilito di oggetti Mano, distribuisca il numero prefissato di carte a ogni mano e restituisca una lista delle Mani.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="poker"></a><p><em>Quelle che seguono sono le possibili combinazioni nel gioco del poker, in ordine crescente di valore e decrescente di probabilità:
</em><a id="hevea_default1541"></a></p><dl class="description"><dt class="dt-description"><em><span class="c009">coppia:</span></em></dt><dd class="dd-description"><em> due carte dello stesso valore
</em></dd><dt class="dt-description"><span class="c009"><em>doppia coppia:</em></span></dt><dd class="dd-description"><em> due coppie di carte dello stesso valore
</em></dd><dt class="dt-description"><span class="c009"><em>tris:</em></span></dt><dd class="dd-description"><em> tre carte dello stesso valore
</em></dd><dt class="dt-description"><span class="c009"><em>scala:</em></span></dt><dd class="dd-description"><em> cinque carte con valori in sequenza (gli assi possono essere sia la carta di valore inferiore che quella di valore superiore, per cui <span class="c003">Asso-2-3-4-5</span> è una scala, e anche <span class="c003">10-Fante-Regina-Re-Asso</span>, ma non <span class="c003">Regina-Re-Asso-2-3</span>).
</em></dd><dt class="dt-description"><span class="c009"><em>colore:</em></span></dt><dd class="dd-description"><em> cinque carte dello stesso seme
</em></dd><dt class="dt-description"><span class="c009"><em>full:</em></span></dt><dd class="dd-description"><em> tre carte dello stesso valore più una coppia di carte dello stesso valore
</em></dd><dt class="dt-description"><span class="c009"><em>poker:</em></span></dt><dd class="dd-description"><em> quattro carte dello stesso valore
</em></dd><dt class="dt-description"><span class="c009"><em>scala reale:</em></span></dt><dd class="dd-description"><em> cinque carte dello stesso seme in scala (definita come sopra)
</em></dd></dl><p><em>
Scopo di questo esercizio è stimare la probabilità di avere servita una di queste combinazioni.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scaricate i file seguenti da </em><a href="http://thinkpython2.com/code"><em><span class="c003">http://thinkpython2.com/code</span></em></a><em>:</em><dl class="description"><dt class="dt-description"><span class="c004"><em>Card.py</em></span></dt><dd class="dd-description"><em>: Versione completa delle classi <span class="c003">Carta</span>,
<span class="c003">Mazzo</span> e <span class="c003">Mano</span> di questo capitolo.</em></dd><dt class="dt-description"><span class="c004"><em>PokerHand.py</em></span></dt><dd class="dd-description"><em>: Implementazione incompleta di una classe che rappresenta una mano di poker con del codice di prova.</em></dd></dl></li><li class="li-enumerate"><em>Se eseguite <span class="c003">PokerHand.py</span>, serve delle mani di sette carte e controlla se qualcuna contenga un colore. Leggete attentamente il codice prima di proseguire.</em></li><li class="li-enumerate"><em>Aggiungete dei metodi a <span class="c003">PokerHand.py</span> di nome <code>ha_coppia</code>,
<code>ha_doppiacoppia</code>, ecc. che restituiscano True o False a seconda che le mani soddisfino o meno il rispettivo criterio. Il codice deve funzionare indipendentemente dal numero di carte che contiene la mano (5 e 7 carte sono i casi più comuni).</em></li><li class="li-enumerate"><em>Scrivete un metodo di nome <span class="c003">classifica</span> che riconosca la combinazione più elevata in una mano e imposta di conseguenza l’attributo
<span class="c003">label</span>. Per esempio, una mano di 7 carte può contenere un colore e una coppia; deve essere etichettata “colore”.</em></li><li class="li-enumerate"><em>Quando siete sicuri che i vostri metodi di classificazione funzionano, il passo successivo è stimare la probabilità delle varie mani. Scrivete una funzione in <span class="c003">PokerHand.py</span> che mescoli un mazzo di carte, lo divida in mani, le classifichi e conti quante volte compare ciascuna combinazione.</em></li><li class="li-enumerate"><em>Stampate una tabella delle combinazioni con le rispettive probabilità. Eseguite il vostro programma con numeri sempre più grandi di mani finché i valori ottenuti convergono ad un ragionevole grado di accuratezza. Confrontate i vostri risultati con i valori pubblicati su </em><a href="http://en.wikipedia.org/wiki/Hand_rankings"><span class="c003"><em>http://en.wikipedia.org/wiki/Hand_rankings</em></span></a><em>.</em></li></ol><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/PokerHandSoln.py"><em><span class="c003">http://thinkpython2.com/code/PokerHandSoln.py</span></em></a><em>.
</em></p></div>
<!--TOC chapter id="sec225" Ulteriori strumenti-->
<h1 class="chapter" id="sec225">Chapter 19  Ulteriori strumenti</h1><!--SEC END --><p>Uno degli obiettivi di questo libro è di illustrarvi il minimo indispensabile di Python. Quando esistono due modi diversi di fare qualcosa, preferisco sceglierne uno ed evitare di citare l’altro, oppure inserire il secondo all’interno di un esercizio.</p><p>Ora vorrei tornare a recuperare alcune chicche che avevo tralasciato. Python è dotato di parecchie funzionalità che non sono indispensabili—potete scrivere del buon codice anche senza usarle—ma che in certi casi vi permettono di scrivere del codice più conciso, leggibile, efficiente, o anche tutte e tre le cose insieme.</p>
<!--TOC section id="sec226" Espressioni condizionali-->
<h2 class="section" id="sec226">19.1  Espressioni condizionali</h2><!--SEC END --><p>Abbiamo visto nel Paragrafo <a href="#conditional.execution">5.4</a> le istruzioni condizionali, che vengono usate di frequente per scegliere uno tra due valori alternativi, per esempio:
<a id="hevea_default1542"></a>
<a id="hevea_default1543"></a></p><pre class="verbatim">if x &gt; 0:
    y = math.log(x)
else:
    y = float('nan')
</pre><p>Questa istruzione controlla se <span class="c003">x</span> è positivo. Se lo è, calcola
<span class="c003">math.log</span>, altrimenti <span class="c003">math.log</span> scatenerebbe un ValueError. Per evitare che il programma si arresti, generiamo un “NaN”, che è un valore a virgola mobile speciale che rappresenta “Not a Number” (Non è un Numero).
<a id="hevea_default1544"></a>
<a id="hevea_default1545"></a></p><p>Possiamo scrivere questa condizione in modo più conciso utilizzando un’<span class="c009">espressione condizionale</span>:</p><pre class="verbatim">y = math.log(x) if x &gt; 0 else float('nan')
</pre><p>Si può quasi leggere questa riga come fosse: “<span class="c003">y</span> diventa log-<span class="c003">x</span>
se <span class="c003">x</span> è maggiore di 0; altrimenti diventa NaN”.</p><p>A volte, le funzioni ricorsive possono essere riscritte utilizzando le espressioni condizionali. Prendiamo ad esempio una versione ricorsiva di <span class="c003">fattoriale</span>:
<a id="hevea_default1546"></a>
<a id="hevea_default1547"></a></p><pre class="verbatim">def fattoriale(n):
    if n == 0:
        return 1
    else:
        return n * fattoriale(n-1)
</pre><p>Si può riscrivere così:</p><pre class="verbatim">def fattoriale(n):
    return 1 if n == 0 else n * fattoriale(n-1)
</pre><p>Un altro utilizzo delle espressioni condizionali è la gestione degli argomenti opzionali. Per esempio, ecco il metodo init di
<span class="c003">GoodKangaroo</span> (vedere Esercizio <a href="#kangaroo">2</a>):
<a id="hevea_default1548"></a>
<a id="hevea_default1549"></a></p><pre class="verbatim">    def __init__(self, nome, contenuti=None):
        self.nome = nome
        if contenuti == None:
        contenuti = []
        self.contenuto_tasca = contenuti
</pre><p>Si può riscrivere così:</p><pre class="verbatim">    def __init__(self, nome, contenuti=None):
        self.nome = nome
        self.contenuto_tasca = [] if contenuti == None else contenuti 
</pre><p>In generale, si può sostituire un’istruzione condizionale con un’espressione condizionale se entrambe le ramificazioni contengono semplici espressioni che vengono o ritornate o assegnate alla stessa variabile.
<a id="hevea_default1550"></a>
<a id="hevea_default1551"></a></p>
<!--TOC section id="sec227" List comprehension-->
<h2 class="section" id="sec227">19.2  List comprehension</h2><!--SEC END --><p>Nel Paragrafo <a href="#filter">10.7</a> abbiamo visto gli schemi di mappa e filtro. Per esempio, questa funzione prende una lista di stringhe, mappa il metodo delle stringhe <span class="c003">capitalize</span> negli elementi e restituisce una nuova lista di stringhe:</p><pre class="verbatim">def tutte_maiuscole(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</pre><p>Si può scrivere in modo più conciso utilizzando una <span class="c009">list comprehension</span>:
<a id="hevea_default1552"></a></p><pre class="verbatim">def tutte_maiuscole(t):
    return [s.capitalize() for s in t]
</pre><p>Gli operatori parentesi quadre indicano che stiamo costruendo una nuova lista. L’espressione all’interno delle parentesi specifica gli elementi della lista, e il costrutto <span class="c003">for</span> specifica la sequenza che stiamo attraversando.
<a id="hevea_default1553"></a>
<a id="hevea_default1554"></a></p><p>La sintassi di una list comprehension è un po’ sgraziata, perché la variabile del ciclo, <span class="c003">s</span> in questo esempio, compare nell’espressione prima di ottenerne la definizione.
<a id="hevea_default1555"></a></p><p>Si può usare la list comprehension anche per filtrare. Per esempio, questa funzione seleziona solo gli elementi di <span class="c003">t</span> che sono composti di lettere maiuscole, e restituisce una nuova lista:
<a id="hevea_default1556"></a>
<a id="hevea_default1557"></a></p><pre class="verbatim">def solo_maiuscole(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</pre><p>Riscriviamola usando una list comprehension:</p><pre class="verbatim">def solo_maiuscole(t):
    return [s for s in t if s.isupper()]
</pre><p>Le list comprehension sono concise e leggibili, almeno per le espressioni semplici. E di solito sono più veloci dei cicli <code>for</code> equivalenti, a volte molto più veloci. Capisco quindi se mi state biasimando per non avervene parlato prima.</p><p>La giustificazione è che il debug delle list comprehension è più difficile, perché non potete inserire delle istruzioni di stampa nel ciclo. Vi consiglio di usarle solo se i calcoli sono abbastanza semplici da avere buone probabilità di azzeccarci al primo colpo. Che per un principiante, vuol dire quasi mai.
<a id="hevea_default1558"></a></p>
<!--TOC section id="sec228" Generator expression-->
<h2 class="section" id="sec228">19.3  Generator expression</h2><!--SEC END --><p>Le <span class="c009">generator expression</span> assomigliano sintatticamente a delle list comprehension, ma con parentesi tonde anziché quadre:
<a id="hevea_default1559"></a></p><pre class="verbatim">&gt;&gt;&gt; g = (x**2 for x in range(5))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x7f4c45a786c0&gt;
</pre><p>
Il risultato è un oggetto generatore che è in grado di iterare attraverso una sequenza di valori. Ma a differenza di una list comprehension, non calcola i valori tutti in una volta: attende che gli venga chiesto di farlo.
Con la funzione predefinita <span class="c003">next</span>, si ottiene dal generatore il valore successivo:
<a id="hevea_default1560"></a>
<a id="hevea_default1561"></a></p><pre class="verbatim">&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
</pre><p>
Arrivati alla fine della sequenza, <span class="c003">next</span> solleva un’eccezione
StopIteration. Si può anche usare un ciclo <span class="c003">for</span> per iterare attraverso i valori:
<a id="hevea_default1562"></a>
<a id="hevea_default1563"></a></p><pre class="verbatim">&gt;&gt;&gt; for val in g:
...     print(val)
4
9
16
</pre><p>
L’oggetto generatore mantiene traccia del punto in cui si trova all’interno della sequenza, quindi il ciclo <span class="c003">for</span> riprende da dove <span class="c003">next</span> era rimasto. Una volta che il generatore è esaurito, continua sollevando delle <span class="c003">StopIteration</span>:</p><pre class="verbatim">&gt;&gt;&gt; next(g)
StopIteration
</pre><p>Le generator expression vengono usate spesso con funzioni come <span class="c003">sum</span>,
<span class="c003">max</span>, e <span class="c003">min</span>:
<a id="hevea_default1564"></a>
<a id="hevea_default1565"></a></p><pre class="verbatim">&gt;&gt;&gt; sum(x**2 for x in range(5))
30
</pre>
<!--TOC section id="sec229" <span class="c003">any</span> e <span class="c003">all</span>-->
<h2 class="section" id="sec229">19.4  <span class="c003">any</span> e <span class="c003">all</span></h2><!--SEC END --><p>Python dispone di una funzione predefinita di nome <span class="c003">any</span>, che prende una sequenza di valori booleani e restituisce <span class="c003">True</span> se almeno uno dei valori è <span class="c003">True</span>. Funziona sulle liste:
<a id="hevea_default1566"></a>
<a id="hevea_default1567"></a></p><pre class="verbatim">&gt;&gt;&gt; any([False, False, True])
True
</pre><p>
Ma viene usata spesso con le generator expression:
<a id="hevea_default1568"></a></p><pre class="verbatim">&gt;&gt;&gt; any(lettera == 't' for lettera in 'monty')
True
</pre><p>
Questo esempio non è granché utile, perché fa la stessa cosa dell’operatore <span class="c003">in</span>. Ma possiamo usare <span class="c003">any</span> per riscrivere alcune delle funzioni di ricerca che avevamo scritto nel Paragrafo <a href="#search">9.3</a>. Per esempio, avremmo potuto scrivere <span class="c003">evita</span> così:
<a id="hevea_default1569"></a>
<a id="hevea_default1570"></a></p><pre class="verbatim">def evita(parola, vietate):
    return not any(lettera in vietate for lettera in parola)
</pre><p>
La funzione si legge quasi come fosse: “la <span class="c003">parola</span> evita le
<span class="c003">vietate</span> se non c’è alcuna lettera in <span class="c003">vietate</span> per ogni lettera in <span class="c003">parola</span>.”</p><p>L’uso di <span class="c003">any</span> con una generator expression è efficiente, perché si ferma immediatamente se trova un valore <span class="c003">True</span>, senza dover necessariamente verificare tutta la sequenza. </p><p>Python contiene poi un’altra funzione predefinita, <span class="c003">all</span>, che restituisce
<span class="c003">True</span> se ogni elemento di una sequenza è <span class="c003">True</span>. Come esercizio, usate <span class="c003">all</span> per riscrivere la funzione <code>usa_tutte</code> del Paragrafo <a href="#search">9.3</a>.
<a id="hevea_default1571"></a>
<a id="hevea_default1572"></a></p>
<!--TOC section id="sec230" Insiemi (set)-->
<h2 class="section" id="sec230">19.5  Insiemi (set)</h2><!--SEC END --><p>
<a id="sets"></a></p><p>Nel Paragrafo <a href="#dictsub">13.6</a> avevo utilizzato dei dizionari per trovare le parole che comparivano in un testo, ma non in un elenco di parole. La funzione che avevo scritto prendeva <span class="c003">d1</span>, contenente le parole del testo come chiavi, e <span class="c003">d2</span>, contenente l’elenco di parole. Essa restituiva un dizionario contenente le chiavi di <span class="c003">d1</span> che non comparivano in <span class="c003">d2</span>.</p><pre class="verbatim">def sottrai(d1, d2):
    res = dict()
    for chiave in d1:
        if chiave not in d2:
            res[chiave] = None
    return res
</pre><p>
In tutti questi dizionari, i valori sono <span class="c003">None</span> perché non sono necessari e non vengono usati. Ma questo spreca dello spazio di memoria.
<a id="hevea_default1573"></a></p><p>Python dispone di un altro tipo predefinito chiamato <span class="c009">insieme</span> o <span class="c003">set</span>, che si comporta come una raccolta di chiavi di dizionario prive di valori. Aggiungere elementi ad un insieme è rapido, come pure controllare se un elemento appartiene all’insieme. Vengono poi forniti metodi e operatori per eseguire le comuni operazioni sugli insiemi.
<a id="hevea_default1574"></a>
<a id="hevea_default1575"></a></p><p>Per esempio, la sottrazione di insiemi è disponibile sotto forma di metodo chiamato <span class="c003">difference</span> oppure come operatore, <span class="c003">-</span>. Possiamo allora riscrivere <span class="c003">sottrai</span> in questo modo:
<a id="hevea_default1576"></a></p><pre class="verbatim">def sottrai(d1, d2):
    return set(d1) - set(d2)
</pre><p>
Il risultato è un insieme anziché un dizionario, ma per operazioni come l’iterazione il comportamento è identico. </p><p>Alcuni esercizi di questo libro possono essere svolti in modo conciso ed efficiente usando gli insiemi. Per esempio, questa è una soluzione di
<code>ha_duplicati</code>, dall’Esercizio <a href="#duplicate">7</a>, che utilizza un dizionario:</p><pre class="verbatim">def ha_duplicati(t):
    d = {}
    for x in t:
        if x in d:
            return True
        d[x] = True
    return False
</pre><p>Quando un elemento compare per la prima volta, viene aggiunto al dizionario. Se il medesimo elemento ricompare, la funzione restituisce <span class="c003">True</span>.</p><p>Usando gli insiemi, si può riscrivere la funzione così:</p><pre class="verbatim">def ha_duplicati(t):
    return len(set(t)) &lt; len(t)
</pre><p>
Siccome un elemento può comparire in un insieme solo una volta, se in <span class="c003">t</span> esiste qualche elemento che compare più volte, l’insieme risulterà più piccolo di <span class="c003">t</span>. Se invece non ci sono duplicati, l’insieme avrà la stessa dimensione di <span class="c003">t</span>.
<a id="hevea_default1577"></a></p><p>Si possono usare gli insiemi anche per risolvere alcuni esercizi del Capitolo <a href="#wordplay">9</a>. Per esempio, questa è la versione di
<code>usa_solo</code> con un ciclo:</p><pre class="verbatim">def usa_solo(parola, valide):
    for lettera in parola: 
        if lettera not in valide:
            return False
    return True
</pre><p>
<code>usa_solo</code> controlla se tutte le lettere in una <span class="c003">word</span> sono tra quelle <span class="c003">valide</span>. La possiamo riscrivere così:</p><pre class="verbatim">def usa_solo(parola, valide):
    return set(parola) &lt;= set(valide)
</pre><p>
L’operatore <code>&lt;=</code> controlla se un insieme è un sottoinsieme di un altro, compresa la possibilità che siano uguali, il che è vero se tutte le lettere nella <span class="c003">parola</span> fanno parte delle <span class="c003">valide</span>.
<a id="hevea_default1578"></a></p><p>Per esercizio, riscrivete la funzione <code>evita</code> usando gli insiemi.</p>
<!--TOC section id="sec231" Contatori-->
<h2 class="section" id="sec231">19.6  Contatori</h2><!--SEC END --><p>Un contatore è una specie di insieme, tranne per il fatto che se un elemento compare più di una volta, il contatore prende nota di quante volte compare. Se vi è noto il concetto matematico di <span class="c009">multiinsieme</span>, un contatore è un modo immediato per rappresentarlo.
<a id="hevea_default1579"></a>
<a id="hevea_default1580"></a>
<a id="hevea_default1581"></a></p><p>Il contatore è definito all’interno di un modulo standard chiamato <span class="c003">collections</span>, quindi dovete innanzitutto importarlo. Potete inizializzare un contatore con una stringa, lista o qualsiasi altro oggetto che sia iterabile:
<a id="hevea_default1582"></a>
<a id="hevea_default1583"></a></p><pre class="verbatim">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; conta = Counter('parrot')
&gt;&gt;&gt; conta
Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1})
</pre><p>I contatori si comportano per molti versi come i dizionari: fanno corrispondere ciascuna chiave al numero di volte in cui essa compare. Come per i dizionari, le chiavi devono essere idonee all’hashing.</p><p>A differenza dei dizionari, i contatori non sollevano eccezioni in caso di accesso a un elemento che non esiste; invece, restituiscono 0:</p><pre class="verbatim">&gt;&gt;&gt; conta['d']
0
</pre><p>Possiamo usare i contatori per riscrivere <code>anagramma</code> dell’Esercizio <a href="#anagram">6</a>:</p><pre class="verbatim">def anagramma(parola1, parola2):
    return Counter(parola1) == Counter(parola2)
</pre><p>Se due parole sono anagrammi, contengono le stesse lettere, lo stesso numero di volte: pertanto i loro contatori sono equivalenti.</p><p>Anche i contatori sono dotati dei metodi e degli operatori per eseguire le operazioni tipiche degli insiemi, incluse addizione, sottrazione e intersezione. Ed espongono un metodo molto utile, <code>most_common</code>, che
restituisce una lista di coppie valore-frequenza, in ordine di frequenza decrescente:</p><pre class="verbatim">&gt;&gt;&gt; conta = Counter('parrot')
&gt;&gt;&gt; for valore, frequenza in count.most_common(3):
...     print(valore, frequenza)
r 2
p 1
a 1
</pre>
<!--TOC section id="sec232" defaultdict-->
<h2 class="section" id="sec232">19.7  defaultdict</h2><!--SEC END --><p>Il modulo <span class="c003">collections</span> contiene anche <span class="c003">defaultdict</span>, che è simile a un dizionario, con la differenza che quando si tenta di accedere ad una chiave inesistente, può generare al volo un nuovo valore.
<a id="hevea_default1584"></a>
<a id="hevea_default1585"></a>
<a id="hevea_default1586"></a>
<a id="hevea_default1587"></a></p><p>Nel creare un defaultdict, dovete fornire una funzione che viene usata per creare i nuovi valori. Una funzione usata per creare oggetti viene detta da alcuni <span class="c009">factory</span>. Le funzioni predefinite che creano liste, insiemi e altri tipi, possono essere usate come factory:
<a id="hevea_default1588"></a></p><pre class="verbatim">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
</pre><p>Notate che l’argomento è <span class="c003">list</span>, che è un oggetto classe, non <span class="c003">list()</span>, che è una nuova lista. La funzione che avete creato viene chiamata soltanto quando tentate di accedere ad una chiave che non esiste.</p><pre class="verbatim">&gt;&gt;&gt; t = d['nuova chiave']
&gt;&gt;&gt; t
[]
</pre><p>La nuova lista, che chiamiamo <span class="c003">t</span>, viene aggiunta al dizionario. Quindi se modifichiamo <span class="c003">t</span>, i cambiamenti compaiono in <span class="c003">d</span>:</p><pre class="verbatim">&gt;&gt;&gt; t.append('nuovo valore')
&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'nuova chiave': ['nuovo valore']})
</pre><p>Se state creando un dizionario di liste, usare <span class="c003">defaultdict</span> permette spesso di scrivere codice più semplice. Nella mia risoluzione dell’Esercizio <a href="#anagrams">2</a>, che potete scaricare da
<a href="http://thinkpython2.com/code/anagram_sets.py"><span class="c003">http://thinkpython2.com/code/anagram_sets.py</span></a>, ho creato un dizionario che mappa da una stringa ordinata di lettere nella lista di parole che si possono comporre con quelle lettere. Per esempio, <span class="c003">’opst’</span> corrisponde alla lista <span class="c003">[’opts’, ’post’, ’pots’, ’spot’, ’stop’, ’tops’]</span>.</p><p>Questo è il codice di partenza:</p><pre class="verbatim">def tutti_anagrammi(nomefile):
    d = {}
    for riga in open(nomefile):
        parola = riga.strip().lower()
        t = signature(parola)
        if t not in d:
            d[t] = [parola]
        else:
            d[t].append(parola)
    return d
</pre><p>Si può semplificare usando <span class="c003">setdefault</span>, che potreste avere usato nell’Esercizio <a href="#setdefault">2</a>:
<a id="hevea_default1589"></a></p><pre class="verbatim">def tutti_anagrammi(nomefile):
    d = {}
    for riga in open(nomefile):
        parola = riga.strip().lower()
        t = signature(parola)
        d.setdefault(t, []).append(parola)
    return d
</pre><p>Questa soluzione ha il difetto di creare ogni volta una nuova lista, anche se non è necessario. Non è un grande problema se si tratta di liste, ma se la funzione factory è complessa, può diventarlo.
<a id="hevea_default1590"></a></p><p>Ma si può evitare il problema e semplificare il codice con un <span class="c003">defaultdict</span>:</p><pre class="verbatim">def tutti_anagrammi(nomefile):
    d = defaultdict(list)
    for riga in open(nomefile):
        parola = riga.strip().lower()
        t = signature(parola)
        d[t].append(parola)
    return d
</pre><p>La mia risoluzione dell’Esercizio <a href="#poker">3</a>, scaricabile da
<a href="http://thinkpython2.com/code/PokerHandSoln.py"><span class="c003">http://thinkpython2.com/code/PokerHandSoln.py</span></a>,
usa <span class="c003">setdefault</span> nella funzione
<code>has_straightflush</code>. Ha il difetto di creare un oggetto <span class="c003">Mano</span> ad ogni ripetizione del ciclo, anche se non serve. Come esercizio, riscrivetela usando un defaultdict.</p>
<!--TOC section id="sec233" Tuple con nome (namedtuple)-->
<h2 class="section" id="sec233">19.8  Tuple con nome (namedtuple)</h2><!--SEC END --><p>Molti oggetti semplici sono, fondamentalmente, delle raccolte di valori tra loro correlati. Ad esempio, l’oggetto Punto che abbiamo definito nel Capitolo <a href="#clobjects">15</a> contiene due numeri, <span class="c003">x</span> e <span class="c003">y</span>. Nella definizione di una classe come questa, si comincia di solito con un metodo init e un metodo str:</p><pre class="verbatim">class Punto:

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return '(%g, %g)' % (self.x, self.y)
</pre><p>Qui serve molto codice per trasportare una piccola quantità di informazione. Python dispone di un modo più conciso per dire la stessa cosa:</p><pre class="verbatim">from collections import namedtuple
Punto = namedtuple('Punto', ['x', 'y'])
</pre><p>Il primo argomento è il nome della classe che volete creare. Il secondo è una lista degli attributi, come stringhe, che l’oggetto Punto deve avere. Il valore di ritorno da <span class="c003">namedtuple</span> è un oggetto classe:
<a id="hevea_default1591"></a>
<a id="hevea_default1592"></a>
<a id="hevea_default1593"></a>
<a id="hevea_default1594"></a>
<a id="hevea_default1595"></a></p><pre class="verbatim">&gt;&gt;&gt; Punto
&lt;class '__main__.Punto'&gt;
</pre><p><span class="c003">Punto</span> dispone automaticamente dei metodi <code>__init__</code> e
<code>__str__</code>, pertanto non occorre scriverli.
<a id="hevea_default1596"></a>
<a id="hevea_default1597"></a></p><p>Per creare un oggetto Punto, usate la classe Punto come fosse una funzione:</p><pre class="verbatim">&gt;&gt;&gt; p = Punto(1, 2)
&gt;&gt;&gt; p
Punto(x=1, y=2)
</pre><p>Il metodo init assegna gli argomenti agli attributi usando i nomi che avete specificato. Il metodo str mostra una rappresentazione dell’oggetto Punto e dei suoi attributi. </p><p>Potete accedere agli elementi della namedtuple usando il loro nome:</p><pre class="verbatim">&gt;&gt;&gt; p.x, p.y
(1, 2)
</pre><p>Ma potete anche trattare una namedtuple come una tupla, e usare gli indici:</p><pre class="verbatim">&gt;&gt;&gt; p[0], p[1]
(1, 2)

&gt;&gt;&gt; x, y = p
&gt;&gt;&gt; x, y
(1, 2)
</pre><p>Le tuple con nome offrono un modo rapido per definire delle classi semplici.
Per contro, le classi semplici non sempre rimangono tali. Si potrebbe decidere in un secondo tempo di voler aggiungere dei metodi a una tupla con nome. In quel caso, occorrerebbe definire una nuova classe che erediti dalla tupla con nome:
<a id="hevea_default1598"></a></p><pre class="verbatim">class IperPunto(Punto):
    # aggiungere qui altri metodi
</pre><p>Oppure si può passare ad una definizione di classe tradizionale.</p>
<!--TOC section id="sec234" Raccolta di argomenti con nome-->
<h2 class="section" id="sec234">19.9  Raccolta di argomenti con nome</h2><!--SEC END --><p>Nel Paragrafo <a href="#gather">12.4</a>, avevamo visto come scrivere una funzione che raccoglie in una tupla i suoi argomenti:
<a id="hevea_default1599"></a></p><pre class="verbatim">def stampatutti(*args):
    print(args)
</pre><p>
Questa funzione può essere chiamata con un numero qualunque di argomenti posizionali (cioè, argomenti che non hanno nome):
<a id="hevea_default1600"></a>
<a id="hevea_default1601"></a></p><pre class="verbatim">&gt;&gt;&gt; stampatutti(1, 2.0, '3')
(1, 2.0, '3')
</pre><p>
Tuttavia, l’operatore di raccolta <span class="c003">*</span> non funziona con gli argomenti con nome:
<a id="hevea_default1602"></a></p><pre class="verbatim">&gt;&gt;&gt; stampatutti(1, 2.0, terzo='3')
TypeError: stampatutti() got an unexpected keyword argument 'terzo'
</pre><p>
Per raccogliere gli argomenti con nome, si usa invece l’operatore <span class="c003">**</span>:</p><pre class="verbatim">def stampatutti(*args, **kwargs):
    print(args, kwargs)
</pre><p>
Si può chiamare il parametro di raccolta come si vuole, ma per prassi si usa
<span class="c003">kwargs</span>. Il risultato è un dizionario che mappa i nomi nei valori:</p><pre class="verbatim">&gt;&gt;&gt; stampatutti(1, 2.0, terzo='3')
(1, 2.0) {'terzo': '3'}
</pre><p>
Se disponete di un dizionario di nomi e valori, potete usare l’operatore di spacchettamento, <span class="c003">**</span> , per chiamare una funzione:
<a id="hevea_default1603"></a></p><pre class="verbatim">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Punto(**d)
Punto(x=1, y=2)
</pre><p>
Senza l’operatore di spacchettamento, la funzione interpreterebbe <span class="c003">d</span> come un singolo argomento posizionale, assegnandolo a <span class="c003">x</span> e lamentando l’assenza di qualcosa da assegnare a <span class="c003">y</span>:</p><pre class="verbatim">&gt;&gt;&gt; d = dict(x=1, y=2)
&gt;&gt;&gt; Punto(d)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: __new__() missing 1 required positional argument: 'y'
</pre><p>
Quando si lavora con funzioni che hanno parecchi parametri, è una buona idea creare e passare loro dei dizionari che contengono le opzioni di uso più frequente.</p>
<!--TOC section id="sec235" Glossario-->
<h2 class="section" id="sec235">19.10  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">espressione condizionale:</span></dt><dd class="dd-description"> Un’espressione che contiene uno tra due alternativi valori, a seconda di una data condizione.
<a id="hevea_default1604"></a>
<a id="hevea_default1605"></a></dd><dt class="dt-description"><span class="c009">list comprehension:</span></dt><dd class="dd-description"> Espressione con un ciclo <span class="c003">for</span> tra parentesi quadre che genera una nuova lista.
<a id="hevea_default1606"></a></dd><dt class="dt-description"><span class="c009">generator expression:</span></dt><dd class="dd-description"> Espressione con un ciclo <span class="c003">for</span> tra parentesi tonde che produce un oggetto generatore. 
<a id="hevea_default1607"></a></dd><dt class="dt-description"><span class="c009">multiinsieme:</span></dt><dd class="dd-description"> Ente matematico che rappresenta una corrispondenza tra gli elementi di un insieme e il numero di volte in cui compaiono. </dd><dt class="dt-description"><span class="c009">factory:</span></dt><dd class="dd-description"> Funzione, di solito passata come argomento, usata per creare oggetti.
<a id="hevea_default1608"></a></dd></dl>
<!--TOC section id="sec236" Esercizi-->
<h2 class="section" id="sec236">19.11  Esercizi</h2><!--SEC END --><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>La seguente funzione calcola ricorsivamente il coefficiente binomiale:</em></p><pre class="verbatim"><em>def coeff_binomiale(n, k):
    """Calcola il coefficiente binomiale "n sopra k".

    n: numero di prove
    k: numero di successi

    ritorna: int
    """
    if k == 0:
        return 1
    if n == 0:
        return 0

    res = coeff_binomiale(n-1, k) + coeff_binomiale(n-1, k-1)
    return res
</em></pre><p><em>Riscrivete il corpo della funzione usando delle espressioni condizionali nidificate.</em></p><p><em>Nota: questa funzione non è molto efficiente, perché finisce per calcolare continuamente gli stessi valori. Potreste renderla più efficiente con la memoizzazione (vedere Paragrafo </em><a href="#memoize"><em>11.6</em></a><em>). Riscontrerete però che è difficile farlo, scrivendola con le espressioni condizionali.</em></p></div>
<!--TOC chapter id="sec237" Debug-->
<h1 class="chapter" id="sec237">Appendix A  Debug</h1><!--SEC END --><p><a id="hevea_default1609"></a>
Nell’operazione di rimozione degli errori da un programma, è opportuno distinguere i vari tipi di errore in modo da poterli rintracciare più velocemente:</p><ul class="itemize"><li class="li-itemize">Gli errori di sintassi vengono scoperti dall’interprete quando traduce il codice sorgente in codice macchina. Indicano che c’è qualcosa di sbagliato nella struttura del programma. Esempio: omettere i due punti alla fine di una istruzione <span class="c003">def</span> genera il messaggio, un po’ ridondante, <span class="c003">SyntaxError: invalid syntax</span>.
<a id="hevea_default1610"></a>
<a id="hevea_default1611"></a></li><li class="li-itemize">Gli errori di runtime sono prodotti dall’interprete se qualcosa va storto durante l’esecuzione del programma. Nella maggior parte dei casi, il messaggio di errore specifica dove si è verificato l’errore e quali funzioni erano in esecuzione. Esempio: una ricorsione infinita causa un errore di runtime “<span class="c003">maximum recursion depth exceeded</span>”.
<a id="hevea_default1612"></a>
<a id="hevea_default1613"></a>
<a id="hevea_default1614"></a>
<a id="hevea_default1615"></a></li><li class="li-itemize">Gli errori di semantica sono dei problemi con un programma che viene eseguito senza produrre messaggi di errore, ma che non fa le cose nel modo giusto. Esempio: un’espressione può essere valutata secondo un ordine diverso da quello che si intendeva, generando un risultato non corretto.
<a id="hevea_default1616"></a>
<a id="hevea_default1617"></a>
</li></ul><p>La prima cosa da fare nel debug è capire con che tipo di errore abbiamo a che fare. Anche se i paragrafi che seguono sono organizzati per tipo di errore, alcune tecniche sono applicabili in più di una situazione.</p>
<!--TOC section id="sec238" Errori di sintassi-->
<h2 class="section" id="sec238">A.1  Errori di sintassi</h2><!--SEC END --><p>
<a id="hevea_default1618"></a></p><p>Gli errori di sintassi sono in genere facili da sistemare, una volta capito in cosa consistono. Purtroppo, il messaggio di errore spesso è poco utile. Quelli più comuni sono: <span class="c003">SyntaxError: invalid syntax</span> e
<span class="c003">SyntaxError: invalid token</span>, nessuno dei quali è molto esplicativo.</p><p>In compenso, il messaggio comunica il punto del programma dove si è verificato il problema. Più precisamente, dice dove Python ha notato il problema, che non è necessariamente il punto in cui si trova l’errore.
A volte l’errore è prima del punto indicato dal messaggio, spesso nella riga precedente.
<a id="hevea_default1619"></a>
<a id="hevea_default1620"></a></p><p>Se state costruendo il programma in modo incrementale, è molto probabile che l’errore sia nell’ultima riga che avete aggiunto.</p><p>Se state copiando il codice da un libro, cominciate confrontando attentamente il vostro codice con quello del libro. Controllate ogni carattere. Ricordate però che anche il libro può essere sbagliato, e se vedete qualcosa che somiglia a un errore di sintassi, potrebbe esserlo.</p><p>Ecco alcuni modi di evitare i più comuni errori di sintassi:
<a id="hevea_default1621"></a></p><ol class="enumerate" type=1><li class="li-enumerate">Accertatevi di non usare parole chiave di Python come nomi di variabile.
<a id="hevea_default1622"></a></li><li class="li-enumerate">Controllate che ci siano i due punti alla fine di ogni intestazione di tutte le istruzioni composte, inclusi <span class="c003">for</span>, <span class="c003">while</span>,
<span class="c003">if</span>, e le istruzioni <span class="c003">def</span>.
<a id="hevea_default1623"></a>
<a id="hevea_default1624"></a></li><li class="li-enumerate">Accertatevi che ogni stringa nel codice sia racchiusa da una coppia di virgolette o apici, e che questi siano di tipo indifferenziato e non “tipografici”.
<a id="hevea_default1625"></a></li><li class="li-enumerate">Se avete stringhe a righe multiple con triple virgolette, accertatevi di averle chiuse in modo appropriato. Una stringa non chiusa può causare un errore di <span class="c003">invalid token</span> al termine del programma, oppure può trattare la parte che segue del programma come fosse una stringa, finché non incontra la stringa successiva. Nel secondo caso, potrebbe anche non produrre affatto un messaggio di errore!
<a id="hevea_default1626"></a></li><li class="li-enumerate">Un operatore di apertura non chiuso—<code>(</code>, <code>{</code>, o
<code>[</code>—fa sì che Python consideri la riga successiva come parte dell’istruzione corrente. In genere, si verifica un errore nella riga immediatamente successiva.</li><li class="li-enumerate">Controllate che non ci sia il classico <span class="c003">=</span> al posto di <span class="c003">==</span> all’interno di un’istruzione condizionale.
<a id="hevea_default1627"></a></li><li class="li-enumerate">Controllate l’indentazione per assicurarvi che il codice sia allineato nel modo corretto. Python può gestire sia spazi che tabulazioni, ma se li mescolate possono esserci problemi. Il modo migliore di evitarli è usare un editor di testo appositamente realizzato per Python, che gestisca l’indentazione in modo coerente.
<a id="hevea_default1628"></a>
<a id="hevea_default1629"></a></li><li class="li-enumerate">Se nel codice (compresi stringhe e commenti) ci sono caratteri non-ASCII, tipo le lettere accentate, potrebbero causare problemi, anche se Python 3 gestisce abbastanza bene questi caratteri. Fate attenzione, se copiate e incollate del testo da una pagina web o da altre fonti.</li></ol><p>Se nulla di tutto questo funziona, continuate con il paragrafo seguente...</p>
<!--TOC subsection id="sec239" Continuo a fare modifiche ma non cambia nulla.-->
<h3 class="subsection" id="sec239">A.1.1  Continuo a fare modifiche ma non cambia nulla.</h3><!--SEC END --><p>Se l’interprete dice che c’è un errore ma non lo trovate, può essere che voi e l’interprete non stiate guardando lo stesso codice. Controllate il vostro ambiente di programmazione per assicurarvi che il programma che state modificando sia proprio quello che Python sta tentando di eseguire.</p><p>Se non ne siete certi, provate a mettere deliberatamente un evidente errore di sintassi all’inizio del programma e rieseguitelo. Se l’interprete non trova l’errore, non state eseguendo il nuovo codice.</p><p>Alcune cause possibili:</p><ul class="itemize"><li class="li-itemize">Avete modificato il file e dimenticato di salvare le modifiche prima dell’esecuzione. Alcuni ambienti di programmazione lo fanno automaticamente, ma altri no.</li><li class="li-itemize">Avete cambiato il nome del file, ma state eseguendo ancora quello con il vecchio nome.</li><li class="li-itemize">Qualcosa nel vostro ambiente di sviluppo non è configurato correttamente.</li><li class="li-itemize">Se state scrivendo un modulo usando <span class="c003">import</span>, accertatevi di non dare al vostro modulo lo stesso nome di uno dei moduli standard di Python.</li><li class="li-itemize">Se state usando <span class="c003">import</span> per leggere un modulo, ricordatevi che dovete riavviare l’interprete o usare <span class="c003">reload</span> per leggere un file modificato. Se importate nuovamente il modulo, non succederà nulla.
<a id="hevea_default1630"></a>
<a id="hevea_default1631"></a>
<a id="hevea_default1632"></a></li></ul><p>Se vi bloccate e non riuscite a capire cosa sta succedendo, un’alternativa è ripartire con un nuovo programma come “Ciao, mondo!”, e accertarvi di avere un programma ben conosciuto da eseguire. Quindi, aggiungete gradualmente i pezzi del programma originale a quello nuovo.</p>
<!--TOC section id="sec240" Errori di runtime-->
<h2 class="section" id="sec240">A.2  Errori di runtime</h2><!--SEC END --><p>Una volta che il programma è sintatticamente corretto, Python può leggerlo e quantomeno cominciare ad eseguirlo. Cosa può succedere di spiacevole?</p>
<!--TOC subsection id="sec241" Il programma non fa assolutamente nulla.-->
<h3 class="subsection" id="sec241">A.2.1  Il programma non fa assolutamente nulla.</h3><!--SEC END --><p>È il problema più frequente se il vostro file consiste di funzioni e classi, ma in realtà non invoca alcuna funzione per avviare l’esecuzione. Può essere una cosa intenzionale, se intendete utilizzarlo solo come modulo da importare allo scopo di fornire le classi e le funzioni.</p><p>Se non è questo il caso, assicuratevi che nel programma ci sia una chiamata di funzione e che il flusso di esecuzione la raggiunga (vedete anche il paragrafo “Flusso di esecuzione” più avanti).</p>
<!--TOC subsection id="sec242" Il programma si blocca.-->
<h3 class="subsection" id="sec242">A.2.2  Il programma si blocca.</h3><!--SEC END --><p>
<a id="hevea_default1633"></a>
<a id="hevea_default1634"></a>
<a id="hevea_default1635"></a></p><p>Se un programma si blocca e pare che non stia succedendo nulla, spesso vuol dire che è incappato in un ciclo infinito o in una ricorsione infinita.</p><ul class="itemize"><li class="li-itemize">Se c’è un ciclo particolare dove sospettate che stia il problema, aggiungete un’istruzione di stampa immediatamente prima del ciclo che dice:
“Sto entrando nel ciclo” e una immediatamente dopo che dice:
“Sto uscendo dal ciclo”.<p>Avviate il programma. Se viene visualizzato il primo messaggio ma non il secondo, c’è un ciclo infinito. Proseguite con il Paragrafo “Ciclo infinito” più sotto.</p></li><li class="li-itemize">Il più delle volte, in presenza di una ricorsione infinita, il programma funziona per qualche tempo per poi produrre un errore <span class="c003">RuntimeError: Maximum
recursion depth exceeded</span>. Se succede questo, andate al Paragrafo
“Ricorsione infinita”.<p>Se non ottenete questo errore ma sospettate che ci sia un problema con un metodo o funzione ricorsivi, potete usare ugualmente le tecniche illustrate nel Paragrafo “Ricorsione infinita”.</p></li><li class="li-itemize">Se nessuno di questi punti funziona, fate delle prove su altri cicli o funzioni e metodi ricorsivi.</li><li class="li-itemize">Se ancora non funziona, forse non avete ben chiaro il flusso di esecuzione del vostro programma. Andate al relativo Paragrafo.</li></ul>
<!--TOC subsubsection id="sec243" Ciclo infinito-->
<h4 class="subsubsection" id="sec243">Ciclo infinito</h4><!--SEC END --><p>
<a id="hevea_default1636"></a>
<a id="hevea_default1637"></a>
<a id="hevea_default1638"></a></p><p>Se sospettate che vi sia un ciclo infinito e di sapere quale ciclo in particolare stia causando il problema, aggiungete un’istruzione di stampa alla fine del ciclo in modo da visualizzare il valore delle variabili nella condizione e il valore della condizione.</p><p>Per esempio:</p><pre class="verbatim">while x &gt; 0 and y &lt; 0 :
    # fa qualcosa con x
    # fa qualcosa con y

    print('x: ', x)
    print('y: ', y)
    print('condizione: ', (x &gt; 0 and y &lt; 0))
</pre><p>
Ora, eseguendo il programma, vedrete tre righe di output per ogni ripetizione del ciclo. All’ultimo passaggio, la condizione dovrebbe risultare <span class="c003">False</span>. Se il ciclo continua, vedrete comunque i valori di <span class="c003">x</span> e <span class="c003">y</span>, e potrete capire meglio il motivo per cui non vengono aggiornati correttamente.</p>
<!--TOC subsubsection id="sec244" Ricorsione infinita-->
<h4 class="subsubsection" id="sec244">Ricorsione infinita</h4><!--SEC END --><p>
<a id="hevea_default1639"></a></p><p>Il più delle volte, una ricorsione infinita provoca un errore di <span class="c003">Maximum recursion depth exceeded</span>, dopo che il programma è stato in esecuzione per qualche istante.</p><p>Se sospettate che una funzione stia provocando una ricorsione infinita, controllate innanzitutto che esista un caso base. Deve esistere un qualche tipo di condizione che provoca il ritorno della funzione senza generare un’altra chiamata ricorsiva. Se no, occorre ripensare l’algoritmo e stabilire un caso base.</p><p>Se il caso base c’è ma sembra che il programma non lo raggiunga mai, aggiungete un’istruzione di stampa all’inizio della funzione, in modo da visualizzare i parametri. Ora, eseguendo il programma vedrete alcune righe di output con i valori dei parametri per ogni chiamata della funzione. Se i parametri non tendono verso il caso base, avrete qualche spunto per capire il perché.</p>
<!--TOC subsubsection id="sec245" Flusso di esecuzione-->
<h4 class="subsubsection" id="sec245">Flusso di esecuzione</h4><!--SEC END --><p>
<a id="hevea_default1640"></a></p><p>Se non siete sicuri di come il flusso di esecuzione si muova dentro il vostro programma, aggiungete delle istruzioni di stampa all’inizio di ogni funzione con un messaggio del tipo “sto eseguendo la funzione <span class="c003">pippo</span>”, dove
<span class="c003">pippo</span> è il nome della funzione.</p><p>Ora, eseguendo il programma, verrà stampata una traccia di ogni funzione che viene invocata.</p>
<!--TOC subsection id="sec246" Quando eseguo il programma è sollevata un’eccezione.-->
<h3 class="subsection" id="sec246">A.2.3  Quando eseguo il programma è sollevata un’eccezione.</h3><!--SEC END --><p>
<a id="hevea_default1641"></a>
<a id="hevea_default1642"></a></p><p>Se qualcosa non va durante l’esecuzione, Python stampa un messaggio che include il nome dell’eccezione, la riga del programma dove il problema si è verificato, ed un traceback.
<a id="hevea_default1643"></a></p><p>Il traceback identifica la funzione che era in esecuzione, quella che l’aveva chiamata, quella che <em>a sua volta</em> l’aveva chiamata e così via. In altre parole, traccia la sequenza di chiamate di funzione che hanno condotto alla situazione attuale. Include anche il numero di riga del file dove è avvenuta ciascuna chiamata.</p><p>Innanzitutto bisogna esaminare il punto del programma dove è emerso l’errore e vedere se si riesce a capire cosa è successo. Questi sono alcuni dei più comuni errori in esecuzione:</p><dl class="description"><dt class="dt-description"><span class="c009">NameError:</span></dt><dd class="dd-description"> State cercando di usare una variabile che non esiste nell’ambiente attuale. Controllate che il nome sia scritto esattamente e che sia coerente. Ricordate anche che le variabili locali sono, per l’appunto, locali: non potete fare loro riferimento dall’esterno della funzione in cui sono definite.
<a id="hevea_default1644"></a>
<a id="hevea_default1645"></a></dd><dt class="dt-description"><span class="c009">TypeError:</span></dt><dd class="dd-description"> Ci sono alcune possibili cause:
<a id="hevea_default1646"></a>
<a id="hevea_default1647"></a><ul class="itemize"><li class="li-itemize">State cercando di usare un valore in modo improprio. Esempio: indicizzare una stringa, lista o tupla con qualcosa di diverso da un numero intero. 
<a id="hevea_default1648"></a></li><li class="li-itemize">C’è una mancata corrispondenza tra gli elementi in una stringa di formato e gli elementi passati per la conversione. Succede se il numero degli elementi non corrisponde o se viene tentata una conversione non valida.
<a id="hevea_default1649"></a>
<a id="hevea_default1650"></a></li><li class="li-itemize">State passando a una funzione un numero sbagliato di argomenti. Per i metodi, guardatetene la definizione e controllate che il primo parametro sia <span class="c003">self</span>. Quindi guardate l’invocazione: assicuratevi di invocare il metodo su un oggetto con il giusto tipo e di fornire correttamente gli altri argomenti.</li></ul></dd><dt class="dt-description"><span class="c009">KeyError:</span></dt><dd class="dd-description"> State tentando di accedere a un elemento di un dizionario usando una chiave che nel dizionario non esiste. Se le chiavi sono delle stringhe, ricordate che c’è differenza tra lettere maiuscole e minuscole.
<a id="hevea_default1651"></a>
<a id="hevea_default1652"></a>
<a id="hevea_default1653"></a></dd><dt class="dt-description"><span class="c009">AttributeError:</span></dt><dd class="dd-description"> State tentando di accedere a un attributo o a un metodo che non esiste. Controllate se è scritto giusto! Potete usare la funzione predefinita <span class="c003">vars</span> per elencare gli attributi esistenti.<p>Se un AttributeError indica che un oggetto è di tipo <span class="c003">NoneType</span>,
vuol dire che è <span class="c003">None</span>. Il problema non è il nome dell’attributo, ma l’oggetto. la ragione per cui un oggetto è <span class="c003">None</span> può essere dimenticare di ritornare un valore da una funzione: se arrivate in fondo a una funzione senza intercettare un’istruzione <span class="c003">return</span>, questa restituisce <span class="c003">None</span>. Un’altra causa frequente è usare il risultato di un metodo di una lista, come <span class="c003">sort</span>, che restituisce <span class="c003">None</span>.
<a id="hevea_default1654"></a>
<a id="hevea_default1655"></a></p></dd><dt class="dt-description"><span class="c009">IndexError:</span></dt><dd class="dd-description"> L’indice che state usando per accedere a una lista, stringa o tupla è maggiore della lunghezza della sequenza meno uno. Immediatamente prima dell’ubicazione dell’errore aggiungete un’istruzione di stampa che mostri il valore dell’indice e la lunghezza della struttura. Quest’ultima è della lunghezza esatta? E l’indice ha il valore corretto?
<a id="hevea_default1656"></a>
<a id="hevea_default1657"></a></dd></dl><p>Il debugger Python (<span class="c003">pdb</span>) è utile per catturare le eccezioni, perché vi permette di esaminare lo stato del programma immediatamente prima dell’errore. Potete leggere approfondimenti su <span class="c003">pdb</span> sul sito <a href="https://docs.python.org/3/library/pdb.html"><span class="c003">https://docs.python.org/3/library/pdb.html</span></a>.
<a id="hevea_default1658"></a>
<a id="hevea_default1659"></a></p>
<!--TOC subsection id="sec247" Ho aggiunto talmente tante istruzioni di stampa che sono sommerso di output.-->
<h3 class="subsection" id="sec247">A.2.4  Ho aggiunto talmente tante istruzioni di stampa che sono sommerso di output.</h3><!--SEC END --><p>
<a id="hevea_default1660"></a>
<a id="hevea_default1661"></a></p><p>Una controindicazione delle istruzioni di stampa nel debugging è che si rischia di essere inondati di messaggi. Ci sono due modi di procedere: o semplificate l’output o semplificate il programma.</p><p>Per semplificare l’output, potete rimuovere o commentare le istruzioni di stampa superflue, o accorparle, o dare all’output un formato più leggibile.</p><p>Per semplificare il programma, ci sono diverse opzioni. Primo, riducete il problema che il programma sta affrontando. Per esempio, se state cercando una lista, cercatene una <em>piccola</em>. Se il programma riceve input dall’utente, dategli il dato più semplice che causa il problema.
<a id="hevea_default1662"></a></p><p>Secondo, ripulite il programma. Togliete il codice inutile e riorganizzate il programma in modo da renderlo il più facile possibile da leggere. Per esempio, se sospettate che l’errore sia in una parte profondamente nidificata del programma, cercate di riscrivere quella parte con una struttura più semplice. Se sospettate di una corposa funzione, provate a suddividerla in funzioni più piccole e a testarle separatamente.
<a id="hevea_default1663"></a>
<a id="hevea_default1664"></a></p><p>Spesso, il procedimento di ricercare il caso di prova più circoscritto porta a trovare l’errore. Se riscontrate che il programma funziona in un caso ma non in un altro, questo vi dà una chiave di lettura di quello che sta succedendo.</p><p>Allo stesso modo, riscrivere un pezzo di codice vi può aiutare a trovare errori insidiosi. Una modifica che pensavate ininfluente sul programma, e che invece influisce, può farvi trovare il bandolo della matassa.</p>
<!--TOC section id="sec248" Errori di semantica-->
<h2 class="section" id="sec248">A.3  Errori di semantica</h2><!--SEC END --><p>Gli errori di semantica sono i più difficili da affrontare, perché l’interprete non fornisce informazioni su ciò che non va. Sapete per certo solo quello che il programma dovrebbe fare, ma non fa.
<a id="hevea_default1665"></a>
<a id="hevea_default1666"></a></p><p>Innanzitutto occorre stabilire una connessione logica tra il testo del programma e il comportamento che vedete. Vi serve un’ipotesi di cosa sta facendo in realtà il programma. Quello che rende difficili le cose è che i computer eseguono le operazioni in tempi rapidissimi. </p><p>Vi capiterà di desiderare di poter rallentare il programma ad una velocità umana, e in effetti con alcuni strumenti di debug potete farlo. Ma il tempo che ci vuole per inserire alcune istruzioni di stampa ben calibrate è spesso più breve di quello necessario a impostare il debugger, inserire e togliere i punti di interruzione, ed eseguire i passi per portare il programma dove si verifica l’errore .</p>
<!--TOC subsection id="sec249" Il mio programma non funziona.-->
<h3 class="subsection" id="sec249">A.3.1  Il mio programma non funziona.</h3><!--SEC END --><p>Dovreste porvi queste domande:</p><ul class="itemize"><li class="li-itemize">C’è qualcosa che il programma dovrebbe fare ma che non sembra accadere? Trovate la parte del codice che esegue quella funzione e assicuratevi che sia effettivamente eseguita quando ritenete che dovrebbe esserlo.</li><li class="li-itemize">Sta succedendo qualcosa che non dovrebbe succedere? Trovate il codice che genera quella funzione e controllate se viene eseguita quando invece non dovrebbe esserlo.</li><li class="li-itemize">Una porzione di codice sta producendo effetti inattesi? Assicuratevi di capire il codice in questione, specie se coinvolge funzioni o metodi in altri moduli Python. Leggete la documentazione delle funzioni che chiamate. Provatele scrivendo semplici test e controllando i risultati.</li></ul><p>Per programmare, vi serve un modello mentale di come funziona il programma. Se scrivete un programma che non fa quello che volete, spesso il problema non è nel programma ma nel vostro modello mentale.
<a id="hevea_default1667"></a></p><p>Il modo migliore per correggere il vostro modello mentale è spezzare il programma nei suoi componenti (di solito funzioni e metodi) e provare indipendentemente ogni singolo componente.
Quando avrete trovato la discrepanza tra il vostro modello e la realtà, potrete risolvere il problema.</p><p>Naturalmente, dovreste costruire e provare i componenti mentre state sviluppando il programma. Così, se vi imbattete in un problema, dovrebbe esserci solo una piccola quantità di codice di cui occorre verificare l’esattezza.</p>
<!--TOC subsection id="sec250" Ho una grande e complicata espressione che non fa quello che voglio.-->
<h3 class="subsection" id="sec250">A.3.2  Ho una grande e complicata espressione che non fa quello che voglio.</h3><!--SEC END --><p>
<a id="hevea_default1668"></a></p><p>Scrivere espressioni complesse va bene fino a quando restano leggibili, ma poi possono diventare difficili da correggere. Un buon consiglio è di spezzare un’espressione complessa in una serie di assegnazioni a variabili temporanee.</p><p>Per esempio:</p><pre class="verbatim">self.mani[i].aggiungiCarta(self.mani[self.trovaVicino(i)].togliCarta())
</pre><p>
Può essere riscritta così:</p><pre class="verbatim">vicino = self.trovaVicino(i)
cartaScelta = self.mani[vicino].togliCarta()
self.mani[i].aggiungiCarta(cartaScelta)
</pre><p>
La versione esplicita è più leggibile perché i nomi delle variabili aggiungono informazione, ed è più facile da correggere perché potete controllare i tipi delle variabili intermedie e visualizzare il loro valore.
<a id="hevea_default1669"></a></p><p>Un altro problema che si verifica con le grandi espressioni è che l’ordine di valutazione delle operazioni può essere diverso da quello che pensate.
Per esempio, nel tradurre in Python l’espressione
<span class="c008">x</span>/2 π, potreste scrivere:</p><pre class="verbatim">y = x / 2 * math.pi
</pre><p>
È sbagliato, perché moltiplicazione e divisione hanno la stessa priorità e vengono calcolate da sinistra verso destra; quindi quell’espressione calcola <span class="c008">x</span> π / 2.
<a id="hevea_default1670"></a>
<a id="hevea_default1671"></a></p><p>Un buon modo di fare il debug delle espressioni è aggiungere delle parentesi per rendere esplicito l’ordine delle operazioni.</p><pre class="verbatim"> y = x / (2 * math.pi)
</pre><p>
Usate le parentesi ogni volta che non siete certi dell’ordine delle operazioni. Non solo il programma sarà corretto (nel senso che farà quello che volete), sarà anche più leggibile da altre persone che non hanno imparato a memoria l’ordine delle operazioni</p>
<!--TOC subsection id="sec251" Ho una funzione che non restituisce quello che voglio.-->
<h3 class="subsection" id="sec251">A.3.3  Ho una funzione che non restituisce quello che voglio.</h3><!--SEC END --><p>
<a id="hevea_default1672"></a>
<a id="hevea_default1673"></a></p><p>Se avete un’istruzione <span class="c003">return</span> associata ad un’espressione complessa, non avete modo di stampare il risultato prima del ritorno. Di nuovo, usate una variabile temporanea. Per esempio, anziché:</p><pre class="verbatim">return self.mani[i].togliUguali()
</pre><p>
potete scrivere:</p><pre class="verbatim">conta = self.mani[i].togliUguali()
return conta
</pre><p>
Ora potete stampare il valore di <span class="c003">conta</span> prima che sia restituito.</p>
<!--TOC subsection id="sec252" Sono proprio bloccato e mi serve aiuto.-->
<h3 class="subsection" id="sec252">A.3.4  Sono proprio bloccato e mi serve aiuto.</h3><!--SEC END --><p>Per prima cosa, staccatevi dal computer per qualche minuto. I computer emettono onde che influenzano il cervello, causando questi sintomi:</p><ul class="itemize"><li class="li-itemize">Frustrazione e rabbia.
<a id="hevea_default1674"></a>
<a id="hevea_default1675"></a>
<a id="hevea_default1676"></a>
<a id="hevea_default1677"></a></li><li class="li-itemize">Credenze superstiziose (“il computer mi odia”) e influssi magici (“il programma funziona solo quando indosso il berretto all’indietro”).
<a id="hevea_default1678"></a></li><li class="li-itemize">Programmazione a tentoni (il tentativo di programmare scrivendo ogni possibile programma e prendendo quello che funziona).
<a id="hevea_default1679"></a>
<a id="hevea_default1680"></a></li></ul><p>Se accusate qualcuno di questi sintomi, alzatevi e andate a fare una passeggiata. Quando vi siete calmati, ripensate al programma. Cosa sta facendo? Quali sono le possibili cause del suo comportamento? Quand’era l’ultima volta che avete avuto un programma funzionante, e cosa avete fatto dopo?</p><p>A volte per trovare un bug è richiesto solo del tempo. Io trovo spesso bug mentre non sono al computer e distraggo la mente. Tra i posti migliori per trovare bug: in treno; sotto la doccia; a letto appena prima di addormentarsi.</p>
<!--TOC subsection id="sec253" No, ho davvero bisogno di aiuto.-->
<h3 class="subsection" id="sec253">A.3.5  No, ho davvero bisogno di aiuto.</h3><!--SEC END --><p>Capita. Anche i migliori programmatori a volte si bloccano. Magari avete lavorato talmente a lungo sul programma da non riuscire a vedere un errore. Un paio di occhi freschi sono quello che ci vuole.</p><p>Prima di rivolgervi a qualcun altro, dovete fare dei preparativi. Il vostro programma dovrebbe essere il più semplice possibile, e dovete fare in modo di lavorare sul più circoscritto input che causa l’errore.
Dovete posizionare delle istruzioni di stampa nei posti adatti (e l’output che producono deve essere comprensibile). Il problema va compreso abbastanza bene da poterlo descrivere in poche parole.</p><p>Quando portate qualcuno ad aiutarvi, assicuratevi di dargli tutte le informazioni che servono:</p><ul class="itemize"><li class="li-itemize">Se c’è un messaggio di errore, di cosa si tratta e quale parte del programma indica?</li><li class="li-itemize">Qual è l’ultima cosa che avete fatto prima della comparsa dell’errore? Quali erano le ultime righe di codice che avevate scritto, oppure il nuovo caso di prova che non è riuscito?</li><li class="li-itemize">Cosa avete provato a fare finora, e cosa avete appreso dai tentativi?</li></ul><p>Quando trovate l’errore, prendetevi un attimo di tempo per pensare cosa avreste potuto fare per trovarlo più velocemente: la prossima volta che incontrerete qualcosa di simile, vi sarà più facile scoprire l’errore.</p><p>Ricordate che lo scopo non è solo far funzionare il programma, ma imparare a farlo funzionare.</p>
<!--TOC chapter id="sec254" Analisi degli Algoritmi-->
<h1 class="chapter" id="sec254">Appendix B  Analisi degli Algoritmi</h1><!--SEC END --><p>
<a id="algorithms"></a></p><blockquote class="quote">
Questa Appendice è un estratto adattato da <span class="c008">Think Complexity</span>, di
Allen B. Downey, pure pubblicato da O’Reilly Media (2012). Quando avete finito questo libro, vi invito a prenderlo in considerazione.
</blockquote><p>L’<span class="c009">analisi degli algoritmi</span> è una branca dell’informatica che studia le prestazioni degli algoritmi, in particolare il tempo di esecuzione e i requisiti di memoria. Vedere anche
<a href="http://en.wikipedia.org/wiki/Analysis_of_algorithms"><span class="c003">http://en.wikipedia.org/wiki/Analysis_of_algorithms</span></a>.
<a id="hevea_default1681"></a> <a id="hevea_default1682"></a></p><p>L’obiettivo pratico dell’analisi degli algoritmi è predire le prestazioni di algoritmi diversi in modo da orientare le scelte di progettazione.</p><p>Durante la campagna elettorale per le Presidenziali degli Stati Uniti del 2008, al candidato Barack Obama fu chiesto di fare un’analisi estemporanea in occasione della sua visita a Google. Il direttore esecutivo Eric Schmidt gli chiese scherzosamente “il modo più efficiente di ordinare un milione di interi a 32-bit”.
Obama era stato presumibilmente messo sull’avviso, poiché replicò subito: “Credo che un ordinamento a bolle sarebbe il modo sbagliato di procedere”.
Vedere <a href="http://www.youtube.com/watch?v=k4RRi_ntQc8"><span class="c003">http://www.youtube.com/watch?v=k4RRi_ntQc8</span></a>.
<a id="hevea_default1683"></a>
<a id="hevea_default1684"></a>
<a id="hevea_default1685"></a></p><p>È vero: l’ordinamento a bolle, o “bubble sort”, è concettualmente semplice ma è lento per grandi insiemi di dati. La risposta che Schmidt probabilmente si aspettava era “radix sort” (<a href="http://it.wikipedia.org/wiki/Radix_sort"><span class="c003">http://it.wikipedia.org/wiki/Radix_sort</span></a>)<sup><a id="text2" href="#note2">1</a></sup>.
<a id="hevea_default1686"></a></p><p>Scopo dell’analisi degli algoritmi è fare dei confronti significativi tra algoritmi, ma occorre tener conto di alcuni problemi:
<a id="hevea_default1687"></a></p><ul class="itemize"><li class="li-itemize">L’efficienza relativa degli algoritmi può dipendere dalle caratteristiche dell’hardware, per cui un algoritmo può essere più veloce sulla Macchina A, un altro sulla Macchina B. La soluzione in genere è specificare un
<span class="c009">modello di macchina</span> e quindi analizzare il numero di passi, o operazioni, che un algoritmo richiede su quel dato modello.
<a id="hevea_default1688"></a></li><li class="li-itemize">L’efficienza relativa può dipendere da alcuni dettagli dell’insieme di dati, Per esempio, alcuni algoritmi di ordinamento sono più veloci se i dati sono già parzialmente ordinati; altri in casi simili sono più lenti. Un modo di affrontare il problema è di analizzare lo scenario del <span class="c009">caso peggiore</span>. Talvolta è utile anche analizzare le prestazioni del caso medio, ma questo comporta più difficoltà e può non essere facile stabilire quale insieme di dati mediare.
<a id="hevea_default1689"></a>
<a id="hevea_default1690"></a></li><li class="li-itemize">L’efficienza relativa dipende anche dalle dimensioni del problema. Un algoritmo di ordinamento che è veloce per liste corte può diventare lento su liste lunghe. La soluzione più comune è di esprimere il tempo di esecuzione (o il numero di operazioni) in funzione delle dimensioni del problema, e raggruppare le funzioni in categorie a seconda di quanto velocemente crescono al crescere delle dimensioni del problema.</li></ul><p>Il lato buono di questo tipo di confronto è che conduce a una semplice classificazione degli algoritmi. Ad esempio, se sappiamo che il tempo di esecuzione dell’algoritmo A tende ad essere proporzionale alle dimensioni dell’input, <span class="c008">n</span>, e l’algoritmo B tende ad essere proporzionale a <span class="c008">n</span><sup>2</sup>, allora possiamo attenderci che A sia più veloce di B, almeno per grandi valori di <span class="c008">n</span>.</p><p>Questo tipo di analisi ha alcune avvertenze, ma ci torneremo più avanti.</p>
<!--TOC section id="sec255" Ordine di complessità-->
<h2 class="section" id="sec255">B.1  Ordine di complessità</h2><!--SEC END --><p>Supponiamo che abbiate analizzato due algoritmi esprimendo i loro tempi di esecuzione in funzione delle dimensioni dell’input: l’Algoritmo A impiega 100<span class="c008">n</span>+1 operazioni per risolvere un problema di dimensione <span class="c008">n</span>; l’Algoritmo B impiega <span class="c008">n</span><sup>2</sup> + <span class="c008">n</span> + 1 operazioni.
<a id="hevea_default1691"></a></p><p>La tabella seguente mostra il tempo di esecuzione di questi algoritmi per diverse dimensioni del problema:</p><table class="c000 cellpadding1" border=1><tr><td class="c013">Dimensione</td><td class="c013">Tempo</td><td class="c013">Tempo </td></tr>
<tr><td class="c013">dell’input	</td><td class="c013">Algoritmo A</td><td class="c013">Algoritmo B </td></tr>
<tr><td class="c013">10</td><td class="c013">1 001</td><td class="c013">111 </td></tr>
<tr><td class="c013">100</td><td class="c013">10 001</td><td class="c013">10 101 </td></tr>
<tr><td class="c013">1 000</td><td class="c013">100 001</td><td class="c013">1 001 001 </td></tr>
<tr><td class="c013">10 000</td><td class="c013">1 000 001</td><td class="c013">&gt; 10<sup>10</sup> </td></tr>
</table><p>Per <span class="c008">n</span>=10, l’Algoritmo A si comporta piuttosto male: impiega quasi 10 volte il tempo dell’Algoritmo B. Ma per <span class="c008">n</span>=100 sono circa equivalenti, e per grandi valori A è molto migliore.</p><p>Il motivo fondamentale è che, per grandi valori di n, ogni funzione che contiene un termine <span class="c008">n</span><sup>2</sup> crescerà più rapidamente di una che ha come termine dominante <span class="c008">n</span>. L’<span class="c009">operazione dominante</span> è quella relativa al termine con il più alto esponente.
<a id="hevea_default1692"></a>
<a id="hevea_default1693"></a></p><p>Per l’algoritmo A, l’operazione dominante ha un grande coefficiente, 100, ed è per questo che B è migliore di A per piccoli valori di <span class="c008">n</span>. Ma indipendentemente dal coefficiente, esisterà un valore di <span class="c008">n</span> a partire dal quale
<span class="c008">a n</span><sup>2</sup> &gt; <span class="c008">b n</span>, qualunque siano i valori di <span class="c008">a</span> e <span class="c008">b</span>.
<a id="hevea_default1694"></a></p><p>Stesso discorso vale per i termini secondari. Anche se il tempo di esecuzione dell’Algoritmo A fosse <span class="c008">n</span>+1000000, sarebbe sempre migliore di B per valori sufficientemente grandi di <span class="c008">n</span>.</p><p>In genere, possiamo aspettarci che un algoritmo con piccola operazione dominante sia migliore per problemi di dimensione maggiore, ma per quelli di minori dimensioni può esistere un <span class="c009">punto di intersezione</span> dove un altro algoritmo diventa migliore. Questo punto dipende dai dettagli dell’algoritmo, dai dati di input e dall’hardware, quindi di solito è trascurato per gli scopi dell’analisi degli algoritmi. Ma non significa che dobbiate scordarvene.
<a id="hevea_default1695"></a></p><p>Se due algoritmi hanno l’operazione dominante dello stesso ordine, è difficile stabilire quale sia migliore; ancora, la risposta dipende dai dettagli. Per l’analisi degli algoritmi, le funzioni dello stesso ordine sono considerate equivalenti, anche se hanno coefficienti diversi.</p><p>Un <span class="c009">ordine di complessità</span> è dato da un insieme di funzioni il cui comportamento di crescita è considerato equivalente. Per esempio, 2<span class="c008">n</span>, 100<span class="c008">n</span> e <span class="c008">n</span>+1 appartengono allo stesso ordine di complessità, che si scrive <span class="c008">O</span>(<span class="c008">n</span>) nella <span class="c009">notazione O-grande</span> e viene chiamato <span class="c009">lineare</span> perché tutte le funzioni dell’insieme crescono in maniera lineare al crescere di <span class="c008">n</span>.
<a id="hevea_default1696"></a>
<a id="hevea_default1697"></a></p><p>Tutte le funzioni con operazione dominante <span class="c008">n</span><sup>2</sup> appartengono a <span class="c008">O</span>(<span class="c008">n</span><sup>2</sup>) e sono dette <span class="c009">quadratiche</span>.
<a id="hevea_default1698"></a></p><p>La tabella seguente mostra alcuni degli ordini di complessità più comuni nell’analisi degli algoritmi, in ordine crescente di inefficienza.
<a id="hevea_default1699"></a></p><table class="c000 cellpadding1" border=1><tr><td class="c013">Ordine di</td><td class="c013">Nome </td></tr>
<tr><td class="c013">complessità</td><td class="c013">&nbsp;</td></tr>
<tr><td class="c013"><span class="c008">O</span>(1)</td><td class="c013">costante </td></tr>
<tr><td class="c013"><span class="c008">O</span>(log<sub><span class="c008">b</span></sub> <span class="c008">n</span>)</td><td class="c013">logaritmico (per qualunque <span class="c008">b</span>) </td></tr>
<tr><td class="c013"><span class="c008">O</span>(<span class="c008">n</span>)</td><td class="c013">lineare </td></tr>
<tr><td class="c013"><span class="c008">O</span>(<span class="c008">n</span> log<sub><span class="c008">b</span></sub> <span class="c008">n</span>)</td><td class="c013">linearitmico </td></tr>
<tr><td class="c013"><span class="c008">O</span>(<span class="c008">n</span><sup>2</sup>)</td><td class="c013">quadratico </td></tr>
<tr><td class="c013"><span class="c008">O</span>(<span class="c008">n</span><sup>3</sup>)</td><td class="c013">cubico </td></tr>
<tr><td class="c013"><span class="c008">O</span>(<span class="c008">c</span><sup><span class="c008">n</span></sup>)</td><td class="c013">esponenziale (per qualunque <span class="c008">c</span>) </td></tr>
</table><p>Per i termini logaritmici, la base del logaritmo non ha importanza; cambiare base equivale a moltiplicare per una costante, il che non modifica l’ordine di complessità. Allo stesso modo, tutte le funzioni esponenziali appartengono allo stesso ordine indipendentemente dalla base. Dato che le funzioni esponenziali crescono molto velocemente, gli algoritmi esponenziali sono utili solo per problemi di piccole dimensioni.
<a id="hevea_default1700"></a>
<a id="hevea_default1701"></a></p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Leggete la pagina di Wikipedia sulla notazione O-grande: 
</em><a href="http://it.wikipedia.org/wiki/O-grande"><em><span class="c003">http://it.wikipedia.org/wiki/O-grande</span></em></a><em> e rispondete alle seguenti domande:</em></p><ol class="enumerate" type=1><li class="li-enumerate">
<em>Qual è l’ordine di complessità di </em><span class="c008">n</span><sup>3</sup> + <span class="c008">n</span><sup>2</sup><em>?
E di </em>1000000 <span class="c008">n</span><sup>3</sup> + <span class="c008">n</span><sup>2</sup><em>?
E di </em><span class="c008">n</span><sup>3</sup> + 1000000 <span class="c008">n</span><sup>2</sup><em>?</em></li><li class="li-enumerate"><em>Qual è l’ordine di complessità </em>(<span class="c008">n</span><sup>2</sup> + <span class="c008">n</span>) · (<span class="c008">n</span> + 1)<em>? Prima di iniziare a moltiplicare, ricordate che vi interessa solo l’operazione dominante.</em></li><li class="li-enumerate"><em>Se </em><span class="c008">f</span><em> appartiene a </em><span class="c008">O</span>(<span class="c008">g</span>)<em>, per una non specificata funzione </em><span class="c008">g</span><em>, cosa possiamo dire di </em><span class="c008">af</span>+<span class="c008">b</span><em>?</em></li><li class="li-enumerate"><em>Se </em><span class="c008">f</span><sub>1</sub><em> e </em><span class="c008">f</span><sub>2</sub><em> appartengono a </em><span class="c008">O</span>(<span class="c008">g</span>)<em>, cosa possiamo dire di </em><span class="c008">f</span><sub>1</sub> + <span class="c008">f</span><sub>2</sub><em>?</em></li><li class="li-enumerate"><em>Se </em><span class="c008">f</span><sub>1</sub><em> appartiene a </em><span class="c008">O</span>(<span class="c008">g</span>)<em>
e </em><span class="c008">f</span><sub>2</sub><em> appartiene a </em><span class="c008">O</span>(<span class="c008">h</span>)<em>,
cosa possiamo dire di </em><span class="c008">f</span><sub>1</sub> + <span class="c008">f</span><sub>2</sub><em>?</em></li><li class="li-enumerate"><em>Se </em><span class="c008">f</span><sub>1</sub><em> appartiene a </em><span class="c008">O</span>(<span class="c008">g</span>)<em> e </em><span class="c008">f</span><sub>2</sub><em> appartiene a </em><span class="c008">O</span>(<span class="c008">h</span>)<em>,
cosa possiamo dire di </em><span class="c008">f</span><sub>1</sub> · <span class="c008">f</span><sub>2</sub><em>?
</em></li></ol></div><p>I programmatori attenti alle prestazioni sono spesso critici su questo tipo di analisi. Ne hanno un motivo: a volte i coefficienti e i termini secondari fanno davvero differenza. E a volte i dettagli dell’hardware, del linguaggio di programmazione, e delle caratteristiche dell’input fanno una grande differenza. E per i piccoli problemi, l’analisi asintotica è irrilevante.</p><p>Ma tenute presenti queste avvertenze, l’analisi degli algoritmi è uno strumento utile. Almeno per i grandi problemi, l’algoritmo “migliore” è effettivamente migliore, e a volte <em>molto</em> migliore. La differenza tra due algoritmi dello stesso ordine di solito è un fattore costante, ma la differenza tra un buon algoritmo e uno cattivo è illimitata!</p>
<!--TOC section id="sec256" Analisi delle operazioni fondamentali di Python-->
<h2 class="section" id="sec256">B.2  Analisi delle operazioni fondamentali di Python</h2><!--SEC END --><p>In Python, molte operazioni aritmetiche sono a tempo costante: di solito la moltiplicazione impiega più tempo di addizione e sottrazione, e la divisione impiega ancora di più, ma i tempi di esecuzione sono indipendenti dalla grandezza degli operandi. Fanno eccezione gli interi molto grandi: in tal caso il tempo di elaborazione cresce al crescere del numero delle cifre.
<a id="hevea_default1702"></a></p><p>Le operazioni di indicizzazione—lettura e scrittura di elementi di una sequenza o dizionario—sono anch’esse a tempo costante, indipendentemente dalle dimensioni della struttura di dati.
<a id="hevea_default1703"></a></p><p>Un ciclo <span class="c003">for</span> che attraversa una sequenza o un dizionario è di solito lineare, a patto che tutte le operazioni nel corpo del ciclo siano a tempo costante. Per esempio, la sommatoria degli elementi di una lista è lineare:</p><pre class="verbatim">    totale = 0
    for x in t:
        totale += x
</pre><p>La funzione predefinita <span class="c003">sum</span> è pure lineare, visto che fa la stessa cosa, ma tende ad essere più rapida perché è un’implementazione più efficiente: nel linguaggio dell’analisi degli algoritmi, ha un coefficiente dell’operazione dominante più piccolo.</p><p>Come regola di massima, se il corpo di un ciclo appartiene a <span class="c008">O</span>(<span class="c008">n</span><sup><span class="c008">a</span></sup>) allora il ciclo nel suo complesso appartiene a <span class="c008">O</span>(<span class="c008">n</span><sup><span class="c008">a</span>+1</sup>). Fa eccezione il caso in cui il ciclo esce dopo un numero di iterazioni costante. Se un ciclo viene eseguito per <span class="c008">k</span> volte indipendentemente da <span class="c008">n</span>, allora il ciclo appartiene a <span class="c008">O</span>(<span class="c008">n</span><sup><span class="c008">a</span></sup>), anche per grandi valori di <span class="c008">k</span>.</p><p>Moltiplicare per <span class="c008">k</span> non cambia l’ordine di complessità, ma nemmeno dividere. Pertanto se il corpo del ciclo appartiene <span class="c008">O</span>(<span class="c008">n</span><sup><span class="c008">a</span></sup>) e viene eseguito
<span class="c008">n</span>/<span class="c008">k</span> volte, il ciclo appartiene a <span class="c008">O</span>(<span class="c008">n</span><sup><span class="c008">a</span>+1</sup>), anche per grandi valori di <span class="c008">k</span>.</p><p>La maggioranza delle operazioni su stringhe e tuple sono lineari, eccetto l’indicizzazione e <span class="c003">len</span>, che sono a tempo costante. Le funzioni predefinite <span class="c003">min</span> e <span class="c003">max</span> sono lineari. Il tempo di esecuzione dello slicing è proporzionale alla lunghezza del risultato, ma indipendente dalle dimensioni del dato di partenza.
<a id="hevea_default1704"></a>
<a id="hevea_default1705"></a></p><p>Il concatenamento di stringhe è lineare. Il tempo di esecuzione dipende dalla somma delle lunghezze degli operandi.
<a id="hevea_default1706"></a></p><p>Tutti i metodi delle stringhe sono lineari, ma se le lunghezze delle stringhe sono limitate da una costante—ad esempio operazioni su singoli caratteri—sono considerati a tempo costante.
Il metodo delle stringhe <span class="c003">join</span> è lineare, e il tempo di esecuzione dipende dalla lunghezza totale delle stringhe.
<a id="hevea_default1707"></a></p><p>La maggior parte dei metodi delle liste sono lineari, con alcune eccezioni:
<a id="hevea_default1708"></a></p><ul class="itemize"><li class="li-itemize">L’aggiunta di un elemento alla fine di una lista è mediamente a tempo costante; quando si supera lo spazio disponibile, occasionalmente la lista viene copiata in uno spazio più ampio, ma il tempo totale per <span class="c008">n</span> operazioni è <span class="c008">O</span>(<span class="c008">n</span>), quindi il tempo medio di ciascuna operazione è <span class="c008">O</span>(1).</li><li class="li-itemize">La rimozione di un elemento dalla fine della lista è a tempo costante.</li><li class="li-itemize">L’ordinamento appartiene a <span class="c008">O</span>(<span class="c008">n</span> log<span class="c008">n</span>).
<a id="hevea_default1709"></a></li></ul><p>La maggior parte delle operazioni e dei metodi dei dizionari sono lineari, con alcune eccezioni:
<a id="hevea_default1710"></a></p><ul class="itemize"><li class="li-itemize">Il tempo di esecuzione di <span class="c003">update</span> è proporzionale alle dimensioni del dizionario passato come parametro, non del dizionario che viene aggiornato.</li><li class="li-itemize"><span class="c003">keys</span>, <span class="c003">values</span> e <span class="c003">items</span> sono a tempo costante perché restituiscono iteratori. Ma se attraversate con un ciclo un iteratore, il ciclo sarà lineare.
<a id="hevea_default1711"></a></li></ul><p>Le prestazioni dei dizionari sono uno dei piccoli miracoli dell’informatica. Vedremo come funzionano nel Paragrafo <a href="#hashtable">B.4</a>.</p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  <p><em>Leggete la pagina di Wikipedia sugli algoritmi di ordinamento:
</em><a href="http://it.wikipedia.org/wiki/Algoritmo_di_ordinamento"><em><span class="c003">http://it.wikipedia.org/wiki/Algoritmo_di_ordinamento</span></em></a><em> e rispondete alle seguenti domande:
</em><a id="hevea_default1712"></a></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Che cos’è un ordinamento per confronto (“comparison sort”)? Qual è l’ordine di complessità minimo, nel peggiore dei casi, per un ordinamento per confronto? Qual è l’ordine di complessità minimo, nel peggiore dei casi, per qualsiasi algoritmo di ordinamento?
</em><a id="hevea_default1713"></a></li><li class="li-enumerate"><em>Qual è l’ordine di complessità dell’ordinamento a bolle (o bubblesort), e perché Barack Obama pensa che sia “il modo sbagliato di procedere”?</em></li><li class="li-enumerate"><em>Qual è l’ordine di complessità del radix sort? Quali precondizioni devono essere soddisfatte per poterlo usare?</em></li><li class="li-enumerate"><em>Che cos’è un ordinamento stabile (“stable sort”) e perché è interessante in pratica?
</em><a id="hevea_default1714"></a></li><li class="li-enumerate"><em>Qual è il peggior algoritmo di ordinamento (tra quelli che hanno un nome)?</em></li><li class="li-enumerate"><em>Quale algoritmo di ordinamento usa la libreria C? Quale usa Python? Questi algoritmi sono stabili? Eventualmente fate alcune ricerche sul web per trovare le risposte.</em></li><li class="li-enumerate"><em>Molti degli ordinamenti che non operano per confronto sono lineari, allora perché Python usa un ordinamento per confronto di tipo </em><span class="c008">O</span>(<span class="c008">n</span> log<span class="c008">n</span>)<em> ?</em></li></ol></div>
<!--TOC section id="sec257" Analisi degli algoritmi di ricerca-->
<h2 class="section" id="sec257">B.3  Analisi degli algoritmi di ricerca</h2><!--SEC END --><p>Una <span class="c009">ricerca</span> è un algoritmo che, data una raccolta e un elemento, determina se l’elemento appartiene alla raccolta, restituendo di solito il suo indice.
<a id="hevea_default1715"></a></p><p>Il più semplice algoritmo di ricerca è una “ricerca lineare”, che attraversa gli elementi della raccolta nel loro ordine, fermandosi se trova quello che cerca. Nel caso peggiore, dovrà attraversare tutta la raccolta, quindi il tempo di esecuzione è lineare.
<a id="hevea_default1716"></a></p><p>L’operatore <span class="c003">in</span> delle sequenze usa una ricerca lineare, come pure i metodi delle stringhe <span class="c003">find</span> e <span class="c003">count</span>.
<a id="hevea_default1717"></a></p><p>Se gli elementi della sequenza sono ordinati, potete usare una <span class="c009">ricerca binaria</span>, che appartiene a <span class="c008">O</span>(log<span class="c008">n</span>). È simile all’algoritmo che usate per cercare una voce quando consultate un vocabolario. Invece di partire dall’inizio e controllare ogni voce nell’ordine, cominciate con un elemento nel mezzo e controllate se quello che cercate viene prima o dopo. Se viene prima, cercate nella prima metà della sequenza, altrimenti nella seconda metà. In ogni caso, dimezzate il numero di elementi rimanenti.
<a id="hevea_default1718"></a></p><p>Se una sequenza ha 1.000.000 di elementi, ci vorranno al massimo una ventina di passaggi per trovare la parola o concludere che non esiste. Quindi è circa 50.000 volte più veloce di una ricerca lineare.</p><p>La ricerca binaria può essere molto più veloce di quella lineare, ma richiede che la sequenza sia ordinata, il che può comportare del lavoro supplementare.</p><p>Esiste un’altra struttura di dati, chiamata <span class="c009">tabella hash</span>, che è ancora più veloce—è in grado di effettuare una ricerca a tempo costante—e non richiede che gli elementi siano ordinati. I dizionari di Python sono implementati usando tabelle hash, e questo è il motivo per cui la maggior parte delle operazioni sui dizionari, incluso l’operatore <span class="c003">in</span>, sono a tempo costante.</p>
<!--TOC section id="sec258" Tabelle hash-->
<h2 class="section" id="sec258">B.4  Tabelle hash</h2><!--SEC END --><p>
<a id="hashtable"></a></p><p>Per spiegare come funzionano le tabelle hash e perché le loro prestazioni sono così buone, inizierò con un’implementazione semplice di una mappatura e la migliorerò gradualmente fino a farla diventare una tabella hash.
<a id="hevea_default1719"></a></p><p>Per illustrare questa implementazione userò Python, ma in pratica non scriverete mai codice del genere in Python: userete semplicemente un dizionario! Pertanto, per il resto di questo capitolo immaginate che i dizionari non esistano, e di voler implementare una struttura di dati che fa corrispondere delle chiavi a dei valori. Le operazioni che bisogna implementare sono:</p><dl class="description"><dt class="dt-description"><span class="c009"><span class="c003">add(k, v)</span>:</span></dt><dd class="dd-description"> Aggiunge un nuovo elemento che fa corrispondere la chiave <span class="c003">k</span> al valore <span class="c003">v</span>. Con un dizionario Python, <span class="c003">d</span>, questa operazione si scrive <span class="c003">d[k] = v</span>.</dd><dt class="dt-description"><span class="c009"><span class="c003">get(k)</span>:</span></dt><dd class="dd-description"> Cerca e restituisce il valore corrispondente alla chiave <span class="c003">k</span>. Con un dizionario Python, <span class="c003">d</span>, questa operazione si scrive <span class="c003">d[k]</span> oppure <span class="c003">d.get(k)</span>.</dd></dl><p>Per ora, supponiamo che ogni chiave compaia solo una volta. L’implementazione più semplice di questa interfaccia usa una lista di tuple, dove ogni tupla è una coppia chiave-valore.
<a id="hevea_default1720"></a></p><pre class="verbatim">class MappaLineare:

    def __init__(self):
        self.items = []

    def add(self, k, v):
        self.items.append((k, v))

    def get(self, k):
        for chiave, valore in self.items:
            if chiave == k:
                return valore
        raise KeyError
</pre><p><span class="c003">add</span> accoda una tupla chiave-valore alla lista di elementi, operazione che è a tempo costante.</p><p><span class="c003">get</span> usa un ciclo <span class="c003">for</span> per ricercare nella lista: se trova la chiave target restituisce il corrispondente valore, altrimenti solleva un <span class="c003">KeyError</span>. Quindi <span class="c003">get</span> è lineare.
<a id="hevea_default1721"></a></p><p>Un’alternativa è mantenere la lista ordinata per chiavi. Allora, <span class="c003">get</span>
potrebbe usare una ricerca binaria, che appartiene a <span class="c008">O</span>(log<span class="c008">n</span>). Ma l’inserimento di un nuovo elemento in mezzo a una lista è lineare, quindi questa potrebbe non essere l’opzione migliore. Esistono altre strutture di dati in grado di implementare <span class="c003">add</span> e <span class="c003">get</span> in tempo logaritmico, ma non va ancora così bene come il tempo costante, quindi andiamo avanti.</p><p><a id="hevea_default1722"></a></p><p>Un modo di migliorare <span class="c003">MappaLineare</span> è di spezzare la lista di coppie chiave-valore in liste più piccole. Ecco un’implementazione chiamata
<span class="c003">MappaMigliore</span>, che è una lista di 100 MappeLineari. Vedremo in un istante che l’ordine di complessità di <span class="c003">get</span> è sempre lineare, ma <span class="c003">MappaMigliore</span> è un passo in direzione delle tabelle hash:
<a id="hevea_default1723"></a></p><pre class="verbatim">class MappaMigliore:

    def __init__(self, n=100):
        self.maps = []
        for i in range(n):
            self.maps.append(MappaLineare())

    def trova_mappa(self, k):
        indice = hash(k) % len(self.maps)
        return self.maps[indice]

    def add(self, k, v):
        m = self.trova_mappa(k)
        m.add(k, v)

    def get(self, k):
        m = self.trova_mappa(k)
        return m.get(k)
</pre><p><code>__init__</code> crea una lista di <span class="c003">n</span> <span class="c003">MappeLineari</span>.</p><p><code>trova_mappa</code> è usata da
<span class="c003">add</span> e <span class="c003">get</span> per capire in quale mappatura inserire il nuovo elemento o in quale mappatura ricercare.</p><p><code>trova_mappa</code> usa la funzione predefinita <span class="c003">hash</span>, che accetta pressoché qualunque oggetto Python e restituisce un intero. Un limite di questa implementazione è che funziona solo con chiavi a cui è applicabile un hash, e i tipi mutabili come liste e dizionari non lo sono.
<a id="hevea_default1724"></a></p><p>Gli oggetti hash-abili che vengono considerati equivalenti restituiscono lo stesso valore hash, ma l’inverso non è necessariamente vero: due oggetti con valori diversi possono restituire lo stesso valore hash.</p><p><code>trova_mappa</code> usa l’operatore modulo per inglobare i valori hash nell’intervallo da 0 a <span class="c003">len(self.maps)</span>, in modo che il risultato sia un indice valido per la lista. Naturalmente, ciò significa che molti valori hash diversi saranno inglobati nello stesso indice. Ma se la funzione hash distribuisce le cose abbastanza uniformemente (che è quello per cui le funzioni hash sono progettate), possiamo attenderci <span class="c008">n</span>/100 elementi per MappaLineare.</p><p>Siccome il tempo di esecuzione di <span class="c003">MappaLineare.get</span> è proporzionale al numero di elementi, possiamo attenderci che MappaMigliore sia circa 100 volte più veloce di MappaLineare. L’ordine di complessità è sempre lineare, ma il coefficiente dell’operazione dominante è più piccolo. Risultato discreto, ma non ancora come una tabella hash.</p><p>Ed ecco (finalmente) il punto cruciale che rende veloci le tabelle hash: se riuscite a mantenere limitata la lunghezza massima delle MappeLineari, <span class="c003">MappaLineare.get</span> diventa a tempo costante. Quello che bisogna fare è tenere conto del numero di elementi, e quando questo numero per MappaLineare eccede una soglia, ridimensionare la tabella hash aggiungendo altre MappeLineari.</p><p>Ecco un’implementazione di una tabella hash:
<a id="hevea_default1725"></a></p><pre class="verbatim">class MappaHash:

    def __init__(self):
        self.maps = MappaMigliore(2)
        self.num = 0

    def get(self, k):
        return self.maps.get(k)

    def add(self, k, v):
        if self.num == len(self.maps.maps):
            self.resize()

        self.maps.add(k, v)
        self.num += 1

    def ridimensiona(self):
        new_maps = MappaMigliore(self.num * 2)

        for m in self.maps.maps:
            for k, v in m.items:
                new_maps.add(k, v)

        self.maps = new_maps
</pre><p>Ogni <span class="c003">MappaHash</span> contiene una <span class="c003">MappaMigliore</span>; <code>__init__</code> comincia con sole 2 MappeLineari e inizializza <span class="c003">num</span>, che tiene il conto del numero di elementi.</p><p><span class="c003">get</span> rinvia semplicemente a <span class="c003">MappaMigliore</span>. Il lavoro vero si svolge in <span class="c003">add</span>, che controlla il numero di elementi e le dimensioni di
<span class="c003">MappaMigliore</span>: se sono uguali, il numero medio di elementi per MappaLineare è 1, quindi chiama <span class="c003">ridimensiona</span>.</p><p><span class="c003">ridimensiona</span> crea una nuova <span class="c003">MappaMigliore</span>, di capienza doppia della precedente, e ricalcola l’hash degli elementi dalla vecchia mappatura alla nuova.</p><p>Il ricalcolo è necessario perché cambiare il numero di MappeLineari cambia il denominatore dell’operatore modulo in <code>trova_mappa</code>. Ciò significa che alcuni oggetti che erano hashati nella stessa MappaLineare saranno separati (che era quello che volevamo, no?).
<a id="hevea_default1726"></a></p><p>Il ricalcolo dell’hash è lineare, quindi <span class="c003">ridimensiona</span> è lineare, il che può sembrare negativo dato che mi ripromettevo che <span class="c003">add</span> diventasse a tempo costante. Ma ricordate che non dobbiamo ridimensionare ogni volta, quindi <span class="c003">add</span> è di norma costante e solo qualche volta lineare. Il lavoro complessivo per eseguire <span class="c003">add</span> <span class="c008">n</span> volte è proporzionale a <span class="c008">n</span>, quindi il tempo medio di ogni <span class="c003">add</span> è costante!
<a id="hevea_default1727"></a></p><p>Per capire come funziona, supponiamo di iniziare con una tabella hash vuota e aggiungere una sequenza di elementi. Iniziamo con 2 MappeLineari, quindi le prime 2 aggiunte saranno veloci (nessun ridimensionamento richiesto). Diciamo che richiedono una unità lavoro ciascuna. L’aggiunta successiva richiede il ridimensionamento, e dobbiamo ricalcolare l’hash dei primi due elementi (diciamo 2 unità lavoro in più), quindi aggiungere il terzo elemento (1 altra unità). Aggiungere l’elemento successivo costa 1 unità, e in totale fanno 6 unità lavoro per 4 elementi.</p><p>Il successivo <span class="c003">add</span> costa 5 unità, ma i tre successivi solo 1 unità ciascuno, in totale 14 unità per 8 aggiunte.</p><p>L’aggiunta successiva costa 9 unità, ma poi possiamo aggiungerne altre 7 prima del ridimensionamento successivo, per un totale di 30 unità lavoro per le prime 16 aggiunte.</p><p>Dopo 32 aggiunte, il costo totale è 62 unità, e spero stiate cominciando ad avere chiaro lo schema. Dopo <span class="c008">n</span> aggiunte, con <span class="c008">n</span> potenza di 2, il costo totale è 2<span class="c008">n</span>−2 unità, per cui il lavoro medio per aggiunta è poco meno di 2 unità. Con <span class="c008">n</span> potenza di 2 si ha il caso migliore; per altri valori di <span class="c008">n</span> il lavoro medio è leggermente più alto, ma non in modo importante. La cosa importante è che sia
<span class="c008">O</span>(1).
<a id="hevea_default1728"></a></p><p>La Figura <a href="#fig.hash">B.1</a> illustra graficamente il funzionamento. Ogni quadrato è una unità di lavoro. Le colonne mostrano il lavoro totale per ogni aggiunta nell’ordine da sinistra verso destra: le prime due aggiunte costano 1 unità, la terza 3, ecc.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython_italian026.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure B.1: Costo delle aggiunte a una Tabella Hash.<a id="fig.hash"></a></td></tr>
</table></div>
<div class="center"><hr class="c019"></div></blockquote><p>Il lavoro supplementare di ricalcolo appare come una sequenza di torri sempre più alte e con spazi sempre più ampi tra due torri successive. Ora, se abbattete le torri, spalmando il costo del ridimensionamento su tutte le aggiunte, potete vedere graficamente che il costo del lavoro totale dopo <span class="c008">n</span> aggiunte è 2<span class="c008">n</span> − 2.</p><p>Una caratteristica importante di questo algoritmo è che quando ridimensioniamo la tabella hash, cresce geometricamente, cioè moltiplichiamo la dimensione per una costante. Se incrementaste le dimensioni aritmeticamente, aggiungendo ogni volta un numero fisso, il tempo medio per aggiunta sarebbe lineare.
<a id="hevea_default1729"></a></p><p>Potete scaricare la mia implementazione di MappaHash da
<a href="http://thinkpython2/code/Map.py"><span class="c003">http://thinkpython2/code/Map.py</span></a>, ma ricordate che non c’è alcuna buona ragione per usarla. Piuttosto, se dovete fare una mappatura, usate un dizionario di Python.</p>
<!--TOC section id="sec259" Glossario-->
<h2 class="section" id="sec259">B.5  Glossario</h2><!--SEC END --><dl class="description"><dt class="dt-description"><span class="c009">analisi degli algoritmi:</span></dt><dd class="dd-description"> Un modo di confrontare gli algoritmi in termini di tempo di esecuzione e/o requisiti di memoria.
<a id="hevea_default1730"></a></dd><dt class="dt-description"><span class="c009">modello di macchina:</span></dt><dd class="dd-description"> Rappresentazione semplificata di un computer usato per analizzare il comportamento degli algoritmi.
<a id="hevea_default1731"></a></dd><dt class="dt-description"><span class="c009">caso peggiore:</span></dt><dd class="dd-description"> L’input che, con riferimento ad un algoritmo, lo rende più lento nell’esecuzione o richiede più spazio di memoria.
<a id="hevea_default1732"></a></dd><dt class="dt-description"><span class="c009">operazione dominante:</span></dt><dd class="dd-description"> In un polinomio, il termine con il più alto esponente.
<a id="hevea_default1733"></a></dd><dt class="dt-description"><span class="c009">punto di intersezione:</span></dt><dd class="dd-description"> La dimensione del problema per cui due diversi algoritmi richiedono lo stesso tempo di esecuzione o lo stesso spazio di memoria.
<a id="hevea_default1734"></a></dd><dt class="dt-description"><span class="c009">ordine di complessità:</span></dt><dd class="dd-description"> Insieme di funzioni che, per gli scopi dell’analisi degli algoritmi, crescono in maniera equivalente. Per esempio, tutte le funzioni con incremento lineare appartengono allo stesso ordine di complessità.
<a id="hevea_default1735"></a></dd><dt class="dt-description"><span class="c009">Notazione O-grande:</span></dt><dd class="dd-description"> Notazione per rappresentare l’ordine di complessità;
ad esempio, <span class="c008">O</span>(<span class="c008">n</span>) rappresenta l’insieme delle funzioni con incremento lineare.
<a id="hevea_default1736"></a></dd><dt class="dt-description"><span class="c009">lineare:</span></dt><dd class="dd-description"> Un algoritmo il cui tempo di esecuzione è proporzionale alle dimensioni del problema, almeno per i problemi di grandi dimensioni.
<a id="hevea_default1737"></a></dd><dt class="dt-description"><span class="c009">quadratico:</span></dt><dd class="dd-description"> Un algoritmo il cui tempo di esecuzione è proporzionale a
<span class="c008">n</span><sup>2</sup>, dove <span class="c008">n</span> è una misura delle dimensioni del problema.
<a id="hevea_default1738"></a></dd><dt class="dt-description"><span class="c009">ricerca:</span></dt><dd class="dd-description"> Il problema di rintracciare un elemento in un insieme (come una lista o un dizionario) oppure stabilire che non è presente.
<a id="hevea_default1739"></a></dd><dt class="dt-description"><span class="c009">tabella hash:</span></dt><dd class="dd-description"> Struttura di dati che rappresenta una raccolta di coppie chiave-valore e ne esegue la ricerca a tempo costante.
<a id="hevea_default1740"></a></dd></dl><!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note2" href="#text2">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ma se vi capita una domanda come questa in un’intervista, ritengo che una risposta migliore sarebbe: “Il modo più rapido di ordinare un milione di interi è usare una qualsiasi funzione di ordinamento di cui dispone il linguaggio di programmazione che uso. Il suo rendimento sarà abbastanza buono per la maggior parte delle applicazioni, ma se proprio capitasse che la mia fosse troppo lenta, userei un profiler per controllare dove viene impiegato il tempo. Se risultasse che un algoritmo di ordinamento più rapido avrebbe un impatto significativo sulle prestazioni, cercherei una buona implementazione del radix sort”.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec260" Index-->
<h1 class="chapter" id="sec260">Index</h1><!--SEC END --><p></p><table class="c001 cellpading0"><tr><td class="c017"><ul class="indexenv"><li class="li-indexenv">
Ackermann, funzione di, <a href="#hevea_default454">6.11</a>, <a href="#hevea_default927">11.10</a>
</li><li class="li-indexenv">AttributeError, <a href="#hevea_default1291">15.7</a>, <a href="#hevea_default1654">A.2.3</a>
</li><li class="li-indexenv">Austin, Jane, <a href="#hevea_default1084">13.3</a>
</li><li class="li-indexenv">abs, funzione, <a href="#hevea_default397">6.1</a>
</li><li class="li-indexenv">accesso, <a href="#hevea_default657">10.2</a>
</li><li class="li-indexenv">accumulatore, <a href="#hevea_default787">10.14</a>
<ul class="indexenv"><li class="li-indexenv">
istogramma, <a href="#hevea_default1085">13.3</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default721">10.7</a>
</li><li class="li-indexenv">somma, <a href="#hevea_default717">10.7</a>
</li><li class="li-indexenv">stringa, <a href="#hevea_default1478">18.5</a>
</li></ul>
</li><li class="li-indexenv">add, metodo, <a href="#hevea_default1391">17.7</a>
</li><li class="li-indexenv">addizione<ul class="indexenv"><li class="li-indexenv">
con riporto, <a href="#hevea_default486">7.6</a>, <a href="#hevea_default1321">16.2</a>, <a href="#hevea_default1332">16.4</a>
</li></ul>
</li><li class="li-indexenv">aggiornamento, <a href="#hevea_default464">7.2</a>, <a href="#hevea_default482">7.5</a>, <a href="#hevea_default490">7.8</a>
<ul class="indexenv"><li class="li-indexenv">
di database, <a href="#hevea_default1173">14.6</a>
</li><li class="li-indexenv">elemento, <a href="#hevea_default683">10.3</a>
</li><li class="li-indexenv">istogramma, <a href="#hevea_default1087">13.3</a>
</li><li class="li-indexenv">operatore di, <a href="#hevea_default713">10.7</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default701">10.5</a>
</li><li class="li-indexenv">variabile globale, <a href="#hevea_default889">11.7</a>
</li></ul>
</li><li class="li-indexenv">alfabetico, <a href="#hevea_default524">8.3</a>, <a href="#hevea_default614">9.2</a>
</li><li class="li-indexenv">alfabeto, <a href="#hevea_default295">4.12</a>
</li><li class="li-indexenv">algoritmo, <a href="#hevea_default12">1.1</a>, <a href="#hevea_default485">7.6</a>, <a href="#hevea_default496">7.8</a>, <a href="#hevea_default1097">13.7</a>, <a href="#hevea_default1681">B</a>
<ul class="indexenv"><li class="li-indexenv">
md5, <a href="#hevea_default1235">14.12</a>
</li><li class="li-indexenv">radice quadrata, <a href="#hevea_default497">7.9</a>
</li></ul>
</li><li class="li-indexenv">alias, <a href="#hevea_default751">10.10</a>, <a href="#hevea_default759">10.11</a>, <a href="#hevea_default800">10.14</a>, <a href="#hevea_default1260">15.2</a>, <a href="#hevea_default1271">15.6</a>, <a href="#hevea_default1435">17.13</a>
<ul class="indexenv"><li class="li-indexenv">
copiare per evitare, <a href="#hevea_default780">10.13</a>
</li></ul>
</li><li class="li-indexenv">all, funzione, <a href="#hevea_default1571">19.4</a>
</li><li class="li-indexenv">ambiguità, <a href="#hevea_default53">1.6</a>
</li><li class="li-indexenv">anagramma, <a href="#hevea_default803">10.15</a>
</li><li class="li-indexenv">anagramma, insieme, <a href="#hevea_default1051">12.10</a>, <a href="#hevea_default1230">14.12</a>
</li><li class="li-indexenv">analisi degli algoritmi, <a href="#hevea_default1682">B</a>, <a href="#hevea_default1730">B.5</a>
</li><li class="li-indexenv">analisi delle primitive, <a href="#hevea_default1702">B.2</a>
</li><li class="li-indexenv">and, operatore, <a href="#hevea_default317">5.3</a>
</li><li class="li-indexenv">any, funzione, <a href="#hevea_default1566">19.4</a>
</li><li class="li-indexenv">apici, <a href="#hevea_default21">1.3</a>, <a href="#hevea_default45">1.5</a>, <a href="#hevea_default531">8.4</a>
</li><li class="li-indexenv">appartenenza<ul class="indexenv"><li class="li-indexenv">
dizionario, <a href="#hevea_default837">11.1</a>
</li><li class="li-indexenv">insieme di, <a href="#hevea_default924">11.10</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default672">10.2</a>
</li><li class="li-indexenv">ricerca binaria, <a href="#hevea_default815">10.15</a>, <a href="#hevea_default817">10.15</a>
</li></ul>
</li><li class="li-indexenv">append, metodo, <a href="#hevea_default704">10.6</a>, <a href="#hevea_default771">10.12</a>, <a href="#hevea_default811">10.15</a>, <a href="#hevea_default1474">18.4</a>, <a href="#hevea_default1485">18.6</a>
</li><li class="li-indexenv">arco, funzione, <a href="#hevea_default261">4.3</a>
</li><li class="li-indexenv">argomento, <a href="#hevea_default149">3.1</a>, <a href="#hevea_default179">3.4</a>, <a href="#hevea_default193">3.7</a>, <a href="#hevea_default198">3.7</a>, <a href="#hevea_default229">3.13</a>, <a href="#hevea_default766">10.12</a>
<ul class="indexenv"><li class="li-indexenv">
con nome, <a href="#hevea_default266">4.5</a>, <a href="#hevea_default284">4.11</a>, <a href="#hevea_default1602">19.9</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default767">10.12</a>
</li><li class="li-indexenv">opzionale, <a href="#hevea_default560">8.8</a>, <a href="#hevea_default588">8.12</a>, <a href="#hevea_default592">8.13</a>, <a href="#hevea_default743">10.9</a>, <a href="#hevea_default867">11.4</a>, <a href="#hevea_default1549">19.1</a>
</li><li class="li-indexenv">posizionale, <a href="#hevea_default1375">17.3</a>, <a href="#hevea_default1423">17.12</a>, <a href="#hevea_default1601">19.9</a>
</li><li class="li-indexenv">raccolta, <a href="#hevea_default981">12.4</a>
</li><li class="li-indexenv">spacchettamento, <a href="#hevea_default983">12.4</a>
</li><li class="li-indexenv">tupla di lunghezza variabile, <a href="#hevea_default978">12.4</a>
</li></ul>
</li><li class="li-indexenv">aritmetico<ul class="indexenv"><li class="li-indexenv">
operatore, <a href="#hevea_default28">1.4</a>
</li></ul>
</li><li class="li-indexenv">assegnazione, <a href="#hevea_default126">2.9</a>, <a href="#hevea_default459">7.1</a>, <a href="#hevea_default655">10.1</a>
<ul class="indexenv"><li class="li-indexenv">
elemento, <a href="#hevea_default542">8.5</a>, <a href="#hevea_default666">10.2</a>, <a href="#hevea_default956">12.1</a>
</li><li class="li-indexenv">potenziata, <a href="#hevea_default715">10.7</a>, <a href="#hevea_default788">10.14</a>
</li><li class="li-indexenv">tupla, <a href="#hevea_default958">12.2</a>, <a href="#hevea_default972">12.3</a>, <a href="#hevea_default998">12.5</a>, <a href="#hevea_default1041">12.9</a>
</li></ul>
</li><li class="li-indexenv">assegnazione, istruzione di, <a href="#hevea_default91">2.1</a>
</li><li class="li-indexenv">assert, istruzione, <a href="#hevea_default1341">16.5</a>, <a href="#hevea_default1349">16.6</a>
</li><li class="li-indexenv">attraversamento, <a href="#hevea_default518">8.3</a>, <a href="#hevea_default547">8.6</a>, <a href="#hevea_default568">8.11</a>, <a href="#hevea_default582">8.12</a>, <a href="#hevea_default617">9.3</a>, <a href="#hevea_default621">9.3</a>, <a href="#hevea_default720">10.7</a>, <a href="#hevea_default789">10.14</a>, <a href="#hevea_default847">11.2</a>, <a href="#hevea_default853">11.3</a>, <a href="#hevea_default996">12.5</a>, <a href="#hevea_default1001">12.5</a>, <a href="#hevea_default1086">13.3</a>
<ul class="indexenv"><li class="li-indexenv">
dizionario, <a href="#hevea_default1016">12.6</a>, <a href="#hevea_default1409">17.10</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default676">10.3</a>
</li></ul>
</li><li class="li-indexenv">attributo, <a href="#hevea_default1298">15.7</a>, <a href="#hevea_default1417">17.11</a>
<ul class="indexenv"><li class="li-indexenv">
__dict__, <a href="#hevea_default1408">17.10</a>
</li><li class="li-indexenv">di classe, <a href="#hevea_default1452">18.2</a>, <a href="#hevea_default1527">18.11</a>
</li><li class="li-indexenv">di istanza, <a href="#hevea_default1255">15.2</a>, <a href="#hevea_default1454">18.2</a>, <a href="#hevea_default1529">18.11</a>
</li><li class="li-indexenv">inizializzazione, <a href="#hevea_default1404">17.10</a>
</li><li class="li-indexenv">istanza, <a href="#hevea_default1306">15.8</a>
</li></ul>
</li><li class="li-indexenv">avviare Python, <a href="#hevea_default13">1.2</a>
<br>
<br>
</li><li class="li-indexenv">Big-Oh notation, <a href="#hevea_default1736">B.5</a>
</li><li class="li-indexenv">bella copia, <a href="#hevea_default898">11.8</a>
</li><li class="li-indexenv">benchmarking, <a href="#hevea_default1107">13.9</a>, <a href="#hevea_default1118">13.11</a>
</li><li class="li-indexenv">bifronte, parola, <a href="#hevea_default821">10.15</a>
</li><li class="li-indexenv">bisect, modulo, <a href="#hevea_default819">10.15</a>
</li><li class="li-indexenv">bitwise, operatore, <a href="#hevea_default29">1.4</a>
</li><li class="li-indexenv">blocco, <a href="#hevea_default1635">A.2.2</a>
</li><li class="li-indexenv">bool, tipo, <a href="#hevea_default311">5.2</a>
</li><li class="li-indexenv">booleano, operatore, <a href="#hevea_default563">8.9</a>
</li><li class="li-indexenv">break, istruzione, <a href="#hevea_default478">7.4</a>
</li><li class="li-indexenv">bubble sort, <a href="#hevea_default1685">B</a>
</li><li class="li-indexenv">bug, <a href="#hevea_default60">1.7</a>, <a href="#hevea_default84">1.8</a>
<ul class="indexenv"><li class="li-indexenv">
il peggiore, <a href="#hevea_default1432">17.13</a>
</li></ul>
</li><li class="li-indexenv">bytes, oggetto, <a href="#hevea_default1174">14.6</a>, <a href="#hevea_default1225">14.11</a>
<br>
<br>
</li><li class="li-indexenv">Canguro, classe, <a href="#hevea_default1433">17.13</a>
</li><li class="li-indexenv">Car Talk, <a href="#hevea_default639">9.7</a>, <a href="#hevea_default642">9.7</a>, <a href="#hevea_default646">9.7</a>, <a href="#hevea_default932">11.10</a>, <a href="#hevea_default1055">12.10</a>
</li><li class="li-indexenv">Carta, classe, <a href="#hevea_default1447">18.1</a>
</li><li class="li-indexenv">Creative Commons, <a href="#hevea_default8">0</a>
</li><li class="li-indexenv">cadenza di corsa, <a href="#hevea_default88">1.9</a>, <a href="#hevea_default145">2.10</a>, <a href="#hevea_default1351">16.7</a>
</li><li class="li-indexenv">calcolatrice, <a href="#hevea_default87">1.9</a>, <a href="#hevea_default144">2.10</a>
</li><li class="li-indexenv">cancellare, elementi di lista, <a href="#hevea_default727">10.8</a>
</li><li class="li-indexenv">carattere, <a href="#hevea_default504">8.1</a>
</li><li class="li-indexenv">carte da gioco, <a href="#hevea_default1438">18</a>
</li><li class="li-indexenv">cartella, <a href="#hevea_default1145">14.4</a>
</li><li class="li-indexenv">caso<ul class="indexenv"><li class="li-indexenv">
medio, <a href="#hevea_default1690">B</a>
</li><li class="li-indexenv">particolare, <a href="#hevea_default632">9.5</a>, <a href="#hevea_default638">9.6</a>, <a href="#hevea_default1325">16.3</a>
</li><li class="li-indexenv">peggiore, <a href="#hevea_default1689">B</a>
</li></ul>
</li><li class="li-indexenv">caso base, <a href="#hevea_default351">5.9</a>, <a href="#hevea_default384">5.13</a>
</li><li class="li-indexenv">caso di prova minimo, <a href="#hevea_default1664">A.2.4</a>
</li><li class="li-indexenv">caso peggiore, <a href="#hevea_default1732">B.5</a>
</li><li class="li-indexenv">cerchio, funzione, <a href="#hevea_default259">4.3</a>
</li><li class="li-indexenv">checksum, <a href="#hevea_default1197">14.8</a>, <a href="#hevea_default1236">14.12</a>
</li><li class="li-indexenv">chiamata, grafico di, <a href="#hevea_default915">11.9</a>
</li><li class="li-indexenv">chiave, <a href="#hevea_default825">11.1</a>, <a href="#hevea_default906">11.9</a>
</li><li class="li-indexenv">chiave-valore, coppia, <a href="#hevea_default826">11.1</a>, <a href="#hevea_default904">11.9</a>, <a href="#hevea_default1010">12.6</a>
</li><li class="li-indexenv">choice, funzione, <a href="#hevea_default1080">13.2</a>
</li><li class="li-indexenv">cicli e contatori, <a href="#hevea_default552">8.7</a>
</li><li class="li-indexenv">ciclo, <a href="#hevea_default256">4.2</a>, <a href="#hevea_default281">4.11</a>, <a href="#hevea_default474">7.3</a>, <a href="#hevea_default999">12.5</a>
<ul class="indexenv"><li class="li-indexenv">
attraversamento, <a href="#hevea_default519">8.3</a>
</li><li class="li-indexenv">con dizionario, <a href="#hevea_default852">11.3</a>
</li><li class="li-indexenv">con indici, <a href="#hevea_default624">9.4</a>, <a href="#hevea_default680">10.3</a>
</li><li class="li-indexenv">con stringhe, <a href="#hevea_default553">8.7</a>
</li><li class="li-indexenv">condizione, <a href="#hevea_default1638">A.2.2</a>
</li><li class="li-indexenv">for, <a href="#hevea_default254">4.2</a>, <a href="#hevea_default347">5.8</a>, <a href="#hevea_default521">8.3</a>, <a href="#hevea_default678">10.3</a>
</li><li class="li-indexenv">infinito, <a href="#hevea_default476">7.3</a>, <a href="#hevea_default495">7.8</a>, <a href="#hevea_default1633">A.2.2</a>, <a href="#hevea_default1636">A.2.2</a>
</li><li class="li-indexenv">nidificato, <a href="#hevea_default1471">18.4</a>
</li><li class="li-indexenv">while, <a href="#hevea_default470">7.3</a>
</li></ul>
</li><li class="li-indexenv">classe, <a href="#hevea_default37">1.5</a>, <a href="#hevea_default1243">15.1</a>, <a href="#hevea_default1301">15.8</a>
<ul class="indexenv"><li class="li-indexenv">
attributo di, <a href="#hevea_default1451">18.2</a>, <a href="#hevea_default1526">18.11</a>
</li><li class="li-indexenv">Canguro, <a href="#hevea_default1434">17.13</a>
</li><li class="li-indexenv">Carta, <a href="#hevea_default1448">18.1</a>
</li><li class="li-indexenv">definizione di, <a href="#hevea_default1245">15.1</a>
</li><li class="li-indexenv">figlia, <a href="#hevea_default1502">18.7</a>, <a href="#hevea_default1533">18.11</a>
</li><li class="li-indexenv">Mano, <a href="#hevea_default1498">18.7</a>
</li><li class="li-indexenv">Mazzo, <a href="#hevea_default1473">18.4</a>
</li><li class="li-indexenv">madre, <a href="#hevea_default1500">18.7</a>, <a href="#hevea_default1532">18.11</a>
</li><li class="li-indexenv">Punto, <a href="#hevea_default1248">15.1</a>, <a href="#hevea_default1384">17.5</a>
</li><li class="li-indexenv">Rettangolo, <a href="#hevea_default1263">15.3</a>
</li><li class="li-indexenv">Tempo, <a href="#hevea_default1314">16.1</a>
</li></ul>
</li><li class="li-indexenv">classe, oggetto, <a href="#hevea_default1596">19.8</a>
</li><li class="li-indexenv">close, metodo, <a href="#hevea_default1132">14.2</a>, <a href="#hevea_default1177">14.6</a>, <a href="#hevea_default1194">14.8</a>
</li><li class="li-indexenv">__lt__, metodo, <a href="#hevea_default1462">18.3</a>
</li><li class="li-indexenv">codice morto, <a href="#hevea_default394">6.1</a>, <a href="#hevea_default448">6.10</a>, <a href="#hevea_default1662">A.2.4</a>
</li><li class="li-indexenv">codificare, <a href="#hevea_default1443">18.1</a>, <a href="#hevea_default1525">18.11</a>
</li><li class="li-indexenv">coefficiente dominante, <a href="#hevea_default1694">B.1</a>
</li><li class="li-indexenv">coerenza, controllo di, <a href="#hevea_default897">11.8</a>, <a href="#hevea_default1334">16.4</a>
</li><li class="li-indexenv">collaboratori, <a href="#hevea_default9">0</a>
</li><li class="li-indexenv">collections, <a href="#hevea_default1582">19.6</a>, <a href="#hevea_default1586">19.7</a>, <a href="#hevea_default1594">19.8</a>
</li><li class="li-indexenv">comando Unix<ul class="indexenv"><li class="li-indexenv">
ls, <a href="#hevea_default1187">14.8</a>
</li></ul>
</li><li class="li-indexenv">commento, <a href="#hevea_default110">2.7</a>, <a href="#hevea_default139">2.9</a>
</li><li class="li-indexenv">commutatività, <a href="#hevea_default109">2.6</a>, <a href="#hevea_default1397">17.8</a>
</li><li class="li-indexenv">compara, funzione, <a href="#hevea_default399">6.1</a>
</li><li class="li-indexenv">comparison sort, <a href="#hevea_default1713">B.2</a>
</li><li class="li-indexenv">compleanno, <a href="#hevea_default1354">16.7</a>
</li><li class="li-indexenv">compleanno, paradosso del, <a href="#hevea_default806">10.15</a>
</li><li class="li-indexenv">complessità<ul class="indexenv"><li class="li-indexenv">
esponenziale, <a href="#hevea_default1701">B.1</a>
</li><li class="li-indexenv">lineare, <a href="#hevea_default1697">B.1</a>
</li><li class="li-indexenv">logaritmica, <a href="#hevea_default1700">B.1</a>
</li><li class="li-indexenv">ordine di, <a href="#hevea_default1691">B.1</a>
</li><li class="li-indexenv">quadratica, <a href="#hevea_default1698">B.1</a>
</li></ul>
</li><li class="li-indexenv">complessità, ordine di, <a href="#hevea_default1735">B.5</a>
</li><li class="li-indexenv">composizione, <a href="#hevea_default171">3.3</a>, <a href="#hevea_default196">3.7</a>, <a href="#hevea_default242">3.13</a>, <a href="#hevea_default409">6.3</a>, <a href="#hevea_default1470">18.4</a>
</li><li class="li-indexenv">concatenamento, <a href="#hevea_default108">2.6</a>, <a href="#hevea_default138">2.9</a>, <a href="#hevea_default201">3.8</a>, <a href="#hevea_default523">8.3</a>, <a href="#hevea_default544">8.5</a>, <a href="#hevea_default747">10.9</a>
<ul class="indexenv"><li class="li-indexenv">
lista, <a href="#hevea_default687">10.4</a>, <a href="#hevea_default774">10.12</a>, <a href="#hevea_default814">10.15</a>
</li></ul>
</li><li class="li-indexenv">condizionale, espressione, <a href="#hevea_default1542">19.1</a>, <a href="#hevea_default1604">19.10</a>
</li><li class="li-indexenv">condizionale, istruzione, <a href="#hevea_default1550">19.1</a>
</li><li class="li-indexenv">condizione, <a href="#hevea_default327">5.4</a>, <a href="#hevea_default378">5.13</a>, <a href="#hevea_default473">7.3</a>, <a href="#hevea_default1637">A.2.2</a>
<ul class="indexenv"><li class="li-indexenv">
di guardia, <a href="#hevea_default442">6.8</a>, <a href="#hevea_default452">6.10</a>
</li><li class="li-indexenv">in serie, <a href="#hevea_default336">5.6</a>, <a href="#hevea_default381">5.13</a>
</li><li class="li-indexenv">nidificata, <a href="#hevea_default339">5.7</a>, <a href="#hevea_default382">5.13</a>
</li></ul>
</li><li class="li-indexenv">confronto<ul class="indexenv"><li class="li-indexenv">
stringa, <a href="#hevea_default566">8.10</a>
</li><li class="li-indexenv">tupla, <a href="#hevea_default1465">18.3</a>
</li></ul>
</li><li class="li-indexenv">confronto di algoritmi, <a href="#hevea_default1687">B</a>
</li><li class="li-indexenv">confronto, operatore di, <a href="#hevea_default313">5.2</a>
</li><li class="li-indexenv">congettura di Collatz, <a href="#hevea_default477">7.3</a>
</li><li class="li-indexenv">congruenza, controllo di, <a href="#hevea_default896">11.8</a>
</li><li class="li-indexenv">contachilometri, <a href="#hevea_default644">9.7</a>
</li><li class="li-indexenv">contatore, <a href="#hevea_default550">8.7</a>, <a href="#hevea_default585">8.12</a>, <a href="#hevea_default843">11.2</a>, <a href="#hevea_default893">11.7</a>, <a href="#hevea_default1579">19.6</a>
</li><li class="li-indexenv">contatori e cicli, <a href="#hevea_default551">8.7</a>
</li><li class="li-indexenv">conteggio, <a href="#hevea_default1199">14.9</a>
</li><li class="li-indexenv">contenuto, oggetto, <a href="#hevea_default1436">17.13</a>
</li><li class="li-indexenv">controllo dei tipi, <a href="#hevea_default432">6.8</a>
</li><li class="li-indexenv">controllo errore, <a href="#hevea_default433">6.8</a>
</li><li class="li-indexenv">conversione<ul class="indexenv"><li class="li-indexenv">
di tipo, <a href="#hevea_default151">3.1</a>
</li></ul>
</li><li class="li-indexenv">copia<ul class="indexenv"><li class="li-indexenv">
di un oggetto, <a href="#hevea_default1272">15.6</a>
</li><li class="li-indexenv">per evitare alias, <a href="#hevea_default781">10.13</a>
</li><li class="li-indexenv">profonda, <a href="#hevea_default1286">15.6</a>, <a href="#hevea_default1310">15.8</a>
</li><li class="li-indexenv">shallow, <a href="#hevea_default1284">15.6</a>, <a href="#hevea_default1309">15.8</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default532">8.4</a>, <a href="#hevea_default698">10.5</a>
</li></ul>
</li><li class="li-indexenv">copy, modulo, <a href="#hevea_default1274">15.6</a>
</li><li class="li-indexenv">corpo, <a href="#hevea_default182">3.4</a>, <a href="#hevea_default226">3.13</a>, <a href="#hevea_default475">7.3</a>
</li><li class="li-indexenv">corrispondenza, <a href="#hevea_default1445">18.1</a>
</li><li class="li-indexenv">costo medio, <a href="#hevea_default1728">B.4</a>
</li><li class="li-indexenv">count, metodo, <a href="#hevea_default593">8.13</a>
</li><li class="li-indexenv">criptare, <a href="#hevea_default1444">18.1</a>
</li><li class="li-indexenv">cruciverba, <a href="#hevea_default601">9.1</a>
</li><li class="li-indexenv">cumulativa, somma, <a href="#hevea_default802">10.15</a>
</li><li class="li-indexenv">curva di Koch, <a href="#hevea_default389">5.14</a>
<br>
<br>
</li><li class="li-indexenv">Dijkstra, Edsger, <a href="#hevea_default634">9.5</a>
</li><li class="li-indexenv">Doyle, Arthur Conan, <a href="#hevea_default220">3.12</a>
</li><li class="li-indexenv">database, <a href="#hevea_default1166">14.6</a>, <a href="#hevea_default1224">14.11</a>
</li><li class="li-indexenv">database, oggetto, <a href="#hevea_default1171">14.6</a>
</li><li class="li-indexenv">datetime, modulo, <a href="#hevea_default1352">16.7</a>
</li><li class="li-indexenv">dbm, modulo, <a href="#hevea_default1167">14.6</a>
</li><li class="li-indexenv">debug, <a href="#hevea_default58">1.7</a>, <a href="#hevea_default59">1.7</a>, <a href="#hevea_default85">1.8</a>, <a href="#hevea_default111">2.8</a>, <a href="#hevea_default217">3.12</a>, <a href="#hevea_default276">4.10</a>, <a href="#hevea_default366">5.12</a>, <a href="#hevea_default443">6.9</a>, <a href="#hevea_default567">8.11</a>, <a href="#hevea_default629">9.5</a>, <a href="#hevea_default777">10.13</a>, <a href="#hevea_default895">11.8</a>, <a href="#hevea_default1033">12.8</a>, <a href="#hevea_default1110">13.10</a>, <a href="#hevea_default1208">14.10</a>, <a href="#hevea_default1289">15.7</a>, <a href="#hevea_default1337">16.5</a>, <a href="#hevea_default1402">17.10</a>, <a href="#hevea_default1511">18.9</a>, <a href="#hevea_default1558">19.2</a>, <a href="#hevea_default1609">A</a>
<ul class="indexenv"><li class="li-indexenv">
binario, <a href="#hevea_default488">7.7</a>
</li><li class="li-indexenv">con la papera di gomma, <a href="#hevea_default1119">13.11</a>
</li><li class="li-indexenv">risposta emotiva, <a href="#hevea_default61">1.7</a>, <a href="#hevea_default1676">A.3.4</a>
</li><li class="li-indexenv">sperimentale, <a href="#hevea_default218">3.12</a>, <a href="#hevea_default1112">13.10</a>
</li><li class="li-indexenv">superstizione, <a href="#hevea_default1678">A.3.4</a>
</li></ul>
</li><li class="li-indexenv">debugger (pdb), <a href="#hevea_default1658">A.2.3</a>
</li><li class="li-indexenv">decremento, <a href="#hevea_default468">7.2</a>, <a href="#hevea_default493">7.8</a>
</li><li class="li-indexenv">deepcopy, funzione, <a href="#hevea_default1287">15.6</a>
</li><li class="li-indexenv">def, parola chiave, <a href="#hevea_default177">3.4</a>
</li><li class="li-indexenv">default, valore di, <a href="#hevea_default1116">13.11</a>
</li><li class="li-indexenv">defaultdict, <a href="#hevea_default1584">19.7</a>
</li><li class="li-indexenv">definizione<ul class="indexenv"><li class="li-indexenv">
circolare, <a href="#hevea_default419">6.5</a>
</li><li class="li-indexenv">di classe, <a href="#hevea_default1246">15.1</a>
</li><li class="li-indexenv">di funzione, <a href="#hevea_default176">3.4</a>
</li><li class="li-indexenv">ricorsiva, <a href="#hevea_default422">6.5</a>, <a href="#hevea_default1058">12.10</a>
</li></ul>
</li><li class="li-indexenv">del, operatore, <a href="#hevea_default730">10.8</a>
</li><li class="li-indexenv">delimitatore, <a href="#hevea_default744">10.9</a>, <a href="#hevea_default801">10.14</a>
</li><li class="li-indexenv">deterministico, <a href="#hevea_default1072">13.2</a>, <a href="#hevea_default1114">13.11</a>
</li><li class="li-indexenv">diagramma<ul class="indexenv"><li class="li-indexenv">
di classe, <a href="#hevea_default1509">18.8</a>, <a href="#hevea_default1537">18.11</a>
</li><li class="li-indexenv">di oggetto, <a href="#hevea_default1258">15.2</a>, <a href="#hevea_default1265">15.3</a>, <a href="#hevea_default1282">15.6</a>, <a href="#hevea_default1311">15.8</a>, <a href="#hevea_default1316">16.1</a>, <a href="#hevea_default1457">18.2</a>
</li><li class="li-indexenv">di stack, <a href="#hevea_default205">3.9</a>, <a href="#hevea_default244">3.13</a>, <a href="#hevea_default292">4.12</a>, <a href="#hevea_default348">5.9</a>, <a href="#hevea_default423">6.5</a>, <a href="#hevea_default453">6.11</a>, <a href="#hevea_default770">10.12</a>
</li><li class="li-indexenv">di stato, <a href="#hevea_default92">2.1</a>, <a href="#hevea_default127">2.9</a>, <a href="#hevea_default462">7.1</a>, <a href="#hevea_default574">8.11</a>, <a href="#hevea_default664">10.2</a>, <a href="#hevea_default754">10.10</a>, <a href="#hevea_default761">10.11</a>, <a href="#hevea_default870">11.5</a>, <a href="#hevea_default1021">12.6</a>, <a href="#hevea_default1257">15.2</a>, <a href="#hevea_default1264">15.3</a>, <a href="#hevea_default1281">15.6</a>, <a href="#hevea_default1315">16.1</a>, <a href="#hevea_default1456">18.2</a>
</li><li class="li-indexenv">grafico di chiamata, <a href="#hevea_default916">11.9</a>
</li></ul>
</li><li class="li-indexenv">dichiarazione, <a href="#hevea_default888">11.7</a>, <a href="#hevea_default922">11.9</a>
</li><li class="li-indexenv">__dict__ attributo, <a href="#hevea_default1407">17.10</a>
</li><li class="li-indexenv">dict, funzione, <a href="#hevea_default829">11.1</a>
</li><li class="li-indexenv">diff, <a href="#hevea_default1238">14.12</a>
</li><li class="li-indexenv">dipendenza, relazione, <a href="#hevea_default1536">18.11</a>
</li><li class="li-indexenv">directory, <a href="#hevea_default1144">14.4</a>, <a href="#hevea_default1219">14.11</a>
<ul class="indexenv"><li class="li-indexenv">
di lavoro, <a href="#hevea_default1151">14.4</a>
</li><li class="li-indexenv">esplorazione, <a href="#hevea_default1156">14.4</a>
</li></ul>
</li><li class="li-indexenv">divisibilità, <a href="#hevea_default303">5.1</a>
</li><li class="li-indexenv">divisione<ul class="indexenv"><li class="li-indexenv">
decimale, <a href="#hevea_default300">5.1</a>
</li><li class="li-indexenv">intera, <a href="#hevea_default299">5.1</a>, <a href="#hevea_default372">5.12</a>, <a href="#hevea_default373">5.13</a>
</li></ul>
</li><li class="li-indexenv">divmod, <a href="#hevea_default970">12.3</a>, <a href="#hevea_default1333">16.4</a>
</li><li class="li-indexenv">dizionario, <a href="#hevea_default823">11.1</a>, <a href="#hevea_default903">11.9</a>, <a href="#hevea_default1007">12.6</a>, <a href="#hevea_default1653">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">
attraversamento, <a href="#hevea_default1017">12.6</a>, <a href="#hevea_default1410">17.10</a>
</li><li class="li-indexenv">ciclo con, <a href="#hevea_default851">11.3</a>
</li><li class="li-indexenv">inizializzazione, <a href="#hevea_default1012">12.6</a>
</li><li class="li-indexenv">inverso, <a href="#hevea_default868">11.5</a>
</li><li class="li-indexenv">lookup, <a href="#hevea_default856">11.4</a>
</li><li class="li-indexenv">lookup inverso, <a href="#hevea_default857">11.4</a>
</li><li class="li-indexenv">metodi, <a href="#hevea_default1710">B.2</a>
</li><li class="li-indexenv">sottrazione, <a href="#hevea_default1092">13.6</a>
</li></ul>
</li><li class="li-indexenv">dizionario, metodi<ul class="indexenv"><li class="li-indexenv">
anydbm, modulo, <a href="#hevea_default1176">14.6</a>
</li></ul>
</li><li class="li-indexenv">docstring, <a href="#hevea_default271">4.9</a>, <a href="#hevea_default288">4.11</a>, <a href="#hevea_default1249">15.1</a>
</li><li class="li-indexenv">dot notation, <a href="#hevea_default161">3.2</a>, <a href="#hevea_default240">3.13</a>, <a href="#hevea_default1256">15.2</a>, <a href="#hevea_default1365">17.2</a>, <a href="#hevea_default1455">18.2</a>
</li><li class="li-indexenv">due punti, <a href="#hevea_default184">3.4</a>, <a href="#hevea_default1624">A.1</a>
</li><li class="li-indexenv">duplicato, <a href="#hevea_default804">10.15</a>, <a href="#hevea_default929">11.10</a>, <a href="#hevea_default1233">14.12</a>, <a href="#hevea_default1577">19.5</a>
<br>
<br>
</li><li class="li-indexenv">Elkner, Jeff, <a href="#hevea_default2">0</a>, <a href="#hevea_default4">0</a>
</li><li class="li-indexenv">eccezione, <a href="#hevea_default119">2.8.2</a>, <a href="#hevea_default141">2.9</a>, <a href="#hevea_default1615">A</a>, <a href="#hevea_default1641">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">
AttributeError, <a href="#hevea_default1290">15.7</a>, <a href="#hevea_default1655">A.2.3</a>
</li><li class="li-indexenv">IndexError, <a href="#hevea_default515">8.2</a>, <a href="#hevea_default573">8.11</a>, <a href="#hevea_default668">10.2</a>, <a href="#hevea_default1657">A.2.3</a>
</li><li class="li-indexenv">IOError, <a href="#hevea_default1159">14.5</a>
</li><li class="li-indexenv">KeyError, <a href="#hevea_default833">11.1</a>, <a href="#hevea_default1652">A.2.3</a>
</li><li class="li-indexenv">LookupError, <a href="#hevea_default864">11.4</a>
</li><li class="li-indexenv">NameError, <a href="#hevea_default203">3.8</a>, <a href="#hevea_default1645">A.2.3</a>
</li><li class="li-indexenv">OverflowError, <a href="#hevea_default370">5.12</a>
</li><li class="li-indexenv">RuntimeError, <a href="#hevea_default356">5.10</a>
</li><li class="li-indexenv">StopIteration, <a href="#hevea_default1563">19.3</a>
</li><li class="li-indexenv">SyntaxError, <a href="#hevea_default173">3.3</a>
</li><li class="li-indexenv">TypeError, <a href="#hevea_default511">8.1</a>, <a href="#hevea_default538">8.5</a>, <a href="#hevea_default872">11.5</a>, <a href="#hevea_default953">12.1</a>, <a href="#hevea_default985">12.4</a>, <a href="#hevea_default1140">14.3</a>, <a href="#hevea_default1372">17.3</a>, <a href="#hevea_default1647">A.2.3</a>
</li><li class="li-indexenv">UnboundLocalError, <a href="#hevea_default892">11.7</a>
</li><li class="li-indexenv">ValueError, <a href="#hevea_default365">5.11</a>, <a href="#hevea_default961">12.2</a>
</li></ul>
</li><li class="li-indexenv">eccezione, gestione, <a href="#hevea_default1163">14.5</a>
</li><li class="li-indexenv">elemento, <a href="#hevea_default540">8.5</a>, <a href="#hevea_default577">8.12</a>, <a href="#hevea_default651">10.1</a>, <a href="#hevea_default785">10.14</a>, <a href="#hevea_default828">11.1</a>
<ul class="indexenv"><li class="li-indexenv">
aggiornamento, <a href="#hevea_default682">10.3</a>
</li><li class="li-indexenv">assegnazione, <a href="#hevea_default541">8.5</a>, <a href="#hevea_default955">12.1</a>
</li><li class="li-indexenv">cancellazione, <a href="#hevea_default726">10.8</a>
</li><li class="li-indexenv">dizionario, <a href="#hevea_default905">11.9</a>
</li></ul>
</li><li class="li-indexenv">elemento, assegnazione, <a href="#hevea_default665">10.2</a>
</li><li class="li-indexenv">elif, parola chiave , <a href="#hevea_default337">5.6</a>
</li><li class="li-indexenv">ellissi, <a href="#hevea_default185">3.4</a>
</li><li class="li-indexenv">else, parola chiave, <a href="#hevea_default332">5.5</a>
</li><li class="li-indexenv">email, indirizzo, <a href="#hevea_default965">12.2</a>
</li><li class="li-indexenv">emotività, nel debug, <a href="#hevea_default62">1.7</a>, <a href="#hevea_default1677">A.3.4</a>
</li><li class="li-indexenv">enumerate, funzione, <a href="#hevea_default1002">12.5</a>
</li><li class="li-indexenv">enumerate, oggetto, <a href="#hevea_default1006">12.5</a>
</li><li class="li-indexenv">epsilon, <a href="#hevea_default484">7.5</a>
</li><li class="li-indexenv">equivalente, <a href="#hevea_default755">10.10</a>, <a href="#hevea_default797">10.14</a>
</li><li class="li-indexenv">equivalenza, <a href="#hevea_default1279">15.6</a>
</li><li class="li-indexenv">ereditarietà, <a href="#hevea_default1494">18.7</a>, <a href="#hevea_default1512">18.9</a>, <a href="#hevea_default1531">18.11</a>, <a href="#hevea_default1598">19.8</a>
</li><li class="li-indexenv">errore<ul class="indexenv"><li class="li-indexenv">
di battitura, <a href="#hevea_default1111">13.10</a>
</li><li class="li-indexenv">di formato, <a href="#hevea_default1036">12.8</a>
</li><li class="li-indexenv">di runtime, <a href="#hevea_default118">2.8.2</a>, <a href="#hevea_default1613">A</a>
</li><li class="li-indexenv">di semantica, <a href="#hevea_default123">2.8.3</a>, <a href="#hevea_default1617">A</a>, <a href="#hevea_default1666">A.3</a>
</li><li class="li-indexenv">di sintassi, <a href="#hevea_default113">2.8.1</a>, <a href="#hevea_default1611">A</a>
</li><li class="li-indexenv">in esecuzione, <a href="#hevea_default117">2.8.2</a>, <a href="#hevea_default354">5.10</a>, <a href="#hevea_default369">5.12</a>, <a href="#hevea_default1612">A</a>, <a href="#hevea_default1642">A.2.3</a>
</li><li class="li-indexenv">messaggio di, <a href="#hevea_default86">1.9</a>, <a href="#hevea_default114">2.8.1</a>, <a href="#hevea_default124">2.8.3</a>, <a href="#hevea_default1618">A.1</a>
</li></ul>
</li><li class="li-indexenv">esadecimale, <a href="#hevea_default1253">15.1</a>
</li><li class="li-indexenv">esecuzione, <a href="#hevea_default99">2.3</a>, <a href="#hevea_default133">2.9</a>
</li><li class="li-indexenv">esecuzione alternativa, <a href="#hevea_default331">5.5</a>
</li><li class="li-indexenv">esecuzione condizionale, <a href="#hevea_default326">5.4</a>
</li><li class="li-indexenv">esponente, <a href="#hevea_default1693">B.1</a>
</li><li class="li-indexenv">espressione, <a href="#hevea_default96">2.3</a>, <a href="#hevea_default130">2.9</a>
<ul class="indexenv"><li class="li-indexenv">
booleana, <a href="#hevea_default305">5.2</a>, <a href="#hevea_default376">5.13</a>
</li><li class="li-indexenv">condizionale, <a href="#hevea_default1543">19.1</a>, <a href="#hevea_default1605">19.10</a>
</li><li class="li-indexenv">grande e complicata, <a href="#hevea_default1668">A.3.2</a>
</li></ul>
</li><li class="li-indexenv">eval, funzione, <a href="#hevea_default499">7.9</a>
</li><li class="li-indexenv">exists, funzione, <a href="#hevea_default1154">14.4</a>
</li><li class="li-indexenv">extend, metodo, <a href="#hevea_default706">10.6</a>
<br>
<br>
</li><li class="li-indexenv">False, valore speciale, <a href="#hevea_default308">5.2</a>
</li><li class="li-indexenv">Fermat, ultimo teorema di, <a href="#hevea_default386">5.14</a>
</li><li class="li-indexenv">Free Documentation License, GNU, <a href="#hevea_default1">0</a>, <a href="#hevea_default7">0</a>
</li><li class="li-indexenv">factory, funzione, <a href="#hevea_default1588">19.7</a>, <a href="#hevea_default1590">19.7</a>, <a href="#hevea_default1608">19.10</a>
</li><li class="li-indexenv">fattoriale, <a href="#hevea_default1546">19.1</a>
</li><li class="li-indexenv">fattoriale, funzione, <a href="#hevea_default420">6.5</a>, <a href="#hevea_default434">6.8</a>
</li><li class="li-indexenv">fibonacci, funzione, <a href="#hevea_default429">6.7</a>, <a href="#hevea_default876">11.6</a>
</li><li class="li-indexenv">figlia, classe, <a href="#hevea_default1501">18.7</a>
</li><li class="li-indexenv">file, <a href="#hevea_default1124">14.1</a>
<ul class="indexenv"><li class="li-indexenv">
di testo, <a href="#hevea_default1218">14.11</a>
</li><li class="li-indexenv">lettura e scrittura, <a href="#hevea_default1129">14.2</a>
</li><li class="li-indexenv">nome, <a href="#hevea_default1142">14.4</a>
</li><li class="li-indexenv">permesso, <a href="#hevea_default1161">14.5</a>
</li></ul>
</li><li class="li-indexenv">filtro, schema, <a href="#hevea_default724">10.7</a>, <a href="#hevea_default794">10.14</a>, <a href="#hevea_default1556">19.2</a>
</li><li class="li-indexenv">fine riga, carattere, <a href="#hevea_default1213">14.10</a>
</li><li class="li-indexenv">fiore, <a href="#hevea_default293">4.12</a>
</li><li class="li-indexenv">flag, <a href="#hevea_default883">11.7</a>, <a href="#hevea_default921">11.9</a>
</li><li class="li-indexenv">float, funzione, <a href="#hevea_default154">3.1</a>
</li><li class="li-indexenv">float, tipo, <a href="#hevea_default43">1.5</a>
</li><li class="li-indexenv">floating-point, <a href="#hevea_default35">1.5</a>, <a href="#hevea_default76">1.8</a>, <a href="#hevea_default1545">19.1</a>
</li><li class="li-indexenv">flusso di esecuzione, <a href="#hevea_default190">3.6</a>, <a href="#hevea_default243">3.13</a>, <a href="#hevea_default431">6.7</a>, <a href="#hevea_default446">6.9</a>, <a href="#hevea_default472">7.3</a>, <a href="#hevea_default1513">18.9</a>, <a href="#hevea_default1640">A.2.2</a>
</li><li class="li-indexenv">for, ciclo, <a href="#hevea_default253">4.2</a>, <a href="#hevea_default346">5.8</a>, <a href="#hevea_default520">8.3</a>, <a href="#hevea_default677">10.3</a>, <a href="#hevea_default1000">12.5</a>, <a href="#hevea_default1554">19.2</a>
</li><li class="li-indexenv">formato, <a href="#hevea_default1048">12.9</a>
<ul class="indexenv"><li class="li-indexenv">
operatore di, <a href="#hevea_default1134">14.3</a>, <a href="#hevea_default1649">A.2.3</a>
</li><li class="li-indexenv">sequenza di, <a href="#hevea_default1138">14.3</a>
</li><li class="li-indexenv">stringa di, <a href="#hevea_default1136">14.3</a>
</li></ul>
</li><li class="li-indexenv">formato, errore di, <a href="#hevea_default1035">12.8</a>
</li><li class="li-indexenv">frame, <a href="#hevea_default207">3.9</a>, <a href="#hevea_default246">3.13</a>, <a href="#hevea_default350">5.9</a>, <a href="#hevea_default425">6.5</a>, <a href="#hevea_default879">11.6</a>
</li><li class="li-indexenv">frequenza, <a href="#hevea_default846">11.2</a>
<ul class="indexenv"><li class="li-indexenv">
di lettere, <a href="#hevea_default1050">12.10</a>
</li><li class="li-indexenv">di parole, <a href="#hevea_default1070">13.1</a>, <a href="#hevea_default1120">13.12</a>
</li></ul>
</li><li class="li-indexenv">frustrazione, <a href="#hevea_default1674">A.3.4</a>
</li><li class="li-indexenv">funzione, <a href="#hevea_default24">1.3</a>, <a href="#hevea_default146">3</a>, <a href="#hevea_default174">3.4</a>, <a href="#hevea_default222">3.13</a>, <a href="#hevea_default1358">17.1</a>
<ul class="indexenv"><li class="li-indexenv">
abs, <a href="#hevea_default398">6.1</a>
</li><li class="li-indexenv">ack, <a href="#hevea_default455">6.11</a>, <a href="#hevea_default928">11.10</a>
</li><li class="li-indexenv">all, <a href="#hevea_default1572">19.4</a>
</li><li class="li-indexenv">any, <a href="#hevea_default1567">19.4</a>
</li><li class="li-indexenv">arco, <a href="#hevea_default262">4.3</a>
</li><li class="li-indexenv">argomento di, <a href="#hevea_default194">3.7</a>
</li><li class="li-indexenv">booleana, <a href="#hevea_default412">6.4</a>
</li><li class="li-indexenv">cerchio, <a href="#hevea_default260">4.3</a>
</li><li class="li-indexenv">chiamata di, <a href="#hevea_default147">3.1</a>, <a href="#hevea_default228">3.13</a>
</li><li class="li-indexenv">choice, <a href="#hevea_default1081">13.2</a>
</li><li class="li-indexenv">compara, <a href="#hevea_default400">6.1</a>
</li><li class="li-indexenv">composizione di, <a href="#hevea_default410">6.3</a>
</li><li class="li-indexenv">deepcopy, <a href="#hevea_default1288">15.6</a>
</li><li class="li-indexenv">definizione di, <a href="#hevea_default175">3.4</a>, <a href="#hevea_default188">3.5</a>, <a href="#hevea_default223">3.13</a>
</li><li class="li-indexenv">dict, <a href="#hevea_default830">11.1</a>
</li><li class="li-indexenv">enumerate, <a href="#hevea_default1003">12.5</a>
</li><li class="li-indexenv">eval, <a href="#hevea_default500">7.9</a>
</li><li class="li-indexenv">exists, <a href="#hevea_default1155">14.4</a>
</li><li class="li-indexenv">fattoriale, <a href="#hevea_default421">6.5</a>, <a href="#hevea_default1547">19.1</a>
</li><li class="li-indexenv">fibonacci, <a href="#hevea_default430">6.7</a>, <a href="#hevea_default877">11.6</a>
</li><li class="li-indexenv">float, <a href="#hevea_default155">3.1</a>
</li><li class="li-indexenv">frame di, <a href="#hevea_default206">3.9</a>, <a href="#hevea_default245">3.13</a>, <a href="#hevea_default349">5.9</a>, <a href="#hevea_default424">6.5</a>, <a href="#hevea_default878">11.6</a>
</li><li class="li-indexenv">gamma, <a href="#hevea_default437">6.8</a>
</li><li class="li-indexenv">getattr, <a href="#hevea_default1412">17.10</a>
</li><li class="li-indexenv">getcwd, <a href="#hevea_default1149">14.4</a>
</li><li class="li-indexenv">hasattr, <a href="#hevea_default1297">15.7</a>, <a href="#hevea_default1406">17.10</a>
</li><li class="li-indexenv">input, <a href="#hevea_default361">5.11</a>
</li><li class="li-indexenv">int, <a href="#hevea_default153">3.1</a>
</li><li class="li-indexenv">isinstance, <a href="#hevea_default439">6.8</a>, <a href="#hevea_default1295">15.7</a>, <a href="#hevea_default1395">17.8</a>
</li><li class="li-indexenv">len, <a href="#hevea_default249">3.14</a>, <a href="#hevea_default514">8.2</a>, <a href="#hevea_default836">11.1</a>
</li><li class="li-indexenv">list, <a href="#hevea_default740">10.9</a>
</li><li class="li-indexenv">log, <a href="#hevea_default164">3.2</a>
</li><li class="li-indexenv">max, <a href="#hevea_default974">12.3</a>, <a href="#hevea_default987">12.4</a>
</li><li class="li-indexenv">min, <a href="#hevea_default976">12.3</a>, <a href="#hevea_default989">12.4</a>
</li><li class="li-indexenv">modificatore, <a href="#hevea_default1323">16.3</a>
</li><li class="li-indexenv">motivi, <a href="#hevea_default216">3.11</a>
</li><li class="li-indexenv">open, <a href="#hevea_default603">9.1</a>, <a href="#hevea_default611">9.1</a>, <a href="#hevea_default1131">14.2</a>, <a href="#hevea_default1158">14.5</a>, <a href="#hevea_default1170">14.6</a>
</li><li class="li-indexenv">parametro di, <a href="#hevea_default192">3.7</a>
</li><li class="li-indexenv">personalizzata, <a href="#hevea_default197">3.7</a>, <a href="#hevea_default1089">13.5</a>
</li><li class="li-indexenv">poligono, <a href="#hevea_default258">4.3</a>
</li><li class="li-indexenv">popen, <a href="#hevea_default1189">14.8</a>
</li><li class="li-indexenv">produttiva, <a href="#hevea_default210">3.10</a>, <a href="#hevea_default232">3.13</a>
</li><li class="li-indexenv">pura, <a href="#hevea_default1319">16.2</a>, <a href="#hevea_default1345">16.6</a>
</li><li class="li-indexenv">randint, <a href="#hevea_default810">10.15</a>, <a href="#hevea_default1079">13.2</a>
</li><li class="li-indexenv">random, <a href="#hevea_default1077">13.2</a>
</li><li class="li-indexenv">reload, <a href="#hevea_default1207">14.9</a>, <a href="#hevea_default1632">A.1.1</a>
</li><li class="li-indexenv">repr, <a href="#hevea_default1211">14.10</a>
</li><li class="li-indexenv">reversed, <a href="#hevea_default1031">12.7</a>
</li><li class="li-indexenv">ricorsiva, <a href="#hevea_default343">5.8</a>
</li><li class="li-indexenv">shuffle, <a href="#hevea_default1491">18.6</a>
</li><li class="li-indexenv">sintassi, <a href="#hevea_default1364">17.2</a>
</li><li class="li-indexenv">sorted, <a href="#hevea_default783">10.13</a>, <a href="#hevea_default855">11.3</a>, <a href="#hevea_default1029">12.7</a>
</li><li class="li-indexenv">sqrt, <a href="#hevea_default170">3.2</a>, <a href="#hevea_default406">6.2</a>
</li><li class="li-indexenv">str, <a href="#hevea_default157">3.1</a>
</li><li class="li-indexenv">sum, <a href="#hevea_default991">12.4</a>, <a href="#hevea_default1565">19.3</a>
</li><li class="li-indexenv">trigonometrica, <a href="#hevea_default167">3.2</a>
</li><li class="li-indexenv">trova, <a href="#hevea_default546">8.6</a>
</li><li class="li-indexenv">tupla come valore di ritorno, <a href="#hevea_default969">12.3</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default946">12.1</a>
</li><li class="li-indexenv">type, <a href="#hevea_default1293">15.7</a>
</li><li class="li-indexenv">vuota, <a href="#hevea_default211">3.10</a>, <a href="#hevea_default233">3.13</a>
</li><li class="li-indexenv">zip, <a href="#hevea_default993">12.5</a>
</li></ul>
</li><li class="li-indexenv">funzioni matematiche, <a href="#hevea_default158">3.2</a>
<br>
<br>
</li><li class="li-indexenv">Giorno del Doppio, <a href="#hevea_default1355">16.7</a>
</li><li class="li-indexenv">GNU Free Documentation License, <a href="#hevea_default0">0</a>, <a href="#hevea_default6">0</a>
</li><li class="li-indexenv">generalizzazione, <a href="#hevea_default264">4.5</a>, <a href="#hevea_default283">4.11</a>, <a href="#hevea_default620">9.3</a>, <a href="#hevea_default1336">16.4</a>
</li><li class="li-indexenv">generator expression, <a href="#hevea_default1559">19.3</a>, <a href="#hevea_default1568">19.4</a>, <a href="#hevea_default1607">19.10</a>
</li><li class="li-indexenv">generatore, oggetto, <a href="#hevea_default1560">19.3</a>
</li><li class="li-indexenv">gestire, <a href="#hevea_default1223">14.11</a>
</li><li class="li-indexenv">get, metodo, <a href="#hevea_default849">11.2</a>
</li><li class="li-indexenv">getattr, funzione, <a href="#hevea_default1411">17.10</a>
</li><li class="li-indexenv">getcwd, funzione, <a href="#hevea_default1148">14.4</a>
</li><li class="li-indexenv">global, istruzione, <a href="#hevea_default886">11.7</a>, <a href="#hevea_default919">11.9</a>
</li><li class="li-indexenv">globale, variabile, <a href="#hevea_default918">11.9</a>
</li><li class="li-indexenv">graffe, parentesi, <a href="#hevea_default831">11.1</a>
</li><li class="li-indexenv">grafico di chiamata, <a href="#hevea_default880">11.6</a>
</li><li class="li-indexenv">griglia, <a href="#hevea_default251">3.14</a>
</li><li class="li-indexenv">guardia, condizione di, <a href="#hevea_default440">6.8</a>, <a href="#hevea_default451">6.10</a>, <a href="#hevea_default569">8.11</a>
<br>
<br>
</li><li class="li-indexenv">HAS-A, relazione, <a href="#hevea_default1508">18.8</a>, <a href="#hevea_default1535">18.11</a>
</li><li class="li-indexenv">Holmes, Sherlock, <a href="#hevea_default219">3.12</a>
</li><li class="li-indexenv">hasattr, funzione, <a href="#hevea_default1296">15.7</a>, <a href="#hevea_default1405">17.10</a>
</li><li class="li-indexenv">hash, funzione, <a href="#hevea_default873">11.5</a>, <a href="#hevea_default910">11.9</a>, <a href="#hevea_default1724">B.4</a>
</li><li class="li-indexenv">hashing, <a href="#hevea_default874">11.5</a>, <a href="#hevea_default911">11.9</a>, <a href="#hevea_default1019">12.6</a>
<br>
<br>
</li><li class="li-indexenv">IndexError, <a href="#hevea_default516">8.2</a>, <a href="#hevea_default572">8.11</a>, <a href="#hevea_default669">10.2</a>, <a href="#hevea_default1656">A.2.3</a>
</li><li class="li-indexenv">Input da tastiera, <a href="#hevea_default358">5.11</a>
</li><li class="li-indexenv">IOError, <a href="#hevea_default1160">14.5</a>
</li><li class="li-indexenv">IS-A, relazione, <a href="#hevea_default1507">18.8</a>, <a href="#hevea_default1534">18.11</a>
</li><li class="li-indexenv">identico, <a href="#hevea_default798">10.14</a>
</li><li class="li-indexenv">identità, <a href="#hevea_default756">10.10</a>, <a href="#hevea_default1278">15.6</a>
</li><li class="li-indexenv">if, istruzione, <a href="#hevea_default324">5.4</a>
</li><li class="li-indexenv">immutabilità, <a href="#hevea_default535">8.5</a>, <a href="#hevea_default543">8.5</a>, <a href="#hevea_default581">8.12</a>, <a href="#hevea_default764">10.11</a>, <a href="#hevea_default875">11.5</a>, <a href="#hevea_default941">12.1</a>, <a href="#hevea_default1027">12.7</a>
</li><li class="li-indexenv">impalcatura, <a href="#hevea_default407">6.2</a>, <a href="#hevea_default450">6.10</a>, <a href="#hevea_default901">11.8</a>
</li><li class="li-indexenv">impiallacciatura, <a href="#hevea_default1487">18.6</a>, <a href="#hevea_default1530">18.11</a>
</li><li class="li-indexenv">implementazione, <a href="#hevea_default844">11.2</a>, <a href="#hevea_default908">11.9</a>, <a href="#hevea_default1105">13.9</a>, <a href="#hevea_default1414">17.11</a>
</li><li class="li-indexenv">import, istruzione, <a href="#hevea_default237">3.13</a>, <a href="#hevea_default1201">14.9</a>
</li><li class="li-indexenv">in, operatore, <a href="#hevea_default561">8.9</a>, <a href="#hevea_default618">9.3</a>, <a href="#hevea_default673">10.2</a>, <a href="#hevea_default838">11.1</a>, <a href="#hevea_default1717">B.3</a>
</li><li class="li-indexenv">incapsulamento, <a href="#hevea_default263">4.4</a>, <a href="#hevea_default282">4.11</a>, <a href="#hevea_default411">6.3</a>, <a href="#hevea_default498">7.9</a>, <a href="#hevea_default554">8.7</a>, <a href="#hevea_default1506">18.7</a>
<ul class="indexenv"><li class="li-indexenv">
dei dati, <a href="#hevea_default1523">18.10</a>, <a href="#hevea_default1539">18.11</a>
</li></ul>
</li><li class="li-indexenv">incastro, parola, <a href="#hevea_default822">10.15</a>
</li><li class="li-indexenv">incremento, <a href="#hevea_default467">7.2</a>, <a href="#hevea_default492">7.8</a>, <a href="#hevea_default1324">16.3</a>, <a href="#hevea_default1371">17.3</a>
</li><li class="li-indexenv">indentazione, <a href="#hevea_default183">3.4</a>, <a href="#hevea_default1363">17.2</a>, <a href="#hevea_default1628">A.1</a>
</li><li class="li-indexenv">indice, <a href="#hevea_default507">8.1</a>, <a href="#hevea_default510">8.1</a>, <a href="#hevea_default571">8.11</a>, <a href="#hevea_default578">8.12</a>, <a href="#hevea_default658">10.2</a>, <a href="#hevea_default827">11.1</a>, <a href="#hevea_default1648">A.2.3</a>
<ul class="indexenv"><li class="li-indexenv">
inizio da zero, <a href="#hevea_default508">8.1</a>, <a href="#hevea_default662">10.2</a>
</li><li class="li-indexenv">negativo, <a href="#hevea_default517">8.2</a>
</li><li class="li-indexenv">nei cicli, <a href="#hevea_default625">9.4</a>, <a href="#hevea_default681">10.3</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default528">8.4</a>, <a href="#hevea_default693">10.5</a>
</li></ul>
</li><li class="li-indexenv">indicizzazione, <a href="#hevea_default1703">B.2</a>
</li><li class="li-indexenv">inefficienza, <a href="#hevea_default1699">B.1</a>
</li><li class="li-indexenv">information hiding, <a href="#hevea_default1428">17.12</a>
</li><li class="li-indexenv">init, metodo, <a href="#hevea_default1378">17.5</a>, <a href="#hevea_default1403">17.10</a>, <a href="#hevea_default1449">18.1</a>, <a href="#hevea_default1468">18.4</a>, <a href="#hevea_default1504">18.7</a>
</li><li class="li-indexenv">inizializzazione<ul class="indexenv"><li class="li-indexenv">
prima di aggiornare, <a href="#hevea_default466">7.2</a>
</li><li class="li-indexenv">variabile, <a href="#hevea_default491">7.8</a>
</li></ul>
</li><li class="li-indexenv">input, funzione, <a href="#hevea_default360">5.11</a>
</li><li class="li-indexenv">insieme, <a href="#hevea_default1094">13.6</a>, <a href="#hevea_default1574">19.5</a>
<ul class="indexenv"><li class="li-indexenv">
anagramma, <a href="#hevea_default1052">12.10</a>, <a href="#hevea_default1231">14.12</a>
</li></ul>
</li><li class="li-indexenv">insieme di appartenenza, <a href="#hevea_default923">11.10</a>
</li><li class="li-indexenv">int, funzione, <a href="#hevea_default152">3.1</a>
</li><li class="li-indexenv">int, tipo, <a href="#hevea_default41">1.5</a>
</li><li class="li-indexenv">interfaccia, <a href="#hevea_default267">4.6</a>, <a href="#hevea_default277">4.10</a>, <a href="#hevea_default285">4.11</a>, <a href="#hevea_default1413">17.11</a>, <a href="#hevea_default1518">18.9</a>
</li><li class="li-indexenv">intero, <a href="#hevea_default34">1.5</a>, <a href="#hevea_default75">1.8</a>
</li><li class="li-indexenv">interprete, <a href="#hevea_default18">1.2</a>, <a href="#hevea_default67">1.8</a>
</li><li class="li-indexenv">intersezione, punto di, <a href="#hevea_default1734">B.5</a>
</li><li class="li-indexenv">intestazione, <a href="#hevea_default181">3.4</a>, <a href="#hevea_default225">3.13</a>, <a href="#hevea_default1623">A.1</a>
</li><li class="li-indexenv">invariante, <a href="#hevea_default1338">16.5</a>, <a href="#hevea_default1348">16.6</a>
</li><li class="li-indexenv">invocazione, <a href="#hevea_default559">8.8</a>, <a href="#hevea_default586">8.12</a>
</li><li class="li-indexenv">ipotenusa, <a href="#hevea_default408">6.2</a>
</li><li class="li-indexenv">is, operatore, <a href="#hevea_default752">10.10</a>, <a href="#hevea_default1276">15.6</a>
</li><li class="li-indexenv">isinstance, funzione, <a href="#hevea_default438">6.8</a>, <a href="#hevea_default1294">15.7</a>, <a href="#hevea_default1394">17.8</a>
</li><li class="li-indexenv">istanza, <a href="#hevea_default1251">15.1</a>, <a href="#hevea_default1304">15.8</a>
<ul class="indexenv"><li class="li-indexenv">
attributo di, <a href="#hevea_default1254">15.2</a>, <a href="#hevea_default1307">15.8</a>, <a href="#hevea_default1453">18.2</a>, <a href="#hevea_default1528">18.11</a>
</li><li class="li-indexenv">come argomento, <a href="#hevea_default1259">15.2</a>
</li><li class="li-indexenv">come valore di ritorno, <a href="#hevea_default1267">15.4</a>
</li></ul>
</li><li class="li-indexenv">istanziare, <a href="#hevea_default1252">15.1</a>, <a href="#hevea_default1305">15.8</a>
</li><li class="li-indexenv">istogramma, <a href="#hevea_default845">11.2</a>, <a href="#hevea_default848">11.2</a>
<ul class="indexenv"><li class="li-indexenv">
frequenza delle parole, <a href="#hevea_default1083">13.3</a>
</li><li class="li-indexenv">scelta casuale, <a href="#hevea_default1082">13.2</a>, <a href="#hevea_default1096">13.7</a>
</li></ul>
</li><li class="li-indexenv">istruzione, <a href="#hevea_default132">2.9</a>
<ul class="indexenv"><li class="li-indexenv">
assegnazione, <a href="#hevea_default460">7.1</a>
</li><li class="li-indexenv">assert, <a href="#hevea_default1342">16.5</a>, <a href="#hevea_default1350">16.6</a>
</li><li class="li-indexenv">break, <a href="#hevea_default479">7.4</a>
</li><li class="li-indexenv">composta, <a href="#hevea_default328">5.4</a>, <a href="#hevea_default379">5.13</a>
</li><li class="li-indexenv">condizionale, <a href="#hevea_default323">5.4</a>, <a href="#hevea_default377">5.13</a>, <a href="#hevea_default413">6.4</a>, <a href="#hevea_default1551">19.1</a>, <a href="#hevea_default1627">A.1</a>
</li><li class="li-indexenv">di assegnazione, <a href="#hevea_default90">2.1</a>
</li><li class="li-indexenv">di stampa, <a href="#hevea_default23">1.3</a>, <a href="#hevea_default71">1.8</a>, <a href="#hevea_default1389">17.6</a>, <a href="#hevea_default1661">A.2.4</a>
</li><li class="li-indexenv">for, <a href="#hevea_default255">4.2</a>, <a href="#hevea_default522">8.3</a>, <a href="#hevea_default679">10.3</a>
</li><li class="li-indexenv">global, <a href="#hevea_default887">11.7</a>, <a href="#hevea_default920">11.9</a>
</li><li class="li-indexenv">if, <a href="#hevea_default325">5.4</a>
</li><li class="li-indexenv">import, <a href="#hevea_default238">3.13</a>, <a href="#hevea_default1202">14.9</a>
</li><li class="li-indexenv">pass, <a href="#hevea_default330">5.4</a>
</li><li class="li-indexenv">raise, <a href="#hevea_default863">11.4</a>, <a href="#hevea_default1340">16.5</a>
</li><li class="li-indexenv">return, <a href="#hevea_default345">5.8</a>, <a href="#hevea_default392">6.1</a>, <a href="#hevea_default1673">A.3.3</a>
</li><li class="li-indexenv">try, <a href="#hevea_default1165">14.5</a>, <a href="#hevea_default1300">15.7</a>
</li><li class="li-indexenv">while, <a href="#hevea_default469">7.3</a>
</li></ul>
</li><li class="li-indexenv">items, metodo, <a href="#hevea_default1008">12.6</a>
</li><li class="li-indexenv">iteratore, <a href="#hevea_default994">12.5</a>, <a href="#hevea_default1004">12.5</a>, <a href="#hevea_default1011">12.6</a>, <a href="#hevea_default1032">12.7</a>, <a href="#hevea_default1046">12.9</a>, <a href="#hevea_default1711">B.2</a>
</li><li class="li-indexenv">iterazione, <a href="#hevea_default471">7.3</a>, <a href="#hevea_default494">7.8</a>
<br>
<br>
</li><li class="li-indexenv"><span class="c003">join</span>, <a href="#hevea_default1707">B.2</a>
</li><li class="li-indexenv">join, metodo, <a href="#hevea_default745">10.9</a>, <a href="#hevea_default1480">18.5</a>
<br>
<br>
</li><li class="li-indexenv">KeyError, <a href="#hevea_default834">11.1</a>, <a href="#hevea_default1651">A.2.3</a>, <a href="#hevea_default1721">B.4</a>
<br>
<br>
</li><li class="li-indexenv">Linux, <a href="#hevea_default221">3.12</a>
</li><li class="li-indexenv">Liskov, principio di sostituzione, <a href="#hevea_default1521">18.9</a>
</li><li class="li-indexenv">LookupError, <a href="#hevea_default865">11.4</a>
</li><li class="li-indexenv">lavoro, directory di, <a href="#hevea_default1150">14.4</a>
</li><li class="li-indexenv">len, funzione, <a href="#hevea_default248">3.14</a>, <a href="#hevea_default513">8.2</a>, <a href="#hevea_default835">11.1</a>
</li><li class="li-indexenv">letteralità, <a href="#hevea_default55">1.6</a>
</li><li class="li-indexenv">lettere<ul class="indexenv"><li class="li-indexenv">
doppie, <a href="#hevea_default641">9.7</a>
</li><li class="li-indexenv">frequenza, <a href="#hevea_default1049">12.10</a>
</li><li class="li-indexenv">rotazione, <a href="#hevea_default930">11.10</a>
</li></ul>
</li></ul></td><td class="c017"><ul class="indexenv"><li class="li-indexenv">lineare, <a href="#hevea_default1737">B.5</a>
</li><li class="li-indexenv">linguaggio<ul class="indexenv"><li class="li-indexenv">
completo di Turing, <a href="#hevea_default415">6.5</a>
</li><li class="li-indexenv">di alto livello, <a href="#hevea_default64">1.8</a>
</li><li class="li-indexenv">di basso livello, <a href="#hevea_default65">1.8</a>
</li><li class="li-indexenv">formale, <a href="#hevea_default47">1.6</a>, <a href="#hevea_default79">1.8</a>
</li><li class="li-indexenv">naturale, <a href="#hevea_default48">1.6</a>, <a href="#hevea_default78">1.8</a>
</li><li class="li-indexenv">orientato agli oggetti, <a href="#hevea_default1418">17.12</a>
</li><li class="li-indexenv">sicuro, <a href="#hevea_default120">2.8.2</a>
</li></ul>
</li><li class="li-indexenv">lipogramma, <a href="#hevea_default613">9.2</a>
</li><li class="li-indexenv">list comprehension, <a href="#hevea_default1552">19.2</a>, <a href="#hevea_default1606">19.10</a>
</li><li class="li-indexenv">list, funzione, <a href="#hevea_default739">10.9</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default649">10.1</a>, <a href="#hevea_default736">10.9</a>, <a href="#hevea_default784">10.14</a>, <a href="#hevea_default1024">12.7</a>, <a href="#hevea_default1553">19.2</a>
<ul class="indexenv"><li class="li-indexenv">
appartenenza, <a href="#hevea_default671">10.2</a>
</li><li class="li-indexenv">attraversamento, <a href="#hevea_default675">10.3</a>
</li><li class="li-indexenv">come argomento, <a href="#hevea_default765">10.12</a>
</li><li class="li-indexenv">concatenamento, <a href="#hevea_default688">10.4</a>, <a href="#hevea_default773">10.12</a>, <a href="#hevea_default813">10.15</a>
</li><li class="li-indexenv">copia, <a href="#hevea_default696">10.5</a>
</li><li class="li-indexenv">di oggetti, <a href="#hevea_default1466">18.4</a>
</li><li class="li-indexenv">di tuple, <a href="#hevea_default995">12.5</a>
</li><li class="li-indexenv">elemento, <a href="#hevea_default656">10.2</a>
</li><li class="li-indexenv">indice, <a href="#hevea_default670">10.2</a>
</li><li class="li-indexenv">metodi, <a href="#hevea_default702">10.6</a>, <a href="#hevea_default1708">B.2</a>
</li><li class="li-indexenv">nidificata, <a href="#hevea_default653">10.1</a>, <a href="#hevea_default685">10.3</a>, <a href="#hevea_default786">10.14</a>
</li><li class="li-indexenv">operazione, <a href="#hevea_default686">10.4</a>
</li><li class="li-indexenv">ripetizione, <a href="#hevea_default690">10.4</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default694">10.5</a>
</li><li class="li-indexenv">vuota, <a href="#hevea_default654">10.1</a>
</li></ul>
</li><li class="li-indexenv">log, funzione, <a href="#hevea_default163">3.2</a>
</li><li class="li-indexenv">logaritmo, <a href="#hevea_default1122">13.12</a>
</li><li class="li-indexenv">logico, operatore, <a href="#hevea_default315">5.3</a>
</li><li class="li-indexenv">lookup, <a href="#hevea_default912">11.9</a>
<ul class="indexenv"><li class="li-indexenv">
dizionario, <a href="#hevea_default858">11.4</a>
</li></ul>
</li><li class="li-indexenv">lookup inverso, <a href="#hevea_default913">11.9</a>
</li><li class="li-indexenv">lookup inverso, dizionario, <a href="#hevea_default859">11.4</a>
</li><li class="li-indexenv">loop variable, <a href="#hevea_default1555">19.2</a>
</li><li class="li-indexenv">ls (comando Unix), <a href="#hevea_default1186">14.8</a>
</li><li class="li-indexenv">lunghezza variabile, tupla di argomenti, <a href="#hevea_default977">12.4</a>
<br>
<br>
</li><li class="li-indexenv">Mano, classe, <a href="#hevea_default1497">18.7</a>
</li><li class="li-indexenv">MappaHash, <a href="#hevea_default1725">B.4</a>
</li><li class="li-indexenv"><span class="c003">MappaLineare</span>, <a href="#hevea_default1720">B.4</a>
</li><li class="li-indexenv"><span class="c003">MappaMigliore</span>, <a href="#hevea_default1723">B.4</a>
</li><li class="li-indexenv">Markov, analisi di, <a href="#hevea_default1098">13.8</a>
</li><li class="li-indexenv">Matplotlib, <a href="#hevea_default1123">13.12</a>
</li><li class="li-indexenv">Mazzo, classe, <a href="#hevea_default1472">18.4</a>
</li><li class="li-indexenv">MCD (massimo comun divisore), <a href="#hevea_default458">6.11</a>
</li><li class="li-indexenv">McCloskey, Robert, <a href="#hevea_default525">8.3</a>
</li><li class="li-indexenv">Meyers, Chris, <a href="#hevea_default5">0</a>
</li><li class="li-indexenv">Moby Project, <a href="#hevea_default600">9.1</a>
</li><li class="li-indexenv">Monty Python e il Sacro Graal, <a href="#hevea_default1320">16.2</a>
</li><li class="li-indexenv">MP3, <a href="#hevea_default1232">14.12</a>
</li><li class="li-indexenv">macchina da scrivere a tartaruga, <a href="#hevea_default296">4.12</a>
</li><li class="li-indexenv">madre, classe, <a href="#hevea_default1499">18.7</a>
</li><li class="li-indexenv">main, <a href="#hevea_default208">3.9</a>, <a href="#hevea_default341">5.8</a>, <a href="#hevea_default884">11.7</a>, <a href="#hevea_default1204">14.9</a>
</li><li class="li-indexenv">manutenzione, <a href="#hevea_default1415">17.11</a>
</li><li class="li-indexenv">mappa, schema, <a href="#hevea_default722">10.7</a>, <a href="#hevea_default792">10.14</a>
</li><li class="li-indexenv">mappatura, <a href="#hevea_default902">11.9</a>, <a href="#hevea_default1101">13.8</a>
</li><li class="li-indexenv">massimo comun divisore (MCD), <a href="#hevea_default457">6.11</a>
</li><li class="li-indexenv">max, funzione, <a href="#hevea_default973">12.3</a>, <a href="#hevea_default986">12.4</a>
</li><li class="li-indexenv">mazzo, <a href="#hevea_default1440">18</a>
</li><li class="li-indexenv">mazzo, carte da gioco, <a href="#hevea_default1467">18.4</a>
</li><li class="li-indexenv">md5, <a href="#hevea_default1196">14.8</a>
</li><li class="li-indexenv">md5, algoritmo, <a href="#hevea_default1234">14.12</a>
</li><li class="li-indexenv">md5sum, <a href="#hevea_default1237">14.12</a>
</li><li class="li-indexenv">memoizzazione, <a href="#hevea_default881">11.6</a>, <a href="#hevea_default917">11.9</a>
</li><li class="li-indexenv">metafora, invocazione di metodo, <a href="#hevea_default1370">17.2</a>
</li><li class="li-indexenv">metatesi, <a href="#hevea_default1054">12.10</a>
</li><li class="li-indexenv">metodi delle liste, <a href="#hevea_default703">10.6</a>
</li><li class="li-indexenv">metodo, <a href="#hevea_default280">4.11</a>, <a href="#hevea_default555">8.8</a>, <a href="#hevea_default1357">17.1</a>, <a href="#hevea_default1420">17.12</a>
<ul class="indexenv"><li class="li-indexenv">
__lt__, <a href="#hevea_default1463">18.3</a>
</li><li class="li-indexenv">__str__, <a href="#hevea_default1386">17.6</a>, <a href="#hevea_default1477">18.5</a>
</li><li class="li-indexenv">add, <a href="#hevea_default1392">17.7</a>
</li><li class="li-indexenv">append, <a href="#hevea_default705">10.6</a>, <a href="#hevea_default772">10.12</a>, <a href="#hevea_default812">10.15</a>, <a href="#hevea_default1475">18.4</a>, <a href="#hevea_default1486">18.6</a>
</li><li class="li-indexenv">close, <a href="#hevea_default1133">14.2</a>, <a href="#hevea_default1178">14.6</a>, <a href="#hevea_default1195">14.8</a>
</li><li class="li-indexenv">count, <a href="#hevea_default594">8.13</a>
</li><li class="li-indexenv">extend, <a href="#hevea_default707">10.6</a>
</li><li class="li-indexenv">get, <a href="#hevea_default850">11.2</a>
</li><li class="li-indexenv">init, <a href="#hevea_default1379">17.5</a>, <a href="#hevea_default1450">18.1</a>, <a href="#hevea_default1469">18.4</a>, <a href="#hevea_default1505">18.7</a>
</li><li class="li-indexenv">items, <a href="#hevea_default1009">12.6</a>
</li><li class="li-indexenv">join, <a href="#hevea_default746">10.9</a>, <a href="#hevea_default1481">18.5</a>
</li><li class="li-indexenv">mro, <a href="#hevea_default1515">18.9</a>
</li><li class="li-indexenv">pop, <a href="#hevea_default729">10.8</a>, <a href="#hevea_default1484">18.6</a>
</li><li class="li-indexenv">radd, <a href="#hevea_default1399">17.8</a>
</li><li class="li-indexenv">read, <a href="#hevea_default1193">14.8</a>
</li><li class="li-indexenv">readline, <a href="#hevea_default607">9.1</a>, <a href="#hevea_default1191">14.8</a>
</li><li class="li-indexenv">remove, <a href="#hevea_default733">10.8</a>
</li><li class="li-indexenv">replace, <a href="#hevea_default1064">13.1</a>
</li><li class="li-indexenv">setdefault, <a href="#hevea_default926">11.10</a>
</li><li class="li-indexenv">sintassi, <a href="#hevea_default1366">17.2</a>
</li><li class="li-indexenv">sort, <a href="#hevea_default709">10.6</a>, <a href="#hevea_default779">10.13</a>, <a href="#hevea_default1493">18.6</a>
</li><li class="li-indexenv">split, <a href="#hevea_default742">10.9</a>, <a href="#hevea_default964">12.2</a>
</li><li class="li-indexenv">stringa, <a href="#hevea_default590">8.13</a>
</li><li class="li-indexenv">strip, <a href="#hevea_default609">9.1</a>, <a href="#hevea_default1062">13.1</a>
</li><li class="li-indexenv">translate, <a href="#hevea_default1066">13.1</a>
</li><li class="li-indexenv">update, <a href="#hevea_default1015">12.6</a>
</li><li class="li-indexenv">values, <a href="#hevea_default841">11.1</a>
</li><li class="li-indexenv">vuoto, <a href="#hevea_default710">10.6</a>
</li></ul>
</li><li class="li-indexenv">metodo di Newton, <a href="#hevea_default481">7.5</a>
</li><li class="li-indexenv">min, funzione, <a href="#hevea_default975">12.3</a>, <a href="#hevea_default988">12.4</a>
</li><li class="li-indexenv">minestrone, <a href="#hevea_default1103">13.8</a>
</li><li class="li-indexenv">modalità interattiva, <a href="#hevea_default102">2.4</a>, <a href="#hevea_default134">2.9</a>, <a href="#hevea_default212">3.10</a>
</li><li class="li-indexenv">modalità script, <a href="#hevea_default101">2.4</a>, <a href="#hevea_default103">2.4</a>, <a href="#hevea_default135">2.9</a>, <a href="#hevea_default213">3.10</a>
</li><li class="li-indexenv">modello di macchina, <a href="#hevea_default1688">B</a>, <a href="#hevea_default1731">B.5</a>
</li><li class="li-indexenv">modello mentale, <a href="#hevea_default1667">A.3.1</a>
</li><li class="li-indexenv">modificatore, <a href="#hevea_default1322">16.3</a>, <a href="#hevea_default1346">16.6</a>
</li><li class="li-indexenv">modulo, <a href="#hevea_default159">3.2</a>, <a href="#hevea_default236">3.13</a>, <a href="#hevea_default239">3.13</a>
<ul class="indexenv"><li class="li-indexenv">
bisect, <a href="#hevea_default820">10.15</a>
</li><li class="li-indexenv">collections, <a href="#hevea_default1583">19.6</a>, <a href="#hevea_default1587">19.7</a>, <a href="#hevea_default1595">19.8</a>
</li><li class="li-indexenv">copy, <a href="#hevea_default1275">15.6</a>
</li><li class="li-indexenv">datetime, <a href="#hevea_default1353">16.7</a>
</li><li class="li-indexenv">dbm, <a href="#hevea_default1168">14.6</a>
</li><li class="li-indexenv">os, <a href="#hevea_default1147">14.4</a>
</li><li class="li-indexenv">pickle, <a href="#hevea_default1128">14.1</a>, <a href="#hevea_default1181">14.7</a>
</li><li class="li-indexenv">pprint, <a href="#hevea_default900">11.8</a>
</li><li class="li-indexenv">profile, <a href="#hevea_default1109">13.9</a>
</li><li class="li-indexenv">random, <a href="#hevea_default808">10.15</a>, <a href="#hevea_default1075">13.2</a>, <a href="#hevea_default1489">18.6</a>
</li><li class="li-indexenv">reload, <a href="#hevea_default1205">14.9</a>, <a href="#hevea_default1630">A.1.1</a>
</li><li class="li-indexenv">shelve, <a href="#hevea_default1183">14.7</a>
</li><li class="li-indexenv">string, <a href="#hevea_default1060">13.1</a>
</li><li class="li-indexenv">structshape, <a href="#hevea_default1038">12.8</a>
</li></ul>
</li><li class="li-indexenv">modulo, operatore, <a href="#hevea_default301">5.1</a>, <a href="#hevea_default374">5.13</a>
</li><li class="li-indexenv">modulo, scrittura, <a href="#hevea_default1198">14.9</a>
</li><li class="li-indexenv">molteplicità (nel diagramma di classe), <a href="#hevea_default1510">18.8</a>, <a href="#hevea_default1538">18.11</a>
</li><li class="li-indexenv">mro, metodo, <a href="#hevea_default1514">18.9</a>
</li><li class="li-indexenv">multiinsieme, <a href="#hevea_default1581">19.6</a>
</li><li class="li-indexenv">mutabilità, <a href="#hevea_default534">8.5</a>, <a href="#hevea_default661">10.2</a>, <a href="#hevea_default699">10.5</a>, <a href="#hevea_default763">10.11</a>, <a href="#hevea_default894">11.7</a>, <a href="#hevea_default940">12.1</a>, <a href="#hevea_default1026">12.7</a>, <a href="#hevea_default1270">15.5</a>
<br>
<br>
</li><li class="li-indexenv">NameError, <a href="#hevea_default202">3.8</a>, <a href="#hevea_default1644">A.2.3</a>
</li><li class="li-indexenv">NaN, <a href="#hevea_default1544">19.1</a>
</li><li class="li-indexenv">None, valore speciale, <a href="#hevea_default214">3.10</a>, <a href="#hevea_default234">3.13</a>, <a href="#hevea_default395">6.1</a>, <a href="#hevea_default711">10.6</a>, <a href="#hevea_default734">10.8</a>
</li><li class="li-indexenv">name, variabile predefinita, <a href="#hevea_default1203">14.9</a>
</li><li class="li-indexenv">namedtuple, <a href="#hevea_default1591">19.8</a>
</li><li class="li-indexenv">nidificata, lista, <a href="#hevea_default684">10.3</a>
</li><li class="li-indexenv">not, operatore, <a href="#hevea_default319">5.3</a>
</li><li class="li-indexenv">notazione a punto, <a href="#hevea_default162">3.2</a>, <a href="#hevea_default241">3.13</a>, <a href="#hevea_default558">8.8</a>
</li><li class="li-indexenv">numero casuale, <a href="#hevea_default1071">13.2</a>
<br>
<br>
</li><li class="li-indexenv">O-grande, notazione, <a href="#hevea_default1696">B.1</a>
</li><li class="li-indexenv">Obama, Barack, <a href="#hevea_default1683">B</a>
</li><li class="li-indexenv">Olin College, <a href="#hevea_default3">0</a>
</li><li class="li-indexenv">OverflowError, <a href="#hevea_default371">5.12</a>
</li><li class="li-indexenv">oggetto, <a href="#hevea_default539">8.5</a>, <a href="#hevea_default575">8.12</a>, <a href="#hevea_default749">10.10</a>, <a href="#hevea_default757">10.10</a>, <a href="#hevea_default796">10.14</a>
<ul class="indexenv"><li class="li-indexenv">
bytes, <a href="#hevea_default1175">14.6</a>, <a href="#hevea_default1226">14.11</a>
</li><li class="li-indexenv">Counter, <a href="#hevea_default1580">19.6</a>
</li><li class="li-indexenv">classe, <a href="#hevea_default1244">15.1</a>, <a href="#hevea_default1250">15.1</a>, <a href="#hevea_default1303">15.8</a>, <a href="#hevea_default1597">19.8</a>
</li><li class="li-indexenv">contenuto, <a href="#hevea_default1437">17.13</a>
</li><li class="li-indexenv">copia, <a href="#hevea_default1273">15.6</a>
</li><li class="li-indexenv">database, <a href="#hevea_default1172">14.6</a>
</li><li class="li-indexenv">defaultdict, <a href="#hevea_default1585">19.7</a>
</li><li class="li-indexenv">enumerate, <a href="#hevea_default1005">12.5</a>
</li><li class="li-indexenv">file, <a href="#hevea_default605">9.1</a>, <a href="#hevea_default635">9.6</a>
</li><li class="li-indexenv">funzione, <a href="#hevea_default187">3.4</a>, <a href="#hevea_default224">3.13</a>, <a href="#hevea_default250">3.14</a>
</li><li class="li-indexenv">generatore, <a href="#hevea_default1561">19.3</a>
</li><li class="li-indexenv">modulo, <a href="#hevea_default160">3.2</a>, <a href="#hevea_default1200">14.9</a>
</li><li class="li-indexenv">mutabile, <a href="#hevea_default1269">15.5</a>
</li><li class="li-indexenv">namedtuple, <a href="#hevea_default1593">19.8</a>
</li><li class="li-indexenv">pipe, <a href="#hevea_default1229">14.11</a>
</li><li class="li-indexenv">set, <a href="#hevea_default1575">19.5</a>
</li><li class="li-indexenv">stampa, <a href="#hevea_default1362">17.2</a>
</li><li class="li-indexenv">zip, <a href="#hevea_default1045">12.9</a>
</li></ul>
</li><li class="li-indexenv">oggetto contenuto (embedded), <a href="#hevea_default1266">15.3</a>, <a href="#hevea_default1308">15.8</a>
<ul class="indexenv"><li class="li-indexenv">
copia, <a href="#hevea_default1280">15.6</a>
</li></ul>
</li><li class="li-indexenv">oggetto mutabile, come valore di default, <a href="#hevea_default1430">17.13</a>
</li><li class="li-indexenv">omofono, <a href="#hevea_default934">11.10</a>
</li><li class="li-indexenv">open, funzione, <a href="#hevea_default602">9.1</a>, <a href="#hevea_default610">9.1</a>, <a href="#hevea_default1130">14.2</a>, <a href="#hevea_default1157">14.5</a>, <a href="#hevea_default1169">14.6</a>
</li><li class="li-indexenv">operando, <a href="#hevea_default129">2.9</a>
</li><li class="li-indexenv">operator overloading, <a href="#hevea_default1393">17.7</a>, <a href="#hevea_default1425">17.12</a>, <a href="#hevea_default1461">18.3</a>
</li><li class="li-indexenv">operatore, <a href="#hevea_default72">1.8</a>
<ul class="indexenv"><li class="li-indexenv">
and, <a href="#hevea_default320">5.3</a>
</li><li class="li-indexenv">aritmetico, <a href="#hevea_default27">1.4</a>
</li><li class="li-indexenv">bitwise, <a href="#hevea_default30">1.4</a>
</li><li class="li-indexenv">booleano, <a href="#hevea_default564">8.9</a>
</li><li class="li-indexenv">confronto, <a href="#hevea_default314">5.2</a>
</li><li class="li-indexenv">del, <a href="#hevea_default731">10.8</a>
</li><li class="li-indexenv">di aggiornamento, <a href="#hevea_default714">10.7</a>
</li><li class="li-indexenv">di formato, <a href="#hevea_default1135">14.3</a>, <a href="#hevea_default1215">14.11</a>, <a href="#hevea_default1650">A.2.3</a>
</li><li class="li-indexenv">di slicing, <a href="#hevea_default527">8.4</a>, <a href="#hevea_default597">8.13</a>, <a href="#hevea_default692">10.5</a>, <a href="#hevea_default776">10.12</a>, <a href="#hevea_default950">12.1</a>
</li><li class="li-indexenv">in, <a href="#hevea_default562">8.9</a>, <a href="#hevea_default619">9.3</a>, <a href="#hevea_default674">10.2</a>, <a href="#hevea_default839">11.1</a>
</li><li class="li-indexenv">is, <a href="#hevea_default753">10.10</a>, <a href="#hevea_default1277">15.6</a>
</li><li class="li-indexenv">logico, <a href="#hevea_default306">5.2</a>, <a href="#hevea_default316">5.3</a>
</li><li class="li-indexenv">modulo, <a href="#hevea_default302">5.1</a>, <a href="#hevea_default375">5.13</a>
</li><li class="li-indexenv">not, <a href="#hevea_default322">5.3</a>
</li><li class="li-indexenv">or, <a href="#hevea_default321">5.3</a>
</li><li class="li-indexenv">parentesi quadre, <a href="#hevea_default506">8.1</a>, <a href="#hevea_default660">10.2</a>, <a href="#hevea_default948">12.1</a>
</li><li class="li-indexenv">relazionale, <a href="#hevea_default1458">18.3</a>
</li><li class="li-indexenv">stringa, <a href="#hevea_default107">2.6</a>
</li></ul>
</li><li class="li-indexenv">operazione dominante, <a href="#hevea_default1692">B.1</a>, <a href="#hevea_default1733">B.5</a>
</li><li class="li-indexenv">opzionale, argomento, <a href="#hevea_default587">8.12</a>, <a href="#hevea_default591">8.13</a>, <a href="#hevea_default1548">19.1</a>
</li><li class="li-indexenv">or, operatore, <a href="#hevea_default318">5.3</a>
</li><li class="li-indexenv">ordinamento, <a href="#hevea_default1709">B.2</a>, <a href="#hevea_default1712">B.2</a>
</li><li class="li-indexenv">ordine delle operazioni, <a href="#hevea_default104">2.5</a>, <a href="#hevea_default137">2.9</a>, <a href="#hevea_default1670">A.3.2</a>
</li><li class="li-indexenv">ordine di risoluzione dei metodi, <a href="#hevea_default1516">18.9</a>
</li><li class="li-indexenv">os, modulo, <a href="#hevea_default1146">14.4</a>
</li><li class="li-indexenv">other (nome di parametro), <a href="#hevea_default1376">17.4</a>
</li><li class="li-indexenv">overloading, <a href="#hevea_default1424">17.12</a>
<br>
<br>
</li><li class="li-indexenv">PEMDAS, <a href="#hevea_default105">2.5</a>
</li><li class="li-indexenv">Progetto Gutenberg, <a href="#hevea_default1067">13.1</a>
</li><li class="li-indexenv">Punto, classe, <a href="#hevea_default1247">15.1</a>, <a href="#hevea_default1383">17.5</a>
</li><li class="li-indexenv">Puzzler, <a href="#hevea_default643">9.7</a>, <a href="#hevea_default647">9.7</a>, <a href="#hevea_default933">11.10</a>, <a href="#hevea_default1056">12.10</a>
</li><li class="li-indexenv">Python<ul class="indexenv"><li class="li-indexenv">
avvio, <a href="#hevea_default14">1.2</a>
</li></ul>
</li><li class="li-indexenv">Python 2, <a href="#hevea_default17">1.2</a>, <a href="#hevea_default26">1.3</a>, <a href="#hevea_default265">4.5</a>, <a href="#hevea_default304">5.1</a>, <a href="#hevea_default359">5.11</a>
</li><li class="li-indexenv">Python in un browser, <a href="#hevea_default15">1.2</a>
</li><li class="li-indexenv">PythonAnywhere, <a href="#hevea_default16">1.2</a>
</li><li class="li-indexenv">palindromo, <a href="#hevea_default456">6.11</a>, <a href="#hevea_default598">8.13</a>, <a href="#hevea_default626">9.4</a>, <a href="#hevea_default645">9.7</a>, <a href="#hevea_default648">9.7</a>
</li><li class="li-indexenv">parametri, <a href="#hevea_default204">3.8</a>
</li><li class="li-indexenv">parametro, <a href="#hevea_default191">3.7</a>, <a href="#hevea_default227">3.13</a>, <a href="#hevea_default769">10.12</a>
<ul class="indexenv"><li class="li-indexenv">
opzionale, <a href="#hevea_default1088">13.5</a>, <a href="#hevea_default1380">17.5</a>
</li><li class="li-indexenv">other, <a href="#hevea_default1377">17.4</a>
</li><li class="li-indexenv">raccolta, <a href="#hevea_default980">12.4</a>
</li><li class="li-indexenv">self, <a href="#hevea_default1369">17.2</a>
</li></ul>
</li><li class="li-indexenv">parentesi<ul class="indexenv"><li class="li-indexenv">
argomento in, <a href="#hevea_default148">3.1</a>
</li><li class="li-indexenv">classe madre in, <a href="#hevea_default1496">18.7</a>
</li><li class="li-indexenv">corrispondenza, <a href="#hevea_default116">2.8.1</a>
</li><li class="li-indexenv">graffe, <a href="#hevea_default832">11.1</a>
</li><li class="li-indexenv">parametri in, <a href="#hevea_default195">3.7</a>, <a href="#hevea_default200">3.8</a>
</li><li class="li-indexenv">tuple in, <a href="#hevea_default942">12.1</a>
</li><li class="li-indexenv">vuote, <a href="#hevea_default180">3.4</a>, <a href="#hevea_default557">8.8</a>
</li></ul>
</li><li class="li-indexenv">parentesi quadre, operatore, <a href="#hevea_default505">8.1</a>, <a href="#hevea_default659">10.2</a>, <a href="#hevea_default947">12.1</a>
</li><li class="li-indexenv">parola chiave, <a href="#hevea_default95">2.2</a>, <a href="#hevea_default128">2.9</a>, <a href="#hevea_default1622">A.1</a>
<ul class="indexenv"><li class="li-indexenv">
def, <a href="#hevea_default178">3.4</a>
</li><li class="li-indexenv">elif, <a href="#hevea_default338">5.6</a>
</li><li class="li-indexenv">else, <a href="#hevea_default333">5.5</a>
</li></ul>
</li><li class="li-indexenv">parola, frequenza, <a href="#hevea_default1069">13.1</a>
</li><li class="li-indexenv">parola, riducibile, <a href="#hevea_default936">11.10</a>, <a href="#hevea_default1057">12.10</a>
</li><li class="li-indexenv">parsing, <a href="#hevea_default52">1.6</a>, <a href="#hevea_default83">1.8</a>
</li><li class="li-indexenv">pass, istruzione, <a href="#hevea_default329">5.4</a>
</li><li class="li-indexenv">pdb (Python debugger), <a href="#hevea_default1659">A.2.3</a>
</li><li class="li-indexenv">peggior bug, <a href="#hevea_default1431">17.13</a>
</li><li class="li-indexenv">percorso, <a href="#hevea_default1143">14.4</a>, <a href="#hevea_default1220">14.11</a>
<ul class="indexenv"><li class="li-indexenv">
assoluto, <a href="#hevea_default1153">14.4</a>, <a href="#hevea_default1222">14.11</a>
</li><li class="li-indexenv">relativo, <a href="#hevea_default1152">14.4</a>, <a href="#hevea_default1221">14.11</a>
</li></ul>
</li><li class="li-indexenv">permesso, accesso a file, <a href="#hevea_default1162">14.5</a>
</li><li class="li-indexenv">persistenza, <a href="#hevea_default1126">14.1</a>, <a href="#hevea_default1214">14.11</a>
</li><li class="li-indexenv">pi, <a href="#hevea_default168">3.2</a>, <a href="#hevea_default502">7.9</a>
</li><li class="li-indexenv">pickle, modulo, <a href="#hevea_default1127">14.1</a>, <a href="#hevea_default1180">14.7</a>
</li><li class="li-indexenv">pickling, <a href="#hevea_default1179">14.7</a>
</li><li class="li-indexenv">pipe, <a href="#hevea_default1185">14.8</a>
</li><li class="li-indexenv">pipe, oggetto, <a href="#hevea_default1228">14.11</a>
</li><li class="li-indexenv">poesia, <a href="#hevea_default56">1.6</a>
</li><li class="li-indexenv">poker, <a href="#hevea_default1439">18</a>, <a href="#hevea_default1541">18.12</a>
</li><li class="li-indexenv">poligono, funzione, <a href="#hevea_default257">4.3</a>
</li><li class="li-indexenv">polimorfismo, <a href="#hevea_default1401">17.9</a>, <a href="#hevea_default1427">17.12</a>
</li><li class="li-indexenv">pop, metodo, <a href="#hevea_default728">10.8</a>, <a href="#hevea_default1483">18.6</a>
</li><li class="li-indexenv">popen, funzione, <a href="#hevea_default1188">14.8</a>
</li><li class="li-indexenv">portabilità, <a href="#hevea_default66">1.8</a>
</li><li class="li-indexenv">posizionale, argomento, <a href="#hevea_default1374">17.3</a>, <a href="#hevea_default1422">17.12</a>, <a href="#hevea_default1600">19.9</a>
</li><li class="li-indexenv">postcondizione, <a href="#hevea_default279">4.10</a>, <a href="#hevea_default291">4.11</a>, <a href="#hevea_default445">6.9</a>, <a href="#hevea_default1520">18.9</a>
</li><li class="li-indexenv">potenziata, assegnazione, <a href="#hevea_default716">10.7</a>
</li><li class="li-indexenv">pprint, modulo, <a href="#hevea_default899">11.8</a>
</li><li class="li-indexenv">precedenza, <a href="#hevea_default1671">A.3.2</a>
</li><li class="li-indexenv">precondizione, <a href="#hevea_default278">4.10</a>, <a href="#hevea_default290">4.11</a>, <a href="#hevea_default444">6.9</a>, <a href="#hevea_default1519">18.9</a>
</li><li class="li-indexenv">prefisso, <a href="#hevea_default1099">13.8</a>
</li><li class="li-indexenv">print, funzione, <a href="#hevea_default25">1.3</a>
</li><li class="li-indexenv">profile, modulo, <a href="#hevea_default1108">13.9</a>
</li><li class="li-indexenv">profonda, copia, <a href="#hevea_default1285">15.6</a>
</li><li class="li-indexenv">progettazione<ul class="indexenv"><li class="li-indexenv">
orientata agli oggetti, <a href="#hevea_default1416">17.11</a>
</li></ul>
</li><li class="li-indexenv">programma, <a href="#hevea_default11">1.1</a>, <a href="#hevea_default69">1.8</a>
<ul class="indexenv"><li class="li-indexenv">
test, <a href="#hevea_default631">9.5</a>
</li></ul>
</li><li class="li-indexenv">programmazione<ul class="indexenv"><li class="li-indexenv">
a tentoni, <a href="#hevea_default1679">A.3.4</a>
</li><li class="li-indexenv">orientata agli oggetti, <a href="#hevea_default1239">15</a>, <a href="#hevea_default1356">17.1</a>, <a href="#hevea_default1419">17.12</a>, <a href="#hevea_default1495">18.7</a>
</li></ul>
</li><li class="li-indexenv">prompt, <a href="#hevea_default19">1.2</a>, <a href="#hevea_default68">1.8</a>, <a href="#hevea_default362">5.11</a>
</li><li class="li-indexenv">prosa, <a href="#hevea_default57">1.6</a>
</li><li class="li-indexenv">prototipo ed evoluzioni, <a href="#hevea_default1317">16.2</a>, <a href="#hevea_default1327">16.4</a>, <a href="#hevea_default1343">16.6</a>
</li><li class="li-indexenv">pseudocasuale, <a href="#hevea_default1073">13.2</a>, <a href="#hevea_default1115">13.11</a>
</li><li class="li-indexenv">punto di intersezione, <a href="#hevea_default1695">B.1</a>
</li><li class="li-indexenv">punto, matematico, <a href="#hevea_default1241">15.1</a>
<br>
<br>
</li><li class="li-indexenv">quadratico, <a href="#hevea_default1738">B.5</a>
</li><li class="li-indexenv">quesito, <a href="#hevea_default640">9.7</a>
<br>
<br>
</li><li class="li-indexenv">Ramanujan, Srinivasa, <a href="#hevea_default501">7.9</a>
</li><li class="li-indexenv">RB-albero, <a href="#hevea_default1722">B.4</a>
</li><li class="li-indexenv">Rettangolo, classe, <a href="#hevea_default1262">15.3</a>
</li><li class="li-indexenv">RuntimeError, <a href="#hevea_default357">5.10</a>, <a href="#hevea_default435">6.8</a>
</li><li class="li-indexenv">rabbia, <a href="#hevea_default1675">A.3.4</a>
</li><li class="li-indexenv">raccolta, <a href="#hevea_default979">12.4</a>, <a href="#hevea_default1042">12.9</a>, <a href="#hevea_default1599">19.9</a>
</li><li class="li-indexenv">radd, metodo, <a href="#hevea_default1398">17.8</a>
</li><li class="li-indexenv">radiante, <a href="#hevea_default166">3.2</a>
</li><li class="li-indexenv">radice quadrata, <a href="#hevea_default480">7.5</a>
</li><li class="li-indexenv">radix sort, <a href="#hevea_default1686">B</a>
</li><li class="li-indexenv">raise, istruzione, <a href="#hevea_default862">11.4</a>, <a href="#hevea_default1339">16.5</a>
</li><li class="li-indexenv">ramificazione, <a href="#hevea_default334">5.5</a>, <a href="#hevea_default380">5.13</a>
</li><li class="li-indexenv">randint, funzione, <a href="#hevea_default809">10.15</a>, <a href="#hevea_default1078">13.2</a>
</li><li class="li-indexenv">random, funzione, <a href="#hevea_default1076">13.2</a>
</li><li class="li-indexenv">random, modulo, <a href="#hevea_default807">10.15</a>, <a href="#hevea_default1074">13.2</a>, <a href="#hevea_default1488">18.6</a>
</li><li class="li-indexenv">rappresentazione, <a href="#hevea_default1242">15.1</a>, <a href="#hevea_default1261">15.3</a>, <a href="#hevea_default1446">18.1</a>
<ul class="indexenv"><li class="li-indexenv">
di stringa, <a href="#hevea_default1387">17.6</a>
</li></ul>
</li><li class="li-indexenv">read, metodo, <a href="#hevea_default1192">14.8</a>
</li><li class="li-indexenv">readline, metodo, <a href="#hevea_default606">9.1</a>, <a href="#hevea_default1190">14.8</a>
</li><li class="li-indexenv">refactoring, <a href="#hevea_default268">4.7</a>, <a href="#hevea_default269">4.7</a>, <a href="#hevea_default286">4.11</a>, <a href="#hevea_default1524">18.10</a>
</li><li class="li-indexenv">rehashing, <a href="#hevea_default1726">B.4</a>
</li><li class="li-indexenv">reload, funzione, <a href="#hevea_default1206">14.9</a>, <a href="#hevea_default1631">A.1.1</a>
</li><li class="li-indexenv">remove, metodo, <a href="#hevea_default732">10.8</a>
</li><li class="li-indexenv">replace, metodo, <a href="#hevea_default1063">13.1</a>
</li><li class="li-indexenv">repr, funzione, <a href="#hevea_default1210">14.10</a>
</li><li class="li-indexenv">return, istruzione, <a href="#hevea_default344">5.8</a>, <a href="#hevea_default391">6.1</a>, <a href="#hevea_default1672">A.3.3</a>
</li><li class="li-indexenv">reversed, funzione, <a href="#hevea_default1030">12.7</a>
</li><li class="li-indexenv">riassegnazione, <a href="#hevea_default461">7.1</a>, <a href="#hevea_default489">7.8</a>, <a href="#hevea_default667">10.2</a>, <a href="#hevea_default885">11.7</a>
</li><li class="li-indexenv">ricerca, <a href="#hevea_default860">11.4</a>, <a href="#hevea_default1715">B.3</a>, <a href="#hevea_default1739">B.5</a>
<ul class="indexenv"><li class="li-indexenv">
binaria, <a href="#hevea_default816">10.15</a>, <a href="#hevea_default818">10.15</a>, <a href="#hevea_default1718">B.3</a>
</li><li class="li-indexenv">lineare, <a href="#hevea_default1716">B.3</a>
</li><li class="li-indexenv">schema, <a href="#hevea_default1570">19.4</a>
</li><li class="li-indexenv">schema di, <a href="#hevea_default548">8.6</a>, <a href="#hevea_default583">8.12</a>, <a href="#hevea_default615">9.3</a>
</li></ul>
</li><li class="li-indexenv">ricorsione, <a href="#hevea_default340">5.8</a>, <a href="#hevea_default342">5.8</a>, <a href="#hevea_default383">5.13</a>, <a href="#hevea_default414">6.5</a>, <a href="#hevea_default426">6.6</a>
<ul class="indexenv"><li class="li-indexenv">
caso base, <a href="#hevea_default352">5.9</a>
</li><li class="li-indexenv">infinita, <a href="#hevea_default353">5.10</a>, <a href="#hevea_default385">5.13</a>, <a href="#hevea_default436">6.8</a>, <a href="#hevea_default1634">A.2.2</a>, <a href="#hevea_default1639">A.2.2</a>
</li></ul>
</li><li class="li-indexenv">ridimensionamento geometrico, <a href="#hevea_default1729">B.4</a>
</li><li class="li-indexenv">ridondanza, <a href="#hevea_default54">1.6</a>
</li><li class="li-indexenv">riducibile, parola, <a href="#hevea_default935">11.10</a>
</li><li class="li-indexenv">riduzione ad un problema già risolto, <a href="#hevea_default622">9.3</a>, <a href="#hevea_default627">9.4</a>, <a href="#hevea_default636">9.6</a>
</li><li class="li-indexenv">riduzione, schema, <a href="#hevea_default718">10.7</a>, <a href="#hevea_default790">10.14</a>
</li><li class="li-indexenv">riferimento, <a href="#hevea_default762">10.11</a>, <a href="#hevea_default768">10.12</a>, <a href="#hevea_default799">10.14</a>
<ul class="indexenv"><li class="li-indexenv">
alias, <a href="#hevea_default760">10.11</a>
</li></ul>
</li><li class="li-indexenv">ripetizione, <a href="#hevea_default252">4.2</a>
<ul class="indexenv"><li class="li-indexenv">
lista, <a href="#hevea_default689">10.4</a>
</li></ul>
</li><li class="li-indexenv">risoluzione di problemi, <a href="#hevea_default10">1</a>
</li><li class="li-indexenv">ritorno a capo, <a href="#hevea_default363">5.11</a>, <a href="#hevea_default1482">18.5</a>
</li><li class="li-indexenv">rotazione<ul class="indexenv"><li class="li-indexenv">
lettere, <a href="#hevea_default931">11.10</a>
</li></ul>
</li><li class="li-indexenv">rotazione di lettere, <a href="#hevea_default599">8.13</a>
</li><li class="li-indexenv">runtime<ul class="indexenv"><li class="li-indexenv">
errore di, <a href="#hevea_default1614">A</a>
</li></ul>
<br>
<br>
</li><li class="li-indexenv">Scarabeo, <a href="#hevea_default1053">12.10</a>
</li><li class="li-indexenv">Schmidt, Eric, <a href="#hevea_default1684">B</a>
</li><li class="li-indexenv">StopIteration, <a href="#hevea_default1562">19.3</a>
</li><li class="li-indexenv">SyntaxError, <a href="#hevea_default172">3.3</a>
</li><li class="li-indexenv">salto sulla fiducia, <a href="#hevea_default427">6.6</a>
</li><li class="li-indexenv">scambio, schema di, <a href="#hevea_default959">12.2</a>
</li><li class="li-indexenv">schema<ul class="indexenv"><li class="li-indexenv">
di ricerca, <a href="#hevea_default549">8.6</a>, <a href="#hevea_default584">8.12</a>, <a href="#hevea_default616">9.3</a>, <a href="#hevea_default861">11.4</a>
</li><li class="li-indexenv">di scambio, <a href="#hevea_default960">12.2</a>
</li><li class="li-indexenv">filtro, <a href="#hevea_default725">10.7</a>, <a href="#hevea_default795">10.14</a>, <a href="#hevea_default1557">19.2</a>
</li><li class="li-indexenv">guardiani, <a href="#hevea_default441">6.8</a>, <a href="#hevea_default570">8.11</a>
</li><li class="li-indexenv">mappa, <a href="#hevea_default723">10.7</a>, <a href="#hevea_default793">10.14</a>
</li><li class="li-indexenv">riduzione, <a href="#hevea_default719">10.7</a>, <a href="#hevea_default791">10.14</a>
</li></ul>
</li><li class="li-indexenv">schema di ricerca, <a href="#hevea_default1569">19.4</a>
</li><li class="li-indexenv">script, <a href="#hevea_default100">2.4</a>, <a href="#hevea_default136">2.9</a>
</li><li class="li-indexenv">self (nome di parametro), <a href="#hevea_default1368">17.2</a>
</li><li class="li-indexenv">semantica, <a href="#hevea_default121">2.8.3</a>, <a href="#hevea_default142">2.9</a>, <a href="#hevea_default1360">17.1</a>
<ul class="indexenv"><li class="li-indexenv">
errore di, <a href="#hevea_default122">2.8.3</a>, <a href="#hevea_default143">2.9</a>, <a href="#hevea_default1616">A</a>, <a href="#hevea_default1665">A.3</a>
</li></ul>
</li><li class="li-indexenv">seme, <a href="#hevea_default1442">18.1</a>
</li><li class="li-indexenv">seno, funzione, <a href="#hevea_default165">3.2</a>
</li><li class="li-indexenv">sequenza, <a href="#hevea_default46">1.5</a>, <a href="#hevea_default503">8</a>, <a href="#hevea_default576">8.12</a>, <a href="#hevea_default652">10.1</a>, <a href="#hevea_default738">10.9</a>, <a href="#hevea_default939">12.1</a>, <a href="#hevea_default1022">12.7</a>
<ul class="indexenv"><li class="li-indexenv">
di formato, <a href="#hevea_default1139">14.3</a>, <a href="#hevea_default1217">14.11</a>
</li></ul>
</li><li class="li-indexenv">serie, condizioni in, <a href="#hevea_default335">5.6</a>
</li><li class="li-indexenv">sessagesimale, <a href="#hevea_default1331">16.4</a>
</li><li class="li-indexenv">setdefault, <a href="#hevea_default1589">19.7</a>
</li><li class="li-indexenv">setdefault, metodo, <a href="#hevea_default925">11.10</a>
</li><li class="li-indexenv">shallow, copia, <a href="#hevea_default1283">15.6</a>
</li><li class="li-indexenv">shell, <a href="#hevea_default1184">14.8</a>, <a href="#hevea_default1227">14.11</a>
</li><li class="li-indexenv">shelve, modulo, <a href="#hevea_default1182">14.7</a>
</li><li class="li-indexenv">shuffle, funzione, <a href="#hevea_default1490">18.6</a>
</li><li class="li-indexenv">simbolo, <a href="#hevea_default49">1.6</a>, <a href="#hevea_default80">1.8</a>
</li><li class="li-indexenv">singleton, <a href="#hevea_default869">11.5</a>, <a href="#hevea_default914">11.9</a>, <a href="#hevea_default943">12.1</a>
</li><li class="li-indexenv">sintassi, <a href="#hevea_default82">1.8</a>, <a href="#hevea_default115">2.8.1</a>, <a href="#hevea_default1359">17.1</a>, <a href="#hevea_default1621">A.1</a>
<ul class="indexenv"><li class="li-indexenv">
errore di, <a href="#hevea_default112">2.8.1</a>, <a href="#hevea_default140">2.9</a>, <a href="#hevea_default1610">A</a>
</li></ul>
</li><li class="li-indexenv">slice, <a href="#hevea_default579">8.12</a>
</li><li class="li-indexenv">slicing<ul class="indexenv"><li class="li-indexenv">
aggiornamento, <a href="#hevea_default700">10.5</a>
</li><li class="li-indexenv">copia, <a href="#hevea_default533">8.4</a>, <a href="#hevea_default697">10.5</a>
</li><li class="li-indexenv">lista, <a href="#hevea_default695">10.5</a>
</li><li class="li-indexenv">operatore di, <a href="#hevea_default526">8.4</a>, <a href="#hevea_default596">8.13</a>, <a href="#hevea_default691">10.5</a>, <a href="#hevea_default775">10.12</a>, <a href="#hevea_default949">12.1</a>
</li><li class="li-indexenv">stringa, <a href="#hevea_default530">8.4</a>
</li><li class="li-indexenv">tupla, <a href="#hevea_default952">12.1</a>
</li></ul>
</li><li class="li-indexenv">smistamento in base al tipo, <a href="#hevea_default1396">17.8</a>, <a href="#hevea_default1400">17.9</a>, <a href="#hevea_default1426">17.12</a>
</li><li class="li-indexenv">soggetto, <a href="#hevea_default1367">17.2</a>, <a href="#hevea_default1421">17.12</a>
</li><li class="li-indexenv">soluzione di problemi, <a href="#hevea_default63">1.8</a>
</li><li class="li-indexenv">sort, metodo, <a href="#hevea_default708">10.6</a>, <a href="#hevea_default778">10.13</a>, <a href="#hevea_default1492">18.6</a>
</li><li class="li-indexenv">sorted<ul class="indexenv"><li class="li-indexenv">
funzione, <a href="#hevea_default782">10.13</a>
</li></ul>
</li><li class="li-indexenv">sorted, funzione, <a href="#hevea_default854">11.3</a>, <a href="#hevea_default1028">12.7</a>
</li><li class="li-indexenv">sottoinsieme, <a href="#hevea_default1578">19.5</a>
</li><li class="li-indexenv">sottrazione<ul class="indexenv"><li class="li-indexenv">
con prestito, <a href="#hevea_default487">7.6</a>, <a href="#hevea_default1335">16.4</a>
</li><li class="li-indexenv">di dizionari, <a href="#hevea_default1573">19.5</a>
</li><li class="li-indexenv">di insiemi, <a href="#hevea_default1576">19.5</a>
</li><li class="li-indexenv">dizionario, <a href="#hevea_default1093">13.6</a>
</li></ul>
</li><li class="li-indexenv">sovrascrittura, <a href="#hevea_default1091">13.5</a>, <a href="#hevea_default1117">13.11</a>, <a href="#hevea_default1382">17.5</a>, <a href="#hevea_default1460">18.3</a>, <a href="#hevea_default1503">18.7</a>, <a href="#hevea_default1517">18.9</a>
</li><li class="li-indexenv">spacchettamento, <a href="#hevea_default982">12.4</a>, <a href="#hevea_default1043">12.9</a>, <a href="#hevea_default1603">19.9</a>
</li><li class="li-indexenv">spazi, <a href="#hevea_default1629">A.1</a>
</li><li class="li-indexenv">spaziatore, <a href="#hevea_default368">5.12</a>, <a href="#hevea_default612">9.2</a>, <a href="#hevea_default1209">14.10</a>
</li><li class="li-indexenv">spirale, <a href="#hevea_default297">4.12</a>
</li><li class="li-indexenv">spirale di Archimede, <a href="#hevea_default298">4.12</a>
</li><li class="li-indexenv">split, metodo, <a href="#hevea_default741">10.9</a>, <a href="#hevea_default963">12.2</a>
</li><li class="li-indexenv">sqrt, funzione, <a href="#hevea_default169">3.2</a>, <a href="#hevea_default405">6.2</a>
</li><li class="li-indexenv">stable sort, <a href="#hevea_default1714">B.2</a>
</li><li class="li-indexenv">stampa, istruzione di, <a href="#hevea_default22">1.3</a>, <a href="#hevea_default70">1.8</a>, <a href="#hevea_default1388">17.6</a>, <a href="#hevea_default1660">A.2.4</a>
</li><li class="li-indexenv">step, ampiezza, <a href="#hevea_default595">8.13</a>
</li><li class="li-indexenv">stile di programmazione funzionale, <a href="#hevea_default1326">16.3</a>, <a href="#hevea_default1347">16.6</a>
</li><li class="li-indexenv">__str__, metodo, <a href="#hevea_default1385">17.6</a>, <a href="#hevea_default1476">18.5</a>
</li><li class="li-indexenv">str, funzione, <a href="#hevea_default156">3.1</a>
</li><li class="li-indexenv">string, modulo, <a href="#hevea_default1059">13.1</a>
</li><li class="li-indexenv">string, tipo, <a href="#hevea_default39">1.5</a>
</li><li class="li-indexenv">stringa, <a href="#hevea_default33">1.5</a>, <a href="#hevea_default36">1.5</a>, <a href="#hevea_default77">1.8</a>, <a href="#hevea_default737">10.9</a>, <a href="#hevea_default1023">12.7</a>
<ul class="indexenv"><li class="li-indexenv">
a righe multiple, <a href="#hevea_default275">4.9</a>, <a href="#hevea_default1626">A.1</a>
</li><li class="li-indexenv">accumulatore, <a href="#hevea_default1479">18.5</a>
</li><li class="li-indexenv">concatenamento, <a href="#hevea_default1706">B.2</a>
</li><li class="li-indexenv">confronto, <a href="#hevea_default565">8.10</a>
</li><li class="li-indexenv">di documentazione, <a href="#hevea_default272">4.9</a>
</li><li class="li-indexenv">di formato, <a href="#hevea_default1137">14.3</a>, <a href="#hevea_default1216">14.11</a>
</li><li class="li-indexenv">documentazione, <a href="#hevea_default289">4.11</a>
</li><li class="li-indexenv">immutabile, <a href="#hevea_default536">8.5</a>
</li><li class="li-indexenv">metodi, <a href="#hevea_default556">8.8</a>, <a href="#hevea_default589">8.13</a>, <a href="#hevea_default1704">B.2</a>
</li><li class="li-indexenv">operazioni, <a href="#hevea_default106">2.6</a>
</li><li class="li-indexenv">rappresentazione, <a href="#hevea_default1212">14.10</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default529">8.4</a>
</li><li class="li-indexenv">triple virgolette, <a href="#hevea_default274">4.9</a>
</li><li class="li-indexenv">vuota, <a href="#hevea_default580">8.12</a>, <a href="#hevea_default748">10.9</a>
</li></ul>
</li><li class="li-indexenv">strip, metodo, <a href="#hevea_default608">9.1</a>, <a href="#hevea_default1061">13.1</a>
</li><li class="li-indexenv">structshape, modulo, <a href="#hevea_default1037">12.8</a>
</li><li class="li-indexenv">struttura, <a href="#hevea_default51">1.6</a>
</li><li class="li-indexenv">struttura di dati, <a href="#hevea_default1034">12.8</a>, <a href="#hevea_default1047">12.9</a>, <a href="#hevea_default1104">13.9</a>
</li><li class="li-indexenv">suffisso, <a href="#hevea_default1100">13.8</a>
</li><li class="li-indexenv">sum, funzione, <a href="#hevea_default990">12.4</a>, <a href="#hevea_default1564">19.3</a>
</li><li class="li-indexenv">sviluppo incrementale, <a href="#hevea_default449">6.10</a>, <a href="#hevea_default1619">A.1</a>
</li><li class="li-indexenv">sviluppo pianificato, <a href="#hevea_default1329">16.4</a>, <a href="#hevea_default1344">16.6</a>
<br>
<br>
</li><li class="li-indexenv">Tempo, classe, <a href="#hevea_default1313">16.1</a>
</li><li class="li-indexenv">Tesi di Turing, <a href="#hevea_default417">6.5</a>
</li><li class="li-indexenv">True, valore speciale, <a href="#hevea_default307">5.2</a>
</li><li class="li-indexenv">Turing, Alan, <a href="#hevea_default416">6.5</a>
</li><li class="li-indexenv">TypeError, <a href="#hevea_default512">8.1</a>, <a href="#hevea_default537">8.5</a>, <a href="#hevea_default871">11.5</a>, <a href="#hevea_default954">12.1</a>, <a href="#hevea_default984">12.4</a>, <a href="#hevea_default1141">14.3</a>, <a href="#hevea_default1373">17.3</a>, <a href="#hevea_default1646">A.2.3</a>
</li><li class="li-indexenv">tabella hash, <a href="#hevea_default842">11.1</a>, <a href="#hevea_default909">11.9</a>, <a href="#hevea_default1719">B.4</a>, <a href="#hevea_default1740">B.5</a>
</li><li class="li-indexenv">tecnica di sviluppo, <a href="#hevea_default287">4.11</a>
<ul class="indexenv"><li class="li-indexenv">
incapsulamento dei dati, <a href="#hevea_default1522">18.10</a>, <a href="#hevea_default1540">18.11</a>
</li><li class="li-indexenv">incapsulamento e generalizzazione, <a href="#hevea_default270">4.8</a>
</li><li class="li-indexenv">incrementale, <a href="#hevea_default401">6.2</a>, <a href="#hevea_default1620">A.1</a>
</li><li class="li-indexenv">pianificato, <a href="#hevea_default1330">16.4</a>
</li><li class="li-indexenv">programmazione a tentoni, <a href="#hevea_default1113">13.10</a>, <a href="#hevea_default1680">A.3.4</a>
</li><li class="li-indexenv">prototipo ed evoluzioni, <a href="#hevea_default1318">16.2</a>, <a href="#hevea_default1328">16.4</a>
</li><li class="li-indexenv">riduzione, <a href="#hevea_default623">9.3</a>, <a href="#hevea_default628">9.4</a>, <a href="#hevea_default637">9.6</a>
</li></ul>
</li><li class="li-indexenv">tempo costante, <a href="#hevea_default1727">B.4</a>
</li><li class="li-indexenv">teorema di Pitagora, <a href="#hevea_default403">6.2</a>
</li><li class="li-indexenv">test<ul class="indexenv"><li class="li-indexenv">
caso di prova minimo, <a href="#hevea_default1663">A.2.4</a>
</li><li class="li-indexenv">difficoltà, <a href="#hevea_default630">9.5</a>
</li><li class="li-indexenv">e assenza di bug, <a href="#hevea_default633">9.5</a>
</li><li class="li-indexenv">salto sulla fiducia, <a href="#hevea_default428">6.6</a>
</li><li class="li-indexenv">sapere il risultato, <a href="#hevea_default404">6.2</a>
</li><li class="li-indexenv">sviluppo incrementale, <a href="#hevea_default402">6.2</a>
</li></ul>
</li><li class="li-indexenv">testo<ul class="indexenv"><li class="li-indexenv">
casuale, <a href="#hevea_default1102">13.8</a>
</li><li class="li-indexenv">semplice, <a href="#hevea_default604">9.1</a>, <a href="#hevea_default1068">13.1</a>
</li></ul>
</li><li class="li-indexenv">tipo, <a href="#hevea_default32">1.5</a>, <a href="#hevea_default38">1.5</a>
<ul class="indexenv"><li class="li-indexenv">
bool, <a href="#hevea_default312">5.2</a>
</li><li class="li-indexenv">dict, <a href="#hevea_default824">11.1</a>
</li><li class="li-indexenv">file, <a href="#hevea_default1125">14.1</a>
</li><li class="li-indexenv">float, <a href="#hevea_default44">1.5</a>
</li><li class="li-indexenv">function, <a href="#hevea_default186">3.4</a>
</li><li class="li-indexenv">int, <a href="#hevea_default42">1.5</a>
</li><li class="li-indexenv">list, <a href="#hevea_default650">10.1</a>
</li><li class="li-indexenv">personalizzato, <a href="#hevea_default1240">15.1</a>, <a href="#hevea_default1302">15.8</a>, <a href="#hevea_default1312">16.1</a>, <a href="#hevea_default1361">17.1</a>, <a href="#hevea_default1390">17.7</a>, <a href="#hevea_default1459">18.3</a>
</li><li class="li-indexenv">set, <a href="#hevea_default1095">13.6</a>
</li><li class="li-indexenv">str, <a href="#hevea_default40">1.5</a>
</li><li class="li-indexenv">tuple, <a href="#hevea_default938">12.1</a>
</li></ul>
</li><li class="li-indexenv">token, <a href="#hevea_default50">1.6</a>, <a href="#hevea_default81">1.8</a>
</li><li class="li-indexenv">torta, <a href="#hevea_default294">4.12</a>
</li><li class="li-indexenv">traceback, <a href="#hevea_default209">3.9</a>, <a href="#hevea_default247">3.13</a>, <a href="#hevea_default355">5.10</a>, <a href="#hevea_default367">5.12</a>, <a href="#hevea_default866">11.4</a>, <a href="#hevea_default1643">A.2.3</a>
</li><li class="li-indexenv">translate, metodo, <a href="#hevea_default1065">13.1</a>
</li><li class="li-indexenv">triangolo, <a href="#hevea_default387">5.14</a>
</li><li class="li-indexenv">trova, funzione, <a href="#hevea_default545">8.6</a>
</li><li class="li-indexenv">try, istruzione, <a href="#hevea_default1164">14.5</a>, <a href="#hevea_default1299">15.7</a>
</li><li class="li-indexenv">tupla, <a href="#hevea_default937">12.1</a>, <a href="#hevea_default966">12.3</a>, <a href="#hevea_default1025">12.7</a>, <a href="#hevea_default1039">12.9</a>
<ul class="indexenv"><li class="li-indexenv">
assegnazione, <a href="#hevea_default957">12.2</a>, <a href="#hevea_default971">12.3</a>, <a href="#hevea_default997">12.5</a>, <a href="#hevea_default1040">12.9</a>
</li><li class="li-indexenv">come chiave di dizionario, <a href="#hevea_default1018">12.6</a>, <a href="#hevea_default1106">13.9</a>
</li><li class="li-indexenv">con nome, <a href="#hevea_default1592">19.8</a>
</li><li class="li-indexenv">confronto, <a href="#hevea_default1464">18.3</a>
</li><li class="li-indexenv">in parentesi quadre, <a href="#hevea_default1020">12.6</a>
</li><li class="li-indexenv">metodi, <a href="#hevea_default1705">B.2</a>
</li><li class="li-indexenv">singleton, <a href="#hevea_default944">12.1</a>
</li><li class="li-indexenv">slicing, <a href="#hevea_default951">12.1</a>
</li></ul>
</li><li class="li-indexenv">tuple, funzione, <a href="#hevea_default945">12.1</a>
</li><li class="li-indexenv">turtle, <a href="#hevea_default388">5.14</a>
</li><li class="li-indexenv">type, <a href="#hevea_default74">1.8</a>
</li><li class="li-indexenv">type, funzione, <a href="#hevea_default1292">15.7</a>
<br>
<br>
</li><li class="li-indexenv">UnboundLocalError, <a href="#hevea_default891">11.7</a>
</li><li class="li-indexenv">uguaglianza e assegnazione, <a href="#hevea_default463">7.1</a>
</li><li class="li-indexenv">underscore, carattere, <a href="#hevea_default94">2.2</a>
</li><li class="li-indexenv">unicità, <a href="#hevea_default805">10.15</a>
</li><li class="li-indexenv">update, metodo, <a href="#hevea_default1014">12.6</a>
</li><li class="li-indexenv">uso prima di def, <a href="#hevea_default189">3.5</a>
<br>
<br>
</li><li class="li-indexenv">ValueError, <a href="#hevea_default364">5.11</a>, <a href="#hevea_default962">12.2</a>
</li><li class="li-indexenv">valore, <a href="#hevea_default31">1.5</a>, <a href="#hevea_default73">1.8</a>, <a href="#hevea_default750">10.10</a>, <a href="#hevea_default758">10.10</a>, <a href="#hevea_default907">11.9</a>
<ul class="indexenv"><li class="li-indexenv">
tupla, <a href="#hevea_default967">12.3</a>
</li></ul>
</li><li class="li-indexenv">valore (delle carte da gioco), <a href="#hevea_default1441">18.1</a>
</li><li class="li-indexenv">valore di default, <a href="#hevea_default1090">13.5</a>, <a href="#hevea_default1381">17.5</a>
<ul class="indexenv"><li class="li-indexenv">
evitare i mutabili, <a href="#hevea_default1429">17.13</a>
</li></ul>
</li><li class="li-indexenv">valore di ritorno, <a href="#hevea_default150">3.1</a>, <a href="#hevea_default231">3.13</a>, <a href="#hevea_default390">6.1</a>, <a href="#hevea_default1268">15.4</a>
<ul class="indexenv"><li class="li-indexenv">
tupla, <a href="#hevea_default968">12.3</a>
</li></ul>
</li><li class="li-indexenv">valore speciale<ul class="indexenv"><li class="li-indexenv">
False, <a href="#hevea_default310">5.2</a>
</li><li class="li-indexenv">None, <a href="#hevea_default215">3.10</a>, <a href="#hevea_default235">3.13</a>, <a href="#hevea_default396">6.1</a>, <a href="#hevea_default712">10.6</a>, <a href="#hevea_default735">10.8</a>
</li><li class="li-indexenv">True, <a href="#hevea_default309">5.2</a>
</li></ul>
</li><li class="li-indexenv">values, metodo, <a href="#hevea_default840">11.1</a>
</li><li class="li-indexenv">valutazione, <a href="#hevea_default97">2.3</a>, <a href="#hevea_default98">2.3</a>, <a href="#hevea_default131">2.9</a>
</li><li class="li-indexenv">variabile, <a href="#hevea_default89">2</a>, <a href="#hevea_default93">2.2</a>, <a href="#hevea_default125">2.9</a>
<ul class="indexenv"><li class="li-indexenv">
aggiornamento, <a href="#hevea_default465">7.2</a>
</li><li class="li-indexenv">globale, <a href="#hevea_default882">11.7</a>
<ul class="indexenv"><li class="li-indexenv">
aggiornamento, <a href="#hevea_default890">11.7</a>
</li></ul>
</li><li class="li-indexenv">locale, <a href="#hevea_default199">3.8</a>, <a href="#hevea_default230">3.13</a>
</li><li class="li-indexenv">temporanea, <a href="#hevea_default393">6.1</a>, <a href="#hevea_default447">6.10</a>, <a href="#hevea_default1669">A.3.2</a>
</li></ul>
</li><li class="li-indexenv">virgola mobile, <a href="#hevea_default483">7.5</a>
</li><li class="li-indexenv">virgolette, <a href="#hevea_default273">4.9</a>, <a href="#hevea_default1625">A.1</a>
</li><li class="li-indexenv">vorpale, <a href="#hevea_default418">6.5</a>
<br>
<br>
</li><li class="li-indexenv">Zipf, legge di, <a href="#hevea_default1121">13.12</a>
</li><li class="li-indexenv">zero, indice iniziale, <a href="#hevea_default509">8.1</a>, <a href="#hevea_default663">10.2</a>
</li><li class="li-indexenv">zip, funzione, <a href="#hevea_default992">12.5</a>
<ul class="indexenv"><li class="li-indexenv">
uso con dict, <a href="#hevea_default1013">12.6</a>
</li></ul>
</li><li class="li-indexenv">zip, oggetto, <a href="#hevea_default1044">12.9</a>
</li></ul></td></tr>
</table><!--CUT END -->
<!--HTMLFOOT-->
<p>
<a href="http://amzn.to/Owtmjy">Buy this book at Amazon.com</a>

</td>

<td width=130 valign="top">

<h4>Contribute</h4>
If you would like to make a contribution to support my books,
you can use the button below.  Thank you!

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="RAAYAZ7Y48S2A">
<table>
<tr><td><input type="hidden" name="on0" value="Pay what you want!">Pay what you want:</td></tr><tr><td><select name="os0">
	<option value="Small">Small $1.00 USD</option>
	<option value="Medium">Medium $5.00 USD</option>
	<option value="Large">Large $10.00 USD</option>
	<option value="X-Large">X-Large $20.00 USD</option>
	<option value="XX-Large">XX-Large $50.00 USD</option>
</select> </td></tr>
</table>
<input type="hidden" name="currency_code" value="USD">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_paynow_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

<p>
<h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onClick="javascript: pageTracker._trackPageview('/outbound/survey');">this short survey</a>.

<p>
<br>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=144933072X&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=1449307116&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=1449314635&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=0521725968&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

</td>
</tr>
</table>
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H<span class="c006"><sup>E</sup></span>V<span class="c006"><sup>E</sup></span>A</em></a><em>.</em></blockquote></body>
</html>
